/// <reference types="node" />

import { AbortSignalLike } from '@azure/abort-controller';
import { AmqpAnnotatedMessage } from '@azure/core-amqp';
import { Buffer as Buffer_2 } from 'buffer';
import { CommonClientOptions } from '@azure/core-client';
import { delay } from '@azure/core-amqp';
import { Delivery } from 'rhea-promise';
import { HttpMethods } from '@azure/core-rest-pipeline';
import Long from 'long';
import { MessagingError } from '@azure/core-amqp';
import { NamedKeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure/core-client';
import { OperationTracingOptions } from '@azure/core-tracing';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PageSettings } from '@azure/core-paging';
import { ProxySettings } from '@azure/core-rest-pipeline';
import { RetryMode } from '@azure/core-amqp';
import { RetryOptions } from '@azure/core-amqp';
import { SASCredential } from '@azure/core-auth';
import { ServiceClient } from '@azure/core-client';
import { TokenCredential } from '@azure/core-auth';
import { TokenType } from '@azure/core-amqp';
import { TracingContext } from '@azure/core-tracing';
import { UserAgentPolicyOptions } from '@azure/core-rest-pipeline';
import { WebSocketImpl } from 'rhea-promise';
import { WebSocketOptions } from '@azure/core-amqp';

/**
 * Represents type of `AuthorizationRule` in ATOM based management operations.
 */
export declare interface AuthorizationRule {
    /**
     * The claim type.
     */
    claimType: string;
    /**
     * The list of rights("Manage" | "Send" | "Listen").
     */
    accessRights?: ("Manage" | "Send" | "Listen")[];
    /**
     * The authorization rule key name.
     */
    keyName: string;
    /**
     * The primary key for the authorization rule.
     */
    primaryKey?: string;
    /**
     * The secondary key for the authorization rule.
     */
    secondaryKey?: string;
}

/**
 * Represents the correlation filter expression.
 * A CorrelationRuleFilter holds a set of conditions that are matched against user and system properties
 * of incoming messages from a Subscription.
 */
export declare interface CorrelationRuleFilter {
    /**
     * Value to be matched with the `correlationId` property of the incoming message.
     */
    correlationId?: string;
    /**
     * Value to be matched with the `messageId` property of the incoming message.
     */
    messageId?: string;
    /**
     * Value to be matched with the `to` property of the incoming message.
     */
    to?: string;
    /**
     * Value to be matched with the `replyTo` property of the incoming message.
     */
    replyTo?: string;
    /**
     * Value to be matched with the `subject` property of the incoming message.
     */
    subject?: string;
    /**
     * Value to be matched with the `sessionId` property of the incoming message.
     */
    sessionId?: string;
    /**
     * Value to be matched with the `replyToSessionId` property of the incoming message.
     */
    replyToSessionId?: string;
    /**
     * Value to be matched with the `contentType` property of the incoming message.
     */
    contentType?: string;
    /**
     * Value to be matched with the user properties of the incoming message.
     */
    applicationProperties?: {
        [key: string]: string | number | boolean | Date;
    };
}

/**
 * Options to configure the `createBatch` method on the `Sender`.
 * - `maxSizeInBytes`: The upper limit for the size of batch.
 *
 * Example usage:
 * ```js
 * {
 *     maxSizeInBytes: 1024 * 1024 // 1 MB
 * }
 * ```
 */
export declare interface CreateMessageBatchOptions extends OperationOptionsBase {
    /**
     * The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.
     */
    maxSizeInBytes?: number;
}

/**
 * Represents settable options on a queue
 */
export declare interface CreateQueueOptions extends OperationOptions {
    /**
     * Determines the amount of time in seconds in which a message should be locked for
     * processing by a receiver. After this period, the message is unlocked and available
     * for consumption by the next receiver.
     * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)
     *
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    lockDuration?: string;
    /**
     * Specifies the maximum queue size in megabytes. Any attempt to enqueue a message that
     * will cause the queue to exceed this value will fail.
     */
    maxSizeInMegabytes?: number;
    /**
     * The maximum message size in kilobytes for messages sent to this queue.
     *
     * (Configurable only for Premium Tier Service Bus namespace.)
     */
    maxMessageSizeInKilobytes?: number;
    /**
     * If enabled, the topic will detect duplicate messages within the time
     * span specified by the DuplicateDetectionHistoryTimeWindow property.
     * Settable only at queue creation time.
     */
    requiresDuplicateDetection?: boolean;
    /**
     * If set to true, the queue will be session-aware and only SessionReceiver
     * will be supported. Session-aware queues are not supported through REST.
     * Settable only at queue creation time.
     */
    requiresSession?: boolean;
    /**
     * Depending on whether DeadLettering is enabled, a message is automatically
     * moved to the dead-letter sub-queue or deleted if it has been stored in the
     * queue for longer than the specified time.
     * This value is overwritten by a TTL specified on the message
     * if and only if the message TTL is smaller than the TTL set on the queue.
     * This value is immutable after the Queue has been created.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    defaultMessageTimeToLive?: string;
    /**
     * If it is enabled and a message expires, the Service Bus moves the message
     * from the queue into the queue’s dead-letter sub-queue. If disabled,
     * message will be permanently deleted from the queue.
     * Settable only at queue creation time.
     */
    deadLetteringOnMessageExpiration?: boolean;
    /**
     * Specifies the time span during which the Service Bus detects message duplication.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    duplicateDetectionHistoryTimeWindow?: string;
    /**
     * The maximum delivery count of messages after which if it is still not settled,
     * gets moved to the dead-letter sub-queue.
     */
    maxDeliveryCount?: number;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations?: boolean;
    /**
     * Authorization rules on the queue
     */
    authorizationRules?: AuthorizationRule[];
    /**
     * Status of the messaging entity.
     */
    status?: EntityStatus;
    /**
     * Absolute URL or the name of the queue or topic the
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardTo?: string;
    /**
     * The user provided metadata information associated with the queue.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata?: string;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    autoDeleteOnIdle?: string;
    /**
     * Specifies whether the queue should be partitioned.
     */
    enablePartitioning?: boolean;
    /**
     * Absolute URL or the name of the queue or topic the dead-lettered
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardDeadLetteredMessagesTo?: string;
    /**
     * Specifies whether express entities are enabled on queue.
     */
    enableExpress?: boolean;
    /**
     * Availability status of the messaging entity.
     */
    availabilityStatus?: EntityAvailabilityStatus;
}

/**
 * Represents settable options on a subscription
 */
export declare interface CreateSubscriptionOptions extends OperationOptions {
    /**
     * The default lock duration is applied to subscriptions that do not define a lock
     * duration.
     * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)
     *
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    lockDuration?: string;
    /**
     * If set to true, the subscription will be session-aware and only SessionReceiver
     * will be supported. Session-aware subscription are not supported through REST.
     * Settable only at subscription creation time.
     */
    requiresSession?: boolean;
    /**
     * Determines how long a message lives in the subscription. Based on whether
     * dead-lettering is enabled, a message whose TTL has expired will either be moved
     * to the subscription’s associated DeadLtterQueue or permanently deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    defaultMessageTimeToLive?: string;
    /**
     * If it is enabled and a message expires, the Service Bus moves the message from
     * the queue into the subscription’s dead-letter sub-queue. If disabled, message
     * will be permanently deleted from the subscription’s main queue.
     * Settable only at subscription creation time.
     */
    deadLetteringOnMessageExpiration?: boolean;
    /**
     * Determines how the Service Bus handles a message that causes an exception during
     * a subscription’s filter evaluation. If the value is set to true, the message that
     * caused the exception will be moved to the subscription’s dead-letter sub-queue.
     * Otherwise, it will be discarded. By default this parameter is set to true,
     * allowing the user a chance to investigate the cause of the exception.
     * It can occur from a malformed message or some incorrect assumptions being made
     * in the filter about the form of the message. Settable only at topic creation time.
     */
    deadLetteringOnFilterEvaluationExceptions?: boolean;
    /**
     * Represents the options to create the default rule for the subscription.
     */
    defaultRuleOptions?: {
        /**
         * Name of the rule
         */
        name: string;
        /**
         * Defines the filter expression that the rule evaluates. For `SqlRuleFilter` input,
         * the expression string is interpreted as a SQL92 expression which must
         * evaluate to True or False. Only one between a `CorrelationRuleFilter` or
         * a `SqlRuleFilter` can be defined.
         */
        filter?: SqlRuleFilter | CorrelationRuleFilter;
        /**
         * The SQL like expression that can be executed on the message should the
         * associated filter apply.
         */
        action?: SqlRuleAction;
    };
    /**
     * The maximum delivery count of messages after which if it is still not settled,
     * gets moved to the dead-letter sub-queue.
     *
     */
    maxDeliveryCount?: number;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations?: boolean;
    /**
     * Status of the messaging entity.
     */
    status?: EntityStatus;
    /**
     * Absolute URL or the name of the queue or topic the
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardTo?: string;
    /**
     * The user provided metadata information associated with the subscription.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata?: string;
    /**
     * Absolute URL or the name of the queue or topic the dead-lettered
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardDeadLetteredMessagesTo?: string;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    autoDeleteOnIdle?: string;
    /**
     * Availability status of the messaging entity.
     */
    availabilityStatus?: EntityAvailabilityStatus;
}

/**
 * Represents settable options on a topic
 */
export declare interface CreateTopicOptions extends OperationOptions {
    /**
     * Determines how long a message lives in the associated subscriptions.
     * Subscriptions inherit the TTL from the topic unless they are created explicitly
     * with a smaller TTL. Based on whether dead-lettering is enabled, a message whose
     * TTL has expired will either be moved to the subscription’s associated dead-letter
     * sub-queue or will be permanently deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    defaultMessageTimeToLive?: string;
    /**
     * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message
     * that will cause the topic to exceed this value will fail. All messages that are
     * stored in the topic or any of its subscriptions count towards this value.
     * Multiple copies of a message that reside in one or multiple subscriptions count
     * as a single messages. For example, if message m exists once in subscription s1
     * and twice in subscription s2, m is counted as a single message.
     */
    maxSizeInMegabytes?: number;
    /**
     * The maximum message size in kilobytes for messages sent to this topic.
     *
     * (Configurable only for Premium Tier Service Bus namespace.)
     */
    maxMessageSizeInKilobytes?: number;
    /**
     * If enabled, the topic will detect duplicate messages within the time span
     * specified by the DuplicateDetectionHistoryTimeWindow property.
     * Settable only at topic creation time.
     */
    requiresDuplicateDetection?: boolean;
    /**
     * Specifies the time span during which the Service Bus will detect message duplication.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    duplicateDetectionHistoryTimeWindow?: string;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations?: boolean;
    /**
     * Authorization rules on the topic
     */
    authorizationRules?: AuthorizationRule[];
    /**
     * Status of the messaging entity.
     */
    status?: EntityStatus;
    /**
     * The user provided metadata information associated with the topic.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata?: string;
    /**
     * Specifies whether the topic supports message ordering.
     */
    supportOrdering?: boolean;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    autoDeleteOnIdle?: string;
    /**
     * Specifies whether the topic should be partitioned
     */
    enablePartitioning?: boolean;
    /**
     * Specifies whether express entities are enabled on topic.
     */
    enableExpress?: boolean;
    /**
     * Availability status of the messaging entity.
     */
    availabilityStatus?: EntityAvailabilityStatus;
}

/**
 * Describes the reason and error description for dead lettering a message using the `deadLetter()`
 * method on the message received from Service Bus.
 */
export declare interface DeadLetterOptions {
    /**
     * The reason for deadlettering the message.
     */
    deadLetterReason: string;
    /**
     * The error description for deadlettering the message.
     */
    deadLetterErrorDescription: string;
}

export { delay }

export { Delivery }

/**
 * Represents the result of list operation on entities which also contains the `continuationToken` to start iterating over from.
 */
export declare type EntitiesResponse<T extends object> = WithResponse<Array<T>> & Pick<PageSettings, "continuationToken">;

/**
 * Possible values for `availabilityStatus` of the Service Bus messaging entities.
 */
export declare type EntityAvailabilityStatus = "Available" | "Limited" | "Renaming" | "Restoring" | "Unknown";

/**
 * Possible values for `status` of the Service Bus messaging entities.
 */
export declare type EntityStatus = "Active" | "Creating" | "Deleting" | "ReceiveDisabled" | "SendDisabled" | "Disabled" | "Renaming" | "Restoring" | "Unknown";

/**
 * Options when getting an iterable iterator from Service Bus.
 */
export declare interface GetMessageIteratorOptions extends OperationOptionsBase {
}

/**
 * An individual header within a HttpHeaders collection.
 */
export declare interface HttpHeader {
    /**
     * The name of the header.
     */
    name: string;
    /**
     * The value of the header.
     */
    value: string;
}

/**
 * A collection of HTTP header key/value pairs.
 */
export declare interface HttpHeadersLike {
    /**
     * Set a header in this collection with the provided name and value. The name is
     * case-insensitive.
     * @param headerName - The name of the header to set. This value is case-insensitive.
     * @param headerValue - The value of the header to set.
     */
    set(headerName: string, headerValue: string | number): void;
    /**
     * Get the header value for the provided header name, or undefined if no header exists in this
     * collection with the provided name.
     * @param headerName - The name of the header.
     */
    get(headerName: string): string | undefined;
    /**
     * Get whether or not this header collection contains a header entry for the provided header name.
     */
    contains(headerName: string): boolean;
    /**
     * Remove the header with the provided headerName. Return whether or not the header existed and
     * was removed.
     * @param headerName - The name of the header to remove.
     */
    remove(headerName: string): boolean;
    /**
     * Get the headers that are contained this collection as an object.
     */
    rawHeaders(): RawHttpHeaders;
    /**
     * Get the headers that are contained in this collection as an array.
     */
    headersArray(): HttpHeader[];
    /**
     * Get the header names that are contained in this collection.
     */
    headerNames(): string[];
    /**
     * Get the header values that are contained in this collection.
     */
    headerValues(): string[];
    /**
     * Create a deep clone/copy of this HttpHeaders collection.
     */
    clone(): HttpHeadersLike;
    /**
     * Get the JSON object representation of this HTTP header collection.
     * The result is the same as `rawHeaders()`.
     */
    toJson(options?: {
        preserveCase?: boolean;
    }): RawHttpHeaders;
}

/**
 * The properties on an HTTP response which will always be present.
 */
export declare interface HttpResponse {
    /**
     * The raw request
     */
    request: WebResourceLike;
    /**
     * The HTTP response status (e.g. 200)
     */
    status: number;
    /**
     * The HTTP response headers.
     */
    headers: HttpHeadersLike;
}

/**
 * Determines if an error is of type `ServiceBusError`
 *
 * @param err - An error to check to see if it's of type ServiceBusError
 */
export declare function isServiceBusError(err: unknown): err is ServiceBusError;

/**
 * The general message handler interface (used for streamMessages).
 */
export declare interface MessageHandlers {
    /**
     * Handler that processes messages from service bus.
     *
     * @param message - A message received from Service Bus.
     */
    processMessage(message: ServiceBusReceivedMessage): Promise<void>;
    /**
     * Handler that processes errors that occur during receiving.
     *
     * This handler will be called for any error that occurs in the receiver when
     *   - receiving the message, or
     *   - executing your `processMessage` callback, or
     *   - receiver is completing the message on your behalf after successfully running your `processMessage` callback and `autoCompleteMessages` is enabled
     *   - receiver is abandoning the message on your behalf if running your `processMessage` callback fails and `autoCompleteMessages` is enabled
     *   - receiver is renewing the lock on your behalf due to auto lock renewal feature being enabled
     *
     * Note that when receiving messages in a stream using `subscribe()`, the receiver will automatically retry receiving messages on all errors unless
     * `close()` is called on the subscription. It is completely up to users to decide what errors are considered non-recoverable and to handle them
     * accordingly in this callback.
     * For a list of errors occurs within Service Bus, please refer to https://docs.microsoft.com/javascript/api/\@azure/service-bus/servicebuserror?view=azure-node-latest
     * @param args - The error and additional context to indicate where
     * the error originated.
     */
    processError(args: ProcessErrorArgs): Promise<void>;
}

export { MessagingError }

/**
 * Represents the metadata related to a service bus namespace.
 *
 */
export declare interface NamespaceProperties {
    /**
     * The time at which the namespace was created.
     */
    createdAt: Date;
    /**
     * The SKU/tier of the namespace.
     * "Basic", "Standard" and "Premium"
     */
    messagingSku: "Basic" | "Premium" | "Standard";
    /**
     * The last time at which the namespace was modified.
     */
    modifiedAt: Date;
    /**
     * Name of the namespace.
     */
    name: string;
    /**
     * Number of messaging units allocated for namespace.
     * Valid only for Premium namespaces.
     * messagingUnits would be set to `undefined` for Basic and Standard namespaces.
     */
    messagingUnits: number | undefined;
}

export { OperationOptions }

/**
 * NOTE: This type is intended to mirror the relevant fields and structure from `@azure/core-client` OperationOptions
 *
 * Options for configuring tracing and the abortSignal.
 */
export declare type OperationOptionsBase = Pick<OperationOptions, "abortSignal" | "tracingOptions">;

/**
 * Parses given connection string into the different properties applicable to Azure Service Bus.
 * The properties are useful to then construct a ServiceBusClient.
 * @param connectionString - The connection string associated with the Shared Access Policy created
 * for the Service Bus namespace, queue or topic.
 */
export declare function parseServiceBusConnectionString(connectionString: string): ServiceBusConnectionStringProperties;

/**
 * Describes the options passed to the `peekMessages` method on a receiver.
 */
export declare interface PeekMessagesOptions extends OperationOptionsBase {
    /**
     * The sequence number to start peeking messages from (inclusive).
     */
    fromSequenceNumber?: Long;
    /* Excluded from this release type: omitMessageBody */
}

/**
 * Arguments to the `processError` callback.
 */
export declare interface ProcessErrorArgs {
    /**
     * The error.
     */
    error: Error | ServiceBusError;
    /**
     * The operation where the error originated.
     *
     * 'abandon': Errors that occur when if `abandon` is triggered automatically.
     * 'complete': Errors that occur when autoComplete completes a message.
     * 'processMessageCallback': Errors thrown from the user's `processMessage` callback passed to `subscribe`.
     * 'receive': Errors thrown when receiving messages.
     * 'renewLock': Errors thrown when automatic lock renewal fails.
     */
    errorSource: "abandon" | "complete" | "processMessageCallback" | "receive" | "renewLock";
    /**
     * The entity path for the current receiver.
     */
    entityPath: string;
    /**
     * The fully qualified namespace for the Service Bus.
     */
    fullyQualifiedNamespace: string;
    /**
     * The identifier of the client that raised this event.
     */
    identifier: string;
}

/**
 * Represents the input for updateQueue.
 *
 */
export declare interface QueueProperties {
    /**
     * Name of the queue
     */
    readonly name: string;
    /**
     * Determines the amount of time in seconds in which a message should be locked for
     * processing by a receiver. After this period, the message is unlocked and available
     * for consumption by the next receiver.
     * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)
     *
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    lockDuration: string;
    /**
     * Specifies the maximum queue size in megabytes. Any attempt to enqueue a message that
     * will cause the queue to exceed this value will fail.
     */
    maxSizeInMegabytes: number;
    /**
     * The maximum message size in kilobytes for messages sent to this queue.
     *
     * Not applicable if service version "2017-04" is chosen when creating the `ServiceBusAdministrationClient`.
     */
    maxMessageSizeInKilobytes?: number;
    /**
     * If enabled, the topic will detect duplicate messages within the time
     * span specified by the DuplicateDetectionHistoryTimeWindow property.
     * Settable only at queue creation time.
     */
    readonly requiresDuplicateDetection: boolean;
    /**
     * If set to true, the queue will be session-aware and only SessionReceiver
     * will be supported. Session-aware queues are not supported through REST.
     * Settable only at queue creation time.
     */
    readonly requiresSession: boolean;
    /**
     * Depending on whether DeadLettering is enabled, a message is automatically
     * moved to the dead-letter sub-queue or deleted if it has been stored in the
     * queue for longer than the specified time.
     * This value is overwritten by a TTL specified on the message
     * if and only if the message TTL is smaller than the TTL set on the queue.
     * This value is immutable after the Queue has been created.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    defaultMessageTimeToLive: string;
    /**
     * If it is enabled and a message expires, the Service Bus moves the message
     * from the queue into the queue’s dead-letter sub-queue. If disabled,
     * message will be permanently deleted from the queue.
     * Settable only at queue creation time.
     */
    deadLetteringOnMessageExpiration: boolean;
    /**
     * Specifies the time span during which the Service Bus detects message duplication.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    duplicateDetectionHistoryTimeWindow: string;
    /**
     * The maximum delivery count of messages after which if it is still not settled,
     * gets moved to the dead-letter sub-queue.
     */
    maxDeliveryCount: number;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations: boolean;
    /**
     * Authorization rules on the queue
     */
    authorizationRules?: AuthorizationRule[];
    /**
     * Status of the messaging entity.
     */
    status: EntityStatus;
    /**
     * Absolute URL or the name of the queue or topic the
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardTo?: string;
    /**
     * The user provided metadata information associated with the queue.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata: string;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    autoDeleteOnIdle: string;
    /**
     * Specifies whether the queue should be partitioned.
     */
    readonly enablePartitioning: boolean;
    /**
     * Absolute URL or the name of the queue or topic the dead-lettered
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardDeadLetteredMessagesTo?: string;
    /**
     * Specifies whether express entities are enabled on queue.
     */
    readonly enableExpress: boolean;
    /**
     * Availability status of the messaging entity.
     */
    readonly availabilityStatus: EntityAvailabilityStatus;
}

/**
 * Represents runtime info attributes of a queue entity
 */
export declare interface QueueRuntimeProperties {
    /**
     * Name of the queue
     */
    name: string;
    /**
     * Created at timestamp
     */
    createdAt: Date;
    /**
     * Updated at timestamp
     */
    modifiedAt: Date;
    /**
     * Accessed at timestamp
     */
    accessedAt: Date;
    /**
     * The entity's message count.
     *
     */
    totalMessageCount?: number;
    /**
     * The number of active messages in the queue.
     */
    activeMessageCount: number;
    /**
     * The number of messages that have been dead lettered.
     */
    deadLetterMessageCount: number;
    /**
     * The number of scheduled messages.
     */
    scheduledMessageCount: number;
    /**
     * The number of messages transferred to another queue, topic, or subscription
     */
    transferMessageCount: number;
    /**
     * The number of messages transferred to the dead letter queue.
     */
    transferDeadLetterMessageCount: number;
    /**
     * The entity's size in bytes.
     *
     */
    sizeInBytes?: number;
}

/**
 * A HttpHeaders collection represented as a simple JSON object.
 */
export declare type RawHttpHeaders = {
    [headerName: string]: string;
};

/**
 * Options when receiving a batch of messages from Service Bus.
 */
export declare interface ReceiveMessagesOptions extends OperationOptionsBase {
    /**
     * The maximum amount of time to wait for messages to arrive.
     *  **Default**: `60000` milliseconds.
     */
    maxWaitTimeInMs?: number;
}

export { RetryMode }

export { RetryOptions }

/**
 * Represents all the attributes of a rule.
 */
export declare interface RuleProperties {
    /**
     * Name of the rule
     */
    readonly name: string;
    /**
     * Defines the filter expression that the rule evaluates. For `SqlRuleFilter` input,
     * the expression string is interpreted as a SQL92 expression which must
     * evaluate to True or False. Only one between a `CorrelationRuleFilter` or
     * a `SqlRuleFilter` can be defined.
     */
    filter: SqlRuleFilter | CorrelationRuleFilter;
    /**
     * The SQL like expression that can be executed on the message should the
     * associated filter apply.
     */
    action: SqlRuleAction;
}

/**
 * All operations return promises that resolve to an object that has the relevant output.
 * These objects also have a property called `_response` that you can use if you want to
 * access the direct response from the service.
 */
export declare class ServiceBusAdministrationClient extends ServiceClient {
    /**
     * Reference to the endpoint as extracted from input connection string.
     */
    private endpoint;
    /**
     * Reference to the endpoint with protocol prefix as extracted from input connection string.
     */
    private endpointWithProtocol;
    private serviceVersion;
    /**
     * Singleton instances of serializers used across the various operations.
     */
    private namespaceResourceSerializer;
    private queueResourceSerializer;
    private topicResourceSerializer;
    private subscriptionResourceSerializer;
    private ruleResourceSerializer;
    /**
     * Credentials used to generate tokens as required for the various operations.
     */
    private credentials;
    /**
     * Initializes a new instance of the ServiceBusAdministrationClient class.
     * @param connectionString - The connection string needed for the client to connect to Azure.
     * @param options - PipelineOptions
     */
    constructor(connectionString: string, options?: ServiceBusAdministrationClientOptions);
    /**
     *
     * @param fullyQualifiedNamespace - The fully qualified namespace of your Service Bus instance which is
     * likely to be similar to <yournamespace>.servicebus.windows.net.
     * @param credential - A credential object used by the client to get the token to authenticate the connection
     * with the Azure Service Bus. See &commat;azure/identity for creating the credentials.
     * If you're using your own implementation of the `TokenCredential` interface against AAD, then set the "scopes" for service-bus
     * to be `["https://servicebus.azure.net//user_impersonation"]` to get the appropriate token.
     * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`
     * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively
     * in `AzureNamedKeyCredential`.
     * @param options - PipelineOptions
     */
    constructor(fullyQualifiedNamespace: string, credential: TokenCredential | NamedKeyCredential, options?: ServiceBusAdministrationClientOptions);
    /**
     * Returns an object representing the metadata related to a service bus namespace.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     */
    getNamespaceProperties(operationOptions?: OperationOptions): Promise<WithResponse<NamespaceProperties>>;
    /**
     * Creates a queue with given name, configured using the given options
     * @param options - Options to configure the Queue being created(For example, you can configure a queue to support partitions or sessions)
     *  and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    createQueue(queueName: string, options?: CreateQueueOptions): Promise<WithResponse<QueueProperties>>;
    /**
     * Returns an object representing the Queue and its properties.
     * If you want to get the Queue runtime info like message count details, use `getQueueRuntimeProperties` API.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getQueue(queueName: string, operationOptions?: OperationOptions): Promise<WithResponse<QueueProperties>>;
    /**
     * Returns an object representing the Queue runtime info like message count details.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getQueueRuntimeProperties(queueName: string, operationOptions?: OperationOptions): Promise<WithResponse<QueueRuntimeProperties>>;
    /**
     * Returns a list of objects, each representing a Queue along with its properties.
     * If you want to get the runtime info of the queues like message count, use `getQueuesRuntimeProperties` API instead.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    private getQueues;
    private listQueuesPage;
    private listQueuesAll;
    /**
     * Returns an async iterable iterator to list all the queues.
     *
     * .byPage() returns an async iterable iterator to list the queues in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listQueues(options?: OperationOptions): PagedAsyncIterableIterator<QueueProperties, EntitiesResponse<QueueProperties>>;
    /**
     * Returns a list of objects, each representing a Queue's runtime info like message count details.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    private getQueuesRuntimeProperties;
    private listQueuesRuntimePropertiesPage;
    private listQueuesRuntimePropertiesAll;
    /**
     * Returns an async iterable iterator to list runtime info of the queues.
     *
     * .byPage() returns an async iterable iterator to list runtime info of the queues in pages.
     *
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listQueuesRuntimeProperties(options?: OperationOptions): PagedAsyncIterableIterator<QueueRuntimeProperties, EntitiesResponse<QueueRuntimeProperties>>;
    /**
     * Updates the queue based on the queue properties provided.
     * All queue properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getQueue()`, update the desired properties in it, and then pass the modified object to `updateQueue()`.
     *
     * The properties that cannot be updated are marked as readonly in the `QueueProperties` interface.
     *
     * @param queue - Object representing the properties of the queue and the raw response.
     * `requiresSession`, `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the queue.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    updateQueue(queue: WithResponse<QueueProperties>, operationOptions?: OperationOptions): Promise<WithResponse<QueueProperties>>;
    /**
     * Deletes a queue.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    deleteQueue(queueName: string, operationOptions?: OperationOptions): Promise<WithResponse<{}>>;
    /**
     * Checks whether a given queue exists or not.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     */
    queueExists(queueName: string, operationOptions?: OperationOptions): Promise<boolean>;
    /**
     * Creates a topic with given name, configured using the given options
     * @param options - Options to configure the Topic being created(For example, you can configure a topic to support partitions)
     * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    createTopic(topicName: string, options?: CreateTopicOptions): Promise<WithResponse<TopicProperties>>;
    /**
     * Returns an object representing the Topic and its properties.
     * If you want to get the Topic runtime info like subscription count details, use `getTopicRuntimeProperties` API.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getTopic(topicName: string, operationOptions?: OperationOptions): Promise<WithResponse<TopicProperties>>;
    /**
     * Returns an object representing the Topic runtime info like subscription count.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getTopicRuntimeProperties(topicName: string, operationOptions?: OperationOptions): Promise<WithResponse<TopicRuntimeProperties>>;
    /**
     * Returns a list of objects, each representing a Topic along with its properties.
     * If you want to get the runtime info of the topics like subscription count, use `getTopicsRuntimeProperties` API instead.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    private getTopics;
    private listTopicsPage;
    private listTopicsAll;
    /**
     * Returns an async iterable iterator to list all the topics.
     *
     * .byPage() returns an async iterable iterator to list the topics in pages.
     *
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listTopics(options?: OperationOptions): PagedAsyncIterableIterator<TopicProperties, EntitiesResponse<TopicProperties>>;
    /**
     * Returns a list of objects, each representing a Topic's runtime info like subscription count.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    private getTopicsRuntimeProperties;
    private listTopicsRuntimePropertiesPage;
    private listTopicsRuntimePropertiesAll;
    /**
     * Returns an async iterable iterator to list runtime info of the topics.
     *
     * .byPage() returns an async iterable iterator to list runtime info of the topics in pages.
     *
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listTopicsRuntimeProperties(options?: OperationOptions): PagedAsyncIterableIterator<TopicRuntimeProperties, EntitiesResponse<TopicRuntimeProperties>>;
    /**
     * Updates the topic based on the topic properties provided.
     * All topic properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getTopic()`, update the desired properties in it, and then pass the modified object to `updateTopic()`.
     *
     * The properties that cannot be updated are marked as readonly in the `TopicProperties` interface.
     *
     * @param topic - Object representing the properties of the topic and the raw response.
     * `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the topic.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    updateTopic(topic: WithResponse<TopicProperties>, operationOptions?: OperationOptions): Promise<WithResponse<TopicProperties>>;
    /**
     * Deletes a topic.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    deleteTopic(topicName: string, operationOptions?: OperationOptions): Promise<WithResponse<{}>>;
    /**
     * Checks whether a given topic exists or not.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     */
    topicExists(topicName: string, operationOptions?: OperationOptions): Promise<boolean>;
    /**
     * Creates a subscription with given name, configured using the given options
     * @param options - Options to configure the Subscription being created(For example, you can configure a Subscription to support partitions or sessions)
     * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    createSubscription(topicName: string, subscriptionName: string, options?: CreateSubscriptionOptions): Promise<WithResponse<SubscriptionProperties>>;
    /**
     * Returns an object representing the Subscription and its properties.
     * If you want to get the Subscription runtime info like message count details, use `getSubscriptionRuntimeProperties` API.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getSubscription(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<WithResponse<SubscriptionProperties>>;
    /**
     * Returns an object representing the Subscription runtime info like message count details.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getSubscriptionRuntimeProperties(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<WithResponse<SubscriptionRuntimeProperties>>;
    /**
     * Returns a list of objects, each representing a Subscription along with its properties.
     * If you want to get the runtime info of the subscriptions like message count, use `getSubscriptionsRuntimeProperties` API instead.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    private getSubscriptions;
    private listSubscriptionsPage;
    private listSubscriptionsAll;
    /**
     *
     * Returns an async iterable iterator to list all the subscriptions
     * under the specified topic.
     *
     * .byPage() returns an async iterable iterator to list the subscriptions in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listSubscriptions(topicName: string, options?: OperationOptions): PagedAsyncIterableIterator<SubscriptionProperties, EntitiesResponse<SubscriptionProperties>>;
    /**
     * Returns a list of objects, each representing a Subscription's runtime info like message count details.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    private getSubscriptionsRuntimeProperties;
    private listSubscriptionsRuntimePropertiesPage;
    private listSubscriptionsRuntimePropertiesAll;
    /**
     * Returns an async iterable iterator to list runtime info of the subscriptions
     * under the specified topic.
     *
     * .byPage() returns an async iterable iterator to list runtime info of subscriptions in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listSubscriptionsRuntimeProperties(topicName: string, options?: OperationOptions): PagedAsyncIterableIterator<SubscriptionRuntimeProperties, EntitiesResponse<SubscriptionRuntimeProperties>>;
    /**
     * Updates the subscription based on the subscription properties provided.
     * All subscription properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getSubscription()`, update the desired properties in it, and then pass the modified object to `updateSubscription()`.
     *
     * The properties that cannot be updated are marked as readonly in the `SubscriptionProperties` interface.
     * @param subscription - Object representing the properties of the subscription and the raw response.
     * `subscriptionName`, `topicName`, and `requiresSession` can't be updated after creating the subscription.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    updateSubscription(subscription: WithResponse<SubscriptionProperties>, operationOptions?: OperationOptions): Promise<WithResponse<SubscriptionProperties>>;
    /**
     * Deletes a subscription.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    deleteSubscription(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<WithResponse<{}>>;
    /**
     * Checks whether a given subscription exists in the topic or not.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     */
    subscriptionExists(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<boolean>;
    /**
     * Creates a rule with given name, configured using the given options.
     * @param ruleFilter - Defines the filter expression that the rule evaluates.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    createRule(topicName: string, subscriptionName: string, ruleName: string, ruleFilter: SqlRuleFilter | CorrelationRuleFilter, operationOptions?: OperationOptions): Promise<WithResponse<RuleProperties>>;
    /**
     * Creates a rule with given name, configured using the given options.
     * @param ruleFilter - Defines the filter expression that the rule evaluates.
     * @param ruleAction - The SQL like expression that can be executed on the message should the associated filter apply.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    createRule(topicName: string, subscriptionName: string, ruleName: string, ruleFilter: SqlRuleFilter | CorrelationRuleFilter, ruleAction: SqlRuleAction, operationOptions?: OperationOptions): Promise<WithResponse<RuleProperties>>;
    /**
     * Returns an object representing the Rule with the given name along with all its properties.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    getRule(topicName: string, subscriptionName: string, ruleName: string, operationOptions?: OperationOptions): Promise<WithResponse<RuleProperties>>;
    /**
     * Lists existing rules.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    private getRules;
    private listRulesPage;
    private listRulesAll;
    /**
     * Returns an async iterable iterator to list all the rules
     * under the specified subscription.
     *
     * .byPage() returns an async iterable iterator to list the rules in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listRules(topicName: string, subscriptionName: string, options?: OperationOptions): PagedAsyncIterableIterator<RuleProperties, EntitiesResponse<RuleProperties>>;
    /**
     * Updates properties on the Rule by the given name based on the given options.
     * All rule properties must be set even if one of them is being updated.
     * Therefore, the suggested flow is to use the output from `getRule()`, update the desired properties in it, and then pass the modified object to `updateRule()`.
     *
     * @param rule - Options to configure the Rule being updated and the raw response.
     * For example, you can configure the filter to apply on associated Topic/Subscription.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    updateRule(topicName: string, subscriptionName: string, rule: WithResponse<RuleProperties>, operationOptions?: OperationOptions): Promise<WithResponse<RuleProperties>>;
    /**
     * Deletes a rule.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    deleteRule(topicName: string, subscriptionName: string, ruleName: string, operationOptions?: OperationOptions): Promise<WithResponse<{}>>;
    /**
     * Checks whether a given rule exists or not.
     *
     */
    ruleExists(topicName: string, subscriptionName: string, ruleName: string, operationOptions?: OperationOptions): Promise<boolean>;
    /**
     * Creates or updates a resource based on `isUpdate` parameter.
     */
    private putResource;
    /**
     * Gets a resource.
     */
    private getResource;
    /**
     * Lists existing resources
     */
    private listResources;
    /**
     * Deletes a resource.
     */
    private deleteResource;
    private getUrl;
    private getSubscriptionPath;
    private getRulePath;
    private getMarkerFromNextLinkUrl;
    private buildNamespacePropertiesResponse;
    private buildListQueuesResponse;
    private buildListQueuesRuntimePropertiesResponse;
    private buildQueueResponse;
    private buildQueueRuntimePropertiesResponse;
    private buildListTopicsResponse;
    private buildListTopicsRuntimePropertiesResponse;
    private buildTopicResponse;
    private buildTopicRuntimePropertiesResponse;
    private buildListSubscriptionsResponse;
    private buildListSubscriptionsRuntimePropertiesResponse;
    private buildSubscriptionResponse;
    private buildSubscriptionRuntimePropertiesResponse;
    private buildListRulesResponse;
    private buildRuleResponse;
    private throwIfInvalidContinuationToken;
}

/**
 * Represents the client options of the `ServiceBusAdministrationClient`.
 */
export declare interface ServiceBusAdministrationClientOptions extends CommonClientOptions {
    /**
     * Service version of the ATOM API.
     *
     * Currently supported = "2021-05" | "2017-04"
     *
     * Defaults to "2021-05".
     */
    serviceVersion?: "2021-05" | "2017-04";
}

/**
 * A client that can create Sender instances for sending messages to queues and
 * topics as well as Receiver instances to receive messages from queues and subscriptions.
 */
export declare class ServiceBusClient {
    private _connectionContext;
    private _clientOptions;
    /**
     * The fully qualified namespace of the Service Bus instance for which this client is created.
     * This is likely to be similar to <yournamespace>.servicebus.windows.net.
     */
    fullyQualifiedNamespace: string;
    /**
     * The name used to identify this ServiceBusClient.
     * If not specified or empty, a random unique one will be generated.
     */
    identifier: string;
    /**
     * Creates an instance of the ServiceBusClient class which can be used to create senders and receivers to
     * the Azure Service Bus namespace provided in the connection string. No connection is made to the service
     * until the senders/receivers created with the client are used to send/receive messages.
     * @param connectionString - A connection string for Azure Service Bus namespace.
     * NOTE: this connection string can contain an EntityPath, which is ignored.
     * @param options - Options for the service bus client.
     */
    constructor(connectionString: string, options?: ServiceBusClientOptions);
    /**
     * Creates an instance of the ServiceBusClient class which can be used to create senders and receivers to
     * the Azure Service Bus namespace provided. No connection is made to the service until
     * the senders/receivers created with the client are used to send/receive messages.
     * @param fullyQualifiedNamespace - The full namespace of your Service Bus instance which is
     * likely to be similar to <yournamespace>.servicebus.windows.net.
     * @param credential - A credential object used by the client to get the token to authenticate the connection
     * with the Azure Service Bus. See &commat;azure/identity for creating the credentials.
     * If you're using an own implementation of the `TokenCredential` interface against AAD, then set the "scopes" for service-bus
     * to be `["https://servicebus.azure.net//user_impersonation"]` to get the appropriate token.
     * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`
     * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively
     * in `AzureNamedKeyCredential`.
     * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`
     * without using a connection string. This field maps to `signature` in `AzureSASCredential`.
     * @param options - A set of options to apply when configuring the client.
     * - `retryOptions`   : Configures the retry policy for all the operations on the client.
     * For example, `{ "maxRetries": 4 }` or `{ "maxRetries": 4, "retryDelayInMs": 30000 }`.
     * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.
     */
    constructor(fullyQualifiedNamespace: string, credential: TokenCredential | NamedKeyCredential | SASCredential, options?: ServiceBusClientOptions);
    /**
     * Creates a receiver for an Azure Service Bus queue. No connection is made
     * to the service until one of the methods on the receiver is called.
     *
     * To target sub queues like the dead letter queue or the transfer dead letter queue, provide the
     * `subQueue` in the options. To learn more about dead letter queues, see
     * https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues
     *
     * You can choose between two receive modes:  "peekLock" (default) and "receiveAndDelete".
     * - In peekLock mode, the receiver has a lock on the message for the duration specified on the
     * queue.
     * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.
     *
     * Messages that are not settled within the lock duration will be redelivered as many times as
     * the max delivery count set on the queue, after which they get sent to a separate dead letter
     * queue.
     *
     * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or
     * deadletterMessage() methods on the receiver.
     *
     * More information about how peekLock and message settlement works here:
     * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock
     *
     * @param queueName - The name of the queue to receive from.
     * @param options - Options to pass the receiveMode, defaulted to peekLock.
     * @returns A receiver that can be used to receive, peek and settle messages.
     */
    createReceiver(queueName: string, options?: ServiceBusReceiverOptions): ServiceBusReceiver;
    /**
     * Creates a receiver for an Azure Service Bus subscription. No connection is made
     * to the service until one of the methods on the receiver is called.
     *
     * To target sub queues like the dead letter queue or the transfer dead letter queue, provide the
     * `subQueue` in the options. To learn more about dead letter queues, see
     * https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues
     *
     * You can choose between two receive modes:  "peekLock" (default) and "receiveAndDelete".
     * - In peekLock mode, the receiver has a lock on the message for the duration specified on the
     * queue.
     * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.
     *
     * Messages that are not settled within the lock duration will be redelivered as many times as
     * the max delivery count set on the subscription, after which they get sent to a separate dead letter
     * queue.
     *
     * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or
     * deadletterMessage() methods on the receiver.
     *
     * More information about how peekLock and message settlement works here:
     * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock
     *
     * @param topicName - Name of the topic for the subscription we want to receive from.
     * @param subscriptionName - Name of the subscription (under the `topic`) that we want to receive from.
     * @param options - Options to pass the receiveMode, defaulted to peekLock.
     * @returns A receiver that can be used to receive, peek and settle messages.
     */
    createReceiver(topicName: string, subscriptionName: string, options?: ServiceBusReceiverOptions): ServiceBusReceiver;
    /**
     * Creates an instance of {@link ServiceBusRuleManager} that is used to manage
     * the rules for a subscription.
     *
     * @param topicName - the topic to create {@link ServiceBusRuleManager}
     * @param subscriptionName - the subscription specific to the specified topic to create a {@link ServiceBusRuleManager} for.
     * @returns a {@link ServiceBusRuleManager} scoped to the specified subscription and topic.
     */
    createRuleManager(topicName: string, subscriptionName: string): ServiceBusRuleManager;
    /**
     * Creates a receiver for a session enabled Azure Service Bus queue.
     *
     * You can choose between two receive modes:  "peekLock" (default) and "receiveAndDelete".
     * - In peekLock mode, the receiver has a lock on the message for the duration specified on the
     * queue.
     * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.
     *
     * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or
     * deadletterMessage() methods on the receiver.
     *
     * More information about how peekLock and message settlement works here:
     * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock
     *
     * @param queueName - The name of the queue to receive from.
     * @param sessionId - The id of the session from which messages need to be received
     * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.
     * @returns A receiver that can be used to receive, peek and settle messages.
     */
    acceptSession(queueName: string, sessionId: string, options?: ServiceBusSessionReceiverOptions): Promise<ServiceBusSessionReceiver>;
    /**
     * Creates a receiver for a session enabled Azure Service Bus subscription.
     *
     * You can choose between two receive modes:  "peekLock" (default) and "receiveAndDelete".
     * - In peekLock mode, the receiver has a lock on the message for the duration specified on the
     * queue.
     * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.
     *
     * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or
     * deadletterMessage() methods on the receiver.
     *
     * More information about how peekLock and message settlement works here:
     * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock
     *
     * @param topicName - Name of the topic for the subscription we want to receive from.
     * @param subscriptionName - Name of the subscription (under the `topic`) that we want to receive from.
     * @param sessionId - The id of the session from which messages need to be received
     * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.
     * @returns A receiver that can be used to receive, peek and settle messages.
     */
    acceptSession(topicName: string, subscriptionName: string, sessionId: string, options?: ServiceBusSessionReceiverOptions): Promise<ServiceBusSessionReceiver>;
    /**
     * Creates a receiver for the next available session in a session-enabled Azure Service Bus queue.
     *
     * You can choose between two receive modes:  "peekLock" (default) and "receiveAndDelete".
     * - In peekLock mode, the receiver has a lock on the message for the duration specified on the
     * queue.
     * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.
     *
     * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or
     * deadletterMessage() methods on the receiver.
     *
     * More information about how peekLock and message settlement works here:
     * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock
     *
     * @param queueName - The name of the queue to receive from.
     * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.
     * @returns A receiver that can be used to receive, peek and settle messages.
     */
    acceptNextSession(queueName: string, options?: ServiceBusSessionReceiverOptions): Promise<ServiceBusSessionReceiver>;
    /**
     * Creates a receiver for the next available session in a session-enabled Azure Service Bus subscription.
     *
     * You can choose between two receive modes:  "peekLock" (default) and "receiveAndDelete".
     * - In peekLock mode, the receiver has a lock on the message for the duration specified on the
     * queue.
     * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.
     *
     * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or
     * deadletterMessage() methods on the receiver.
     *
     * More information about how peekLock and message settlement works here:
     * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock
     *
     * @param topicName - Name of the topic for the subscription we want to receive from.
     * @param subscriptionName - Name of the subscription (under the `topic`) that we want to receive from.
     * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.
     * @returns A receiver that can be used to receive, peek and settle messages.
     */
    acceptNextSession(topicName: string, subscriptionName: string, options?: ServiceBusSessionReceiverOptions): Promise<ServiceBusSessionReceiver>;
    /**
     * Creates a Sender which can be used to send messages, schedule messages to be
     * sent at a later time and cancel such scheduled messages. No connection is made
     * to the service until one of the methods on the sender is called.
     * @param queueOrTopicName - The name of a queue or topic to send messages to.
     */
    createSender(queueOrTopicName: string, options?: ServiceBusSenderOptions): ServiceBusSender;
    /**
     * Closes the underlying AMQP connection.
     * NOTE: this will also disconnect any Receiver or Sender instances created from this
     * instance.
     */
    close(): Promise<void>;
}

/**
 * Describes the options that can be provided while creating the ServiceBusClient.
 *
 * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.
 *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection
 * over a WebSocket.
 *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection
 * over a WebSocket.
 * - `retryOptions`     : The retry options for all the operations on the client.
 *    - `maxRetries` : The number of times the operation can be retried in case of a retryable error.
 *    - `maxRetryDelayInMs`: The maximum delay between retries. Applicable only when performing exponential retries.
 *    - `mode`: Which retry mode to apply, specified by the `RetryMode` enum. Options are `Exponential` and `Fixed`. Defaults to `Fixed`.
 *    - `retryDelayInMs`: Amount of time to wait in milliseconds before making the next attempt. When `mode` is set to `Exponential`,
 *       this is used to compute the exponentially increasing delays between retries. Default: 30000 milliseconds.
 *    - `timeoutInMs`: Amount of time in milliseconds to wait before the operation times out. This will trigger a retry if there are any
 *       retry attempts remaining. Minimum value: 60000 milliseconds.
 */
export declare interface ServiceBusClientOptions {
    /**
     * ID to identify this client. This can be used to correlate logs and exceptions.
     */
    identifier?: string;
    /**
     * A custom endpoint to use when connecting to the Service Bus service.
     * This can be useful when your network does not allow connecting to the
     * standard Azure Service Bus endpoint address, but does allow connecting
     * through an intermediary.
     *
     * Example: "https://my.custom.endpoint:100/"
     */
    customEndpointAddress?: string;
    /**
     * Retry policy options that determine the mode, number of retries, retry interval etc.
     */
    retryOptions?: RetryOptions;
    /**
     * Options to configure the channelling of the AMQP connection over Web Sockets.
     */
    webSocketOptions?: WebSocketOptions;
    /**
     * Options for adding user agent details to outgoing requests.
     */
    userAgentOptions?: UserAgentPolicyOptions;
}

/**
 * The set of properties that comprise a Service Bus connection string.
 */
export declare interface ServiceBusConnectionStringProperties {
    /**
     * The fully qualified Service Bus namespace extracted from the "Endpoint" in the
     * connection string. This is likely to be similar to `{yournamespace}.servicebus.windows.net`.
     * This is typically used to construct the ServiceBusClient.
     */
    fullyQualifiedNamespace: string;
    /**
     * The value for "Endpoint" in the connection string.
     */
    endpoint: string;
    /**
     * The value for "EntityPath" in the connection string which would be the name of the queue or
     * topic associated with the connection string.
     * Connection string from a Shared Access Policy created at the namespace level
     * will not have the EntityPath in it.
     */
    entityPath?: string;
    /**
     * The value for "SharedAccessKey" in the connection string. This along with the "SharedAccessKeyName"
     * in the connection string is used to generate a SharedAccessSignature which can be used authorize
     * the connection to the service.
     */
    sharedAccessKey?: string;
    /**
     * The value for "SharedAccessKeyName" in the connection string. This along with the "SharedAccessKey"
     * in the connection string is used to generate a SharedAccessSignature which can be used authorize
     * the connection to the service.
     */
    sharedAccessKeyName?: string;
    /**
     * The value for "SharedAccessSignature" in the connection string. This is typically not present in the
     * connection string generated for a Shared Access Policy. It is instead generated by the
     * user and appended to the connection string for ease of use.
     */
    sharedAccessSignature?: string;
}

/**
 * Errors that occur within Service Bus.
 */
export declare class ServiceBusError extends MessagingError {
    /**
     * The reason for the failure.
     *
     * - **GeneralError**: The exception was the result of a general error within the client library.
     * - **MessagingEntityNotFound**: A Service Bus resource cannot be found by the Service Bus service.
     * - **MessageLockLost**: The lock on the message is lost. Callers should attempt to receive and process the message again.
     * - **MessageNotFound**: The requested message was not found.
     * - **MessageSizeExceeded**: A message is larger than the maximum size allowed for its transport.
     * - **MessagingEntityAlreadyExists**: An entity with the same name exists under the same namespace.
     * - **MessagingEntityDisabled**: The Messaging Entity is disabled. Enable the entity again using Portal.
     * - **QuotaExceeded**: The quota applied to an Service Bus resource has been exceeded while interacting with the Azure Service Bus service.
     * - **ServiceBusy**: The Azure Service Bus service reports that it is busy in response to a client request to perform an operation.
     * - **ServiceTimeout**: An operation or other request timed out while interacting with the Azure Service Bus service.
     * - **ServiceCommunicationProblem**: There was a general communications error encountered when interacting with the Azure Service Bus service.
     * - **SessionCannotBeLocked**: The requested session cannot be locked.
     * - **SessionLockLost**: The lock on the session has expired. Callers should request the session again.
     * - **UnauthorizedAccess"**: The user doesn't have access to the entity.
     */
    code: ServiceBusErrorCode;
    /**
     * @param message - The error message that provides more information about the error.
     * @param code - The reason for the failure.
     */
    constructor(message: string, code: ServiceBusErrorCode);
    /**
     * @param messagingError - An error whose properties will be copied to the ServiceBusError.
     */
    constructor(messagingError: MessagingError);
    private static normalizeMessagingCode;
}

/**
 * Service Bus failure codes.
 */
export declare type ServiceBusErrorCode = 
/**
* The exception was the result of a general error within the client library.
*/
"GeneralError"
/**
* A Service Bus resource cannot be found by the Service Bus service.
*/
| "MessagingEntityNotFound"
/**
* The lock on the message is lost. Callers should attempt to receive and process the message again.
*/
| "MessageLockLost"
/**
* The requested message was not found.
*/
| "MessageNotFound"
/**
* A message is larger than the maximum size allowed for its transport.
*/
| "MessageSizeExceeded"
/**
* An entity with the same name exists under the same namespace.
*/
| "MessagingEntityAlreadyExists"
/**
* The Messaging Entity is disabled. Enable the entity again using Portal.
*/
| "MessagingEntityDisabled"
/**
* The quota applied to an Service Bus resource has been exceeded while interacting with the Azure Service Bus service.
*/
| "QuotaExceeded"
/**
* The Azure Service Bus service reports that it is busy in response to a client request to perform an operation.
*/
| "ServiceBusy"
/**
* An operation or other request timed out while interacting with the Azure Service Bus service.
*/
| "ServiceTimeout"
/**
* There was a general communications error encountered when interacting with the Azure Service Bus service.
*/
| "ServiceCommunicationProblem"
/**
* The requested session cannot be locked.
*/
| "SessionCannotBeLocked"
/**
* The lock on the session has expired. Callers should request the session again.
*/
| "SessionLockLost"
/**
* The user doesn't have access to the entity.
*/
| "UnauthorizedAccess";

/**
 * Describes the message to be sent to Service Bus.
 */
export declare interface ServiceBusMessage {
    /**
     * The message body that needs to be sent or is received.
     * If the application receiving the message is not using this SDK,
     * convert your body payload to a byte array or Buffer for better
     * cross-language compatibility.
     */
    body: any;
    /**
     * The message identifier is an
     * application-defined value that uniquely identifies the message and its payload.
     *
     * Note: Numbers that are not whole integers are not allowed.
     */
    messageId?: string | number | Buffer_2;
    /**
     * The content type of the message. Optionally describes
     * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for
     * example "application/json".
     */
    contentType?: string;
    /**
     * The correlation identifier that allows an
     * application to specify a context for the message for the purposes of correlation, for example
     * reflecting the MessageId of a message that is being replied to.
     * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.
     */
    correlationId?: string | number | Buffer_2;
    /**
     * The partition key for sending a message to a partitioned entity.
     * Maximum length is 128 characters. For {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning | partitioned entities},
     * setting this value enables assigning related messages to the same internal partition,
     * so that submission sequence order is correctly recorded. The partition is chosen by a hash
     * function over this value and cannot be chosen directly.
     * - For session-aware entities, the `sessionId` property overrides this value.
     * - For non partitioned entities, partition key will be ignored
     *
     */
    partitionKey?: string;
    /**
     * The partition key for sending a message into an entity
     * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a
     * transfer queue in the scope of a transaction, this value selects the transfer queue partition:
     * This is functionally equivalent to `partitionKey` property and ensures that messages are kept
     * together and in order as they are transferred.
     * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via | Transfers and Send Via}.
     */
    /**
     * The session identifier for a session-aware entity. Maximum
     * length is 128 characters. For session-aware entities, this application-defined value specifies
     * the session affiliation of the message. Messages with the same session identifier are subject
     * to summary locking and enable exact in-order processing and demultiplexing. For
     * session-unaware entities, this value is ignored.
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions | Message Sessions}.
     */
    sessionId?: string;
    /**
     * The session identifier augmenting the `replyTo` address.
     * Maximum length is 128 characters. This value augments the ReplyTo information and specifies
     * which SessionId should be set for the reply when sent to the reply entity.
     * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.
     */
    replyToSessionId?: string;
    /**
     * The message’s time to live value. This value is the relative
     * duration after which the message expires, starting from the instant the message has been
     * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,
     * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level
     * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is
     * silently adjusted if it does. See
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-expiration | Expiration}.
     */
    timeToLive?: number;
    /**
     * The application specific label. This property enables the
     * application to indicate the purpose of the message to the receiver in a standardized. fashion,
     * similar to an email subject line. The mapped AMQP property is "subject".
     */
    subject?: string;
    /**
     * The "to" address. This property is reserved for future use in routing
     * scenarios and presently ignored by the broker itself. Applications can use this value in
     * rule-driven {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding | auto-forward chaining}
     * scenarios to indicate the intended logical destination of the message.
     */
    to?: string;
    /**
     * The address of an entity to send replies to. This optional and
     * application-defined value is a standard way to express a reply path to the receiver of the
     * message. When a sender expects a reply, it sets the value to the absolute or relative path of
     * the queue or topic it expects the reply to be sent to. See
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.
     */
    replyTo?: string;
    /**
     * The date and time in UTC at which the message will
     * be enqueued. This property returns the time in UTC; when setting the property, the
     * supplied DateTime value must also be in UTC. This value is for delayed message sending.
     * It is utilized to delay messages sending to a specific time in the future. Message enqueuing
     * time does not mean that the message will be sent at the same time. It will get enqueued,
     * but the actual sending time depends on the queue's workload and its state.
     */
    scheduledEnqueueTimeUtc?: Date;
    /**
     * The application specific properties which can be
     * used for custom message metadata.
     */
    applicationProperties?: {
        [key: string]: number | boolean | string | Date | null;
    };
}

/**
 * A batch of messages that you can create using the {@link createBatch} method.
 *
 */
export declare interface ServiceBusMessageBatch {
    /**
     * Size of the batch in bytes after the events added to it have been encoded into a single AMQP
     * message.
     * @readonly
     */
    readonly sizeInBytes: number;
    /**
     * Number of messages added to the batch.
     * @readonly
     */
    readonly count: number;
    /**
     * The maximum size of the batch, in bytes. The `tryAddMessage` function on the batch will return `false`
     * if the message being added causes the size of the batch to exceed this limit. Use the `createMessageBatch()` method on
     * the `Sender` to set the maxSizeInBytes.
     * @readonly
     */
    readonly maxSizeInBytes: number;
    /**
     * Adds a message to the batch if permitted by the batch's size limit.
     * **NOTE**: Always remember to check the return value of this method, before calling it again
     * for the next event.
     *
     * @param message - The message to add to the batch.
     * @returns A boolean value indicating if the message has been added to the batch or not.
     */
    tryAddMessage(message: ServiceBusMessage | AmqpAnnotatedMessage, options?: TryAddOptions): boolean;
    /* Excluded from this release type: _generateMessage */
    /* Excluded from this release type: _messageSpanContexts */
}

/**
 * Describes the message received from Service Bus during peek operations and so cannot be settled.
 */
export declare interface ServiceBusReceivedMessage extends ServiceBusMessage {
    /**
     * The reason for deadlettering the message.
     * @readonly
     */
    readonly deadLetterReason?: string;
    /**
     * The error description for deadlettering the message.
     * @readonly
     */
    readonly deadLetterErrorDescription?: string;
    /**
     * The lock token is a reference to the lock that is being held by the broker in
     * `peekLock` receive mode. Locks are used internally settle messages as explained in the
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement | product documentation in more detail}
     * - Not applicable when the message is received in `receiveAndDelete` receive mode.
     * mode.
     * @readonly
     */
    readonly lockToken?: string;
    /**
     * Number of deliveries that have been attempted for this message. The count is
     * incremented when a message lock expires, or the message is explicitly abandoned using the
     * `abandon()` method on the message.
     * @readonly
     */
    readonly deliveryCount?: number;
    /**
     * The UTC instant at which the message has been accepted and stored in Service Bus.
     * @readonly
     */
    readonly enqueuedTimeUtc?: Date;
    /**
     * The UTC instant at which the message is marked for removal and no longer available for
     * retrieval from the entity due to expiration. This property is computed from 2 other properties
     * on the message: `enqueuedTimeUtc` + `timeToLive`.
     */
    readonly expiresAtUtc?: Date;
    /**
     * The UTC instant until which the message is held locked in the queue/subscription.
     * When the lock expires, the `deliveryCount` is incremented and the message is again available
     * for retrieval.
     * - Not applicable when the message is received in `receiveAndDelete` receive mode.
     * mode.
     */
    lockedUntilUtc?: Date;
    /**
     * The original sequence number of the message. For
     * messages that have been auto-forwarded, this property reflects the sequence number that had
     * first been assigned to the message at its original point of submission.
     * @readonly
     */
    readonly enqueuedSequenceNumber?: number;
    /**
     * The unique number assigned to a message by Service Bus.
     * The sequence number is a unique 64-bit integer assigned to a message as it is accepted
     * and stored by the broker and functions as its true identifier. For partitioned entities,
     * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.
     * They roll over to 0 when the 48-64 bit range is exhausted.
     *
     * **Max safe integer** that Javascript currently supports is `2^53 - 1`. The sequence number
     * is an AMQP `Long` type which can be upto 64 bits long. To represent that we are using a
     * library named {@link https://github.com/dcodeIO/long.js | long.js}. We expect customers
     * to use the **`Long`** type exported by this library.
     * @readonly
     */
    readonly sequenceNumber?: Long;
    /**
     * The name of the queue or subscription that this message
     * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered
     * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the
     * entity in which the message was dead-lettered.
     * @readonly
     */
    readonly deadLetterSource?: string;
    /**
     * State of the message can be active, deferred or scheduled. Deferred messages have deferred state,
     * scheduled messages have scheduled state, all other messages have active state.
     */
    readonly state: "active" | "deferred" | "scheduled";
    /**
     * The underlying raw amqp message.
     * @readonly
     */
    readonly _rawAmqpMessage: AmqpAnnotatedMessage;
}

/**
 * A receiver that does not handle sessions.
 */
export declare interface ServiceBusReceiver {
    /**
     * A name used to identify the receiver. This can be used to correlate logs and exceptions.
     * If not specified or empty, a random unique one will be generated.
     */
    identifier: string;
    /**
     * Streams messages to message handlers.
     * @param handlers - A handler that gets called for messages and errors.
     * @param options - Options for subscribe.
     * @returns An object that can be closed, sending any remaining messages to `handlers` and
     * stopping new messages from arriving.
     */
    subscribe(handlers: MessageHandlers, options?: SubscribeOptions): {
        /**
         * Causes the subscriber to stop receiving new messages.
         */
        close(): Promise<void>;
    };
    /**
     * Returns an iterator that can be used to receive messages from Service Bus.
     *
     * @param options - A set of options to control the receive operation.
     * - `abortSignal`: The signal to use to abort the ongoing operation.
     *
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws Error if current receiver is already in state of receiving messages.
     * @throws `ServiceBusError` if the service returns an error while receiving messages.
     */
    getMessageIterator(options?: GetMessageIteratorOptions): AsyncIterableIterator<ServiceBusReceivedMessage>;
    /**
     * Returns a promise that resolves to an array of messages received from Service Bus.
     *
     * @param maxMessageCount - The maximum number of messages to receive.
     * @param options - A set of options to control the receive operation.
     * - `maxWaitTimeInMs`: The maximum time to wait for the first message before returning an empty array if no messages are available.
     * - `abortSignal`: The signal to use to abort the ongoing operation.
     * @returns A promise that resolves with an array of messages.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws Error if current receiver is already in state of receiving messages.
     * @throws `ServiceBusError` if the service returns an error while receiving messages.
     */
    receiveMessages(maxMessageCount: number, options?: ReceiveMessagesOptions): Promise<ServiceBusReceivedMessage[]>;
    /**
     * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.
     * @param sequenceNumbers - The sequence number or an array of sequence numbers for the messages that need to be received.
     * @param options - Options bag to pass an abort signal or tracing options.
     * @returns A list of messages identified by the given sequenceNumbers or an empty list if no messages are found.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while receiving deferred messages.
     */
    receiveDeferredMessages(sequenceNumbers: Long | Long[], options?: OperationOptionsBase): Promise<ServiceBusReceivedMessage[]>;
    /**
     * Peek the next batch of active messages (including deferred but not deadlettered messages) on the
     * queue or subscription without modifying them.
     * - The first call to `peekMessages()` fetches the first active message. Each subsequent call fetches the
     * subsequent message.
     * - Unlike a "received" message, "peeked" message is a read-only version of the message.
     * It cannot be `Completed/Abandoned/Deferred/Deadlettered`.
     * @param maxMessageCount - The maximum number of messages to peek.
     * @param options - Options that allow to specify the maximum number of messages to peek,
     * the sequenceNumber to start peeking from or an abortSignal to abort the operation.
     */
    peekMessages(maxMessageCount: number, options?: PeekMessagesOptions): Promise<ServiceBusReceivedMessage[]>;
    /**
     * Path of the entity for which the receiver has been created.
     */
    entityPath: string;
    /**
     * The receive mode used to create the receiver.
     */
    receiveMode: "peekLock" | "receiveAndDelete";
    /**
     * Returns `true` if either the receiver or the client that created it has been closed.
     * @readonly
     */
    isClosed: boolean;
    /**
     * Closes the receiver.
     * Once closed, the receiver cannot be used for any further operations.
     * Use the `createReceiver()` method on the ServiceBusClient to create a new Receiver.
     */
    close(): Promise<void>;
    /**
     * Removes the message from Service Bus.
     *
     * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link is closed by the library due to network loss or service error.
     * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled.
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     */
    completeMessage(message: ServiceBusReceivedMessage): Promise<void>;
    /**
     * The lock held on the message by the receiver is let go, making the message available again in
     * Service Bus for another receive operation.
     *
     * @throws `ServiceBusError` with the code `SessionLockLost` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link is closed by the library due to network loss or service error.
     * @throws `ServiceBusError` with the code `MessageLockLost` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled.
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws `ServiceBusError` with the code `ServiceTimeout` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param propertiesToModify - The properties of the message to modify while abandoning the message.
     */
    abandonMessage(message: ServiceBusReceivedMessage, propertiesToModify?: {
        [key: string]: number | boolean | string | Date | null;
    }): Promise<void>;
    /**
     * Defers the processing of the message. Save the `sequenceNumber` of the message, in order to
     * receive it message again in the future using the `receiveDeferredMessage` method.
     *
     * @throws `ServiceBusError` with the code `SessionLockLost` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link is closed by the library due to network loss or service error.
     * @throws `ServiceBusError` with the code `MessageLockLost` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled.
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws `ServiceBusError` with the code `ServiceTimeout` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param propertiesToModify - The properties of the message to modify while deferring the message
     */
    deferMessage(message: ServiceBusReceivedMessage, propertiesToModify?: {
        [key: string]: number | boolean | string | Date | null;
    }): Promise<void>;
    /**
     * Moves the message to the deadletter sub-queue. To receive a deadletted message, create a new
     * QueueClient/SubscriptionClient using the path for the deadletter sub-queue.
     *
     * @throws `ServiceBusError` with the code `SessionLockLost` (for messages from a Queue/Subscription with sessions enabled)
     * if the AMQP link with which the message was received is no longer alive. This can
     * happen either because the lock on the session expired or the receiver was explicitly closed by
     * the user or the AMQP link is closed by the library due to network loss or service error.
     * @throws `ServiceBusError` with the code `MessageLockLost` (for messages from a Queue/Subscription with sessions not enabled)
     * if the lock on the message has expired or the AMQP link with which the message was received is
     * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the
     * AMQP link got closed by the library due to network loss or service error.
     * @throws Error if the message is already settled.
     * property on the message if you are not sure whether the message is settled.
     * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode
     * are pre-settled. To avoid this error, update your code to not settle a message which is received
     * in this mode.
     * @throws `ServiceBusError` with the code `ServiceTimeout` if Service Bus does not acknowledge the request to settle
     * the message in time. The message may or may not have been settled successfully.
     *
     * @param options - The DeadLetter options that can be provided while
     * rejecting the message.
     */
    deadLetterMessage(message: ServiceBusReceivedMessage, options?: DeadLetterOptions & {
        [key: string]: number | boolean | string | Date | null;
    }): Promise<void>;
    /**
     * Renews the lock on the message for the duration as specified during the Queue/Subscription
     * creation.
     * - Check the `lockedUntilUtc` property on the message for the time when the lock expires.
     * - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,
     * before its lock expires, then the message lands back in the Queue/Subscription for the next
     * receive operation.
     *
     * @returns New lock token expiry date and time in UTC format.
     * @throws Error if the underlying connection, client or receiver is closed.
     * @throws ServiceBusError if the service returns an error while renewing message lock.
     */
    renewMessageLock(message: ServiceBusReceivedMessage): Promise<Date>;
}

/**
 * Options to use when creating a receiver.
 */
export declare interface ServiceBusReceiverOptions {
    /**
     * Represents the receive mode for the receiver.
     *
     * In receiveAndDelete mode, messages are deleted from Service Bus as they are received.
     *
     * In peekLock mode, the receiver has a lock on the message for the duration specified on the
     * queue/subscription.
     *
     * Messages that are not settled within the lock duration will be redelivered as many times as
     * the max delivery count set on the queue/subscription, after which they get sent to a separate
     * dead letter queue.
     *
     * You can settle a message by calling complete(), abandon(), defer() or deadletter() methods on
     * the message.
     *
     * More information about how peekLock and message settlement works here:
     * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock
     *
     */
    receiveMode?: "peekLock" | "receiveAndDelete";
    /**
     * Represents the sub queue that is applicable for any queue or subscription.
     * Valid values are "deadLetter" and "transferDeadLetter". To learn more about dead letter queues,
     * see https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues
     */
    subQueueType?: "deadLetter" | "transferDeadLetter";
    /**
     * The maximum duration, in milliseconds, that the lock on the message will be renewed automatically by the client.
     * This auto renewal stops once the message is settled.
     *
     * - **Default**: `300 * 1000` milliseconds (5 minutes).
     * - **To disable autolock renewal**, set this to `0`.
     *
     * **Example:**
     *
     *    If the message lock expires in 2 minutes and your message processing time is 8 minutes...
     *
     *    Set maxAutoLockRenewalDurationInMs to 10 minutes, and the message lock will be automatically renewed for 4 times
     *    (equivalent to having the message locked for 4 times its lock duration by leveraging the lock renewals).
     */
    maxAutoLockRenewalDurationInMs?: number;
    /**
     * Option to disable the client from running JSON.parse() on the message body when receiving the message.
     * Not applicable if the message was sent with AMQP body type value or sequence. Use this option when you
     * prefer to work directly with the bytes present in the message body than have the client attempt to parse it.
     */
    skipParsingBodyAsJson?: boolean;
    /**
     * Whether to skip converting Date type on properties of message annotations
     * or application properties into numbers when receiving the message. By
     * default, properties of Date type is converted into UNIX epoch number for
     * compatibility.
     */
    skipConvertingDate?: boolean;
    /**
     * Sets the name to identify the receiver. This can be used to correlate logs and exceptions.
     * If not specified or empty, a random unique one will be used.
     */
    identifier?: string;
}

/**
 * Allows rules for a subscription to be managed. This rule manager requires only Listen claims, whereas the
 * {@link ServiceBusAdministrationClient} requires Manage claims.
 */
export declare interface ServiceBusRuleManager {
    /**
     * Adds a rule to the current subscription to filter the messages reaching from topic to the subscription.
     *
     * @param ruleName - the name of the rule
     * @param filter - the filter expression that the rule evaluates.
     * @param options - The options that can be used to abort, trace and control other configurations on the request.
     */
    createRule(ruleName: string, filter: SqlRuleFilter | CorrelationRuleFilter, options?: OperationOptionsBase): Promise<void>;
    /**
     * Adds a rule to the current subscription to filter the messages reaching from topic to the subscription.
     *
     * @param ruleName - the name of the rule
     * @param filter - the filter expression that the rule evaluates.
     * @param ruleAction - The SQL like expression that can be executed on the message should the associated filter apply.
     * @param options - The options that can be used to abort, trace and control other configurations on the request.
     */
    createRule(ruleName: string, filter: SqlRuleFilter | CorrelationRuleFilter, ruleAction?: SqlRuleAction, options?: OperationOptionsBase): Promise<void>;
    /**
     * Deletes a rule.
     *
     * @param ruleName - the name of the rule
     */
    deleteRule(ruleName: string, options?: OperationOptionsBase): Promise<void>;
    /**
     * Returns an async iterable iterator to list all the rules
     * under the specified subscription.
     *
     * .byPage() returns an async iterable iterator to list the rules in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listRules(options?: OperationOptions): PagedAsyncIterableIterator<RuleProperties>;
}

/**
 * A Sender can be used to send messages, schedule messages to be sent at a later time
 * and cancel such scheduled messages.
 * Use the `createSender` function on the ServiceBusClient to instantiate a Sender.
 * The Sender class is an abstraction over the underlying AMQP sender link.
 */
export declare interface ServiceBusSender {
    /**
     * A name used to identify the sender. This can be used to correlate logs and exceptions.
     * If not specified or empty, a random unique one will be generated.
     */
    identifier: string;
    /**
     * Sends the given messages after creating an AMQP Sender link if it doesn't already exist.
     *
     * - To send messages to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`
     * and/or `partitionKey` properties respectively on the messages.
     * - All messages passed to the same sendMessages() call should have the same `sessionId` (if using
     *  sessions) and the same `partitionKey` (if using partitions).
     *
     * **Note:**
     *
     *    __If you want to send messages of size greater than 1MB, please send individual messages instead of sending a batched message or an array of messages like below.__
     *
     *  `await sender.sendMessages(message);`
     *
     * __This is because the batched messages are not capable of sending the larger messages yet. You'll hit the `force detached` error in this case otherwise. Read [service-bus-premium-messaging#large-messages-support](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-premium-messaging#large-messages-support). More info at [#23014](https://github.com/Azure/azure-sdk-for-js/pull/23014).__
     *
     * @param messages - A single message or an array of messages or a batch of messages created via the createBatch()
     * method to send.
     * @param options - Options bag to pass an abort signal or tracing options.
     * @throws `ServiceBusError` with the code `MessageSizeExceeded` if the provided messages do not fit in a single `ServiceBusMessageBatch`.
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws `ServiceBusError` if the service returns an error while sending messages to the service.
     */
    sendMessages(messages: ServiceBusMessage | ServiceBusMessage[] | ServiceBusMessageBatch | AmqpAnnotatedMessage | AmqpAnnotatedMessage[], options?: OperationOptionsBase): Promise<void>;
    /**
     * Creates an instance of `ServiceBusMessageBatch` to which one can add messages until the maximum supported size is reached.
     * The batch can be passed to the {@link send} method to send the messages to Azure Service Bus.
     * @param options - Configures the behavior of the batch.
     * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.
     *
     * @throws `ServiceBusError` if an error is encountered while sending a message.
     * @throws Error if the underlying connection or sender has been closed.
     */
    createMessageBatch(options?: CreateMessageBatchOptions): Promise<ServiceBusMessageBatch>;
    /**
     * Returns `true` if either the sender or the client that created it has been closed.
     * @readonly
     */
    isClosed: boolean;
    /**
     * Schedules given messages to appear on Service Bus Queue/Subscription at a later time.
     *
     * @param messages - Message or an array of messages that need to be scheduled.
     * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
     * @param options - Options bag to pass an abort signal or tracing options.
     * @returns The sequence numbers of messages that were scheduled.
     * You will need the sequence number if you intend to cancel the scheduling of the messages.
     * Save the `Long` type as-is in your application without converting to number. Since JavaScript
     * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws `ServiceBusError` if the service returns an error while scheduling messages.
     */
    scheduleMessages(messages: ServiceBusMessage | ServiceBusMessage[] | AmqpAnnotatedMessage | AmqpAnnotatedMessage[], scheduledEnqueueTimeUtc: Date, options?: OperationOptionsBase): Promise<Long[]>;
    /**
     * Cancels multiple messages that were scheduled to appear on a ServiceBus Queue/Subscription.
     * @param sequenceNumbers - Sequence number or an array of sequence numbers of the messages to be cancelled.
     * @param options - Options bag to pass an abort signal or tracing options.
     * @throws Error if the underlying connection, client or sender is closed.
     * @throws `ServiceBusError` if the service returns an error while canceling scheduled messages.
     */
    cancelScheduledMessages(sequenceNumbers: Long | Long[], options?: OperationOptionsBase): Promise<void>;
    /**
     * Path of the entity for which the sender has been created.
     */
    entityPath: string;
    /**
     * Closes the underlying AMQP sender link.
     * Once closed, the sender cannot be used for any further operations.
     * Use the `createSender` function on the QueueClient or TopicClient to instantiate a new Sender
     *
     */
    close(): Promise<void>;
}

/**
 * Options to use when creating a sender.
 */
export declare interface ServiceBusSenderOptions {
    /**
     * Sets the name to identify the sender. This can be used to correlate logs and exceptions.
     * If not specified or empty, a random unique one will be used.
     */
    identifier?: string;
}

/**
 *A receiver that handles sessions, including renewing the session lock.
 */
export declare interface ServiceBusSessionReceiver extends ServiceBusReceiver {
    /**
     * The session ID.
     */
    readonly sessionId: string;
    /**
     * The time in UTC until which the session is locked.
     * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock
     * duration as specified during the Queue/Subscription creation.
     *
     * Will return undefined until a AMQP receiver link has been successfully set up for the session.
     *
     * @readonly
     */
    readonly sessionLockedUntilUtc: Date;
    /**
     * Streams messages to message handlers.
     * @param handlers - A handler that gets called for messages and errors.
     * @param options - Options for subscribe.
     * @returns An object that can be closed, sending any remaining messages to `handlers` and
     * stopping new messages from arriving.
     */
    subscribe(handlers: MessageHandlers, options?: SubscribeOptions): {
        /**
         * Causes the subscriber to stop receiving new messages.
         */
        close(): Promise<void>;
    };
    /**
     * Renews the lock on the session.
     */
    renewSessionLock(options?: OperationOptionsBase): Promise<Date>;
    /**
     * Gets the state of the Session. For more on session states, see
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}
     * @param options - Options bag to pass an abort signal or tracing options.
     * @returns The state of that session
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while retrieving session state.
     */
    getSessionState(options?: OperationOptionsBase): Promise<any>;
    /**
     * Sets the state on the Session. For more on session states, see
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}
     * @param state - The state that needs to be set.
     * @param options - Options bag to pass an abort signal or tracing options.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while setting the session state.
     *
     */
    setSessionState(state: any, options?: OperationOptionsBase): Promise<void>;
}

/**
 * Describes the options passed to the `acceptSession` and `acceptNextSession` methods
 * when using a Queue/Subscription that has sessions enabled.
 */
export declare interface ServiceBusSessionReceiverOptions extends OperationOptionsBase {
    /**
     * Represents the receive mode for the receiver.
     *
     * In receiveAndDelete mode, messages are deleted from Service Bus as they are received.
     *
     * In peekLock mode, the receiver has a lock on the message for the duration specified on the
     * queue/subscription.
     *
     * Messages that are not settled within the lock duration will be redelivered as many times as
     * the max delivery count set on the queue/subscription, after which they get sent to a separate
     * dead letter queue.
     *
     * You can settle a message by calling complete(), abandon(), defer() or deadletter() methods on
     * the message.
     *
     * More information about how peekLock and message settlement works here:
     * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock
     *
     */
    receiveMode?: "peekLock" | "receiveAndDelete";
    /**
     * The maximum duration, in milliseconds, that the lock on the session will be renewed automatically by the client.
     *
     * - **Default**: `300000` milliseconds (5 minutes).
     * - **To disable autolock renewal**, set this to `0`.
     *
     * **Example:**
     *
     *    If the lock expires in 2 minutes and your processing time is 8 minutes...
     *
     *    Set maxAutoLockRenewalDurationInMs to 10 minutes, and the lock will be automatically renewed about 4 times
     *    (equivalent to having the session locked for 4 times its lock duration by leveraging the lock renewals).
     */
    maxAutoLockRenewalDurationInMs?: number;
    /**
     * Option to disable the client from running JSON.parse() on the message body when receiving the message.
     * Not applicable if the message was sent with AMQP body type value or sequence. Use this option when you
     * prefer to work directly with the bytes present in the message body than have the client attempt to parse it.
     */
    skipParsingBodyAsJson?: boolean;
    /**
     * Whether to skip converting Date type on properties of message annotations
     * or application properties into numbers when receiving the message. By
     * default, properties of Date type is converted into UNIX epoch number for
     * compatibility.
     */
    skipConvertingDate?: boolean;
    /**
     * Sets the name to identify the session receiver. This can be used to correlate logs and exceptions.
     * If not specified or empty, a random unique one will be used.
     */
    identifier?: string;
}

/**
 * Represents all possible fields on SqlRuleAction
 */
export declare type SqlRuleAction = {
    /**
     * SQL expression to use in the rule action.
     */
    sqlExpression?: string;
    /**
     * SQL parameters to the SQL expression in the rule action.
     */
    sqlParameters?: {
        [key: string]: string | number | boolean;
    };
};

/**
 * Represents all possible fields on SqlRuleFilter
 */
export declare interface SqlRuleFilter {
    /**
     * SQL expression to use in the rule filter. It is evaluated against the messages'
     * user-defined properties and system properties. All system properties will be prefixed with
     * `sys.` in the condition expression.
     * Defaults to creating a true filter if none specified
     */
    sqlExpression: string;
    /**
     * SQL parameters to the SQL expression in the rule filter.
     */
    sqlParameters?: {
        [key: string]: string | number | boolean;
    };
}

/**
 * Options used when subscribing to a Service Bus queue or subscription.
 */
export declare interface SubscribeOptions extends OperationOptionsBase {
    /**
     * Indicates whether the message should be settled automatically based on the result from the
     * user provided `processMessage` callback.
     *
     * - If an error is thrown from the `processMessage` callback the message will be abandoned
     *   using `receiver.abandonMessage()`. Doing so will make the message available again from the
     *   queue/subscription and the delivery count will be incremented.
     * - If NO error is thrown from `processMessage` the message will be completed
     *   using `receiver.completeMessage()`. Doing so removes the message from the queue/subscription.
     *
     * This option is ignored if messages are received in the `receiveAndDelete` receive mode or if
     * the message is already settled in the user provided message callback.
     *
     * - **Default**: `true`.
     */
    autoCompleteMessages?: boolean;
    /**
     * The maximum number of concurrent calls that the library
     * can make to the user's message handler. Once this limit has been reached, more messages will
     * not be received until atleast one of the calls to the user's message handler has completed.
     * - **Default**: `1`.
     */
    maxConcurrentCalls?: number;
}

/**
 * Represents the input for updateSubscription.
 *
 */
export declare interface SubscriptionProperties {
    /**
     * Name of the subscription
     */
    readonly subscriptionName: string;
    /**
     * Name of the topic
     */
    readonly topicName: string;
    /**
     * The default lock duration is applied to subscriptions that do not define a lock
     * duration.
     * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)
     *
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    lockDuration: string;
    /**
     * If set to true, the subscription will be session-aware and only SessionReceiver
     * will be supported. Session-aware subscription are not supported through REST.
     * Settable only at subscription creation time.
     */
    readonly requiresSession: boolean;
    /**
     * Determines how long a message lives in the subscription. Based on whether
     * dead-lettering is enabled, a message whose TTL has expired will either be moved
     * to the subscription’s associated DeadLtterQueue or permanently deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    defaultMessageTimeToLive: string;
    /**
     * If it is enabled and a message expires, the Service Bus moves the message from
     * the queue into the subscription’s dead-letter sub-queue. If disabled, message
     * will be permanently deleted from the subscription’s main queue.
     * Settable only at subscription creation time.
     */
    deadLetteringOnMessageExpiration: boolean;
    /**
     * Determines how the Service Bus handles a message that causes an exception during
     * a subscription’s filter evaluation. If the value is set to true, the message that
     * caused the exception will be moved to the subscription’s dead-letter sub-queue.
     * Otherwise, it will be discarded. By default this parameter is set to true,
     * allowing the user a chance to investigate the cause of the exception.
     * It can occur from a malformed message or some incorrect assumptions being made
     * in the filter about the form of the message. Settable only at topic creation time.
     */
    deadLetteringOnFilterEvaluationExceptions: boolean;
    /**
     * The maximum delivery count of messages after which if it is still not settled,
     * gets moved to the dead-letter sub-queue.
     *
     */
    maxDeliveryCount: number;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations: boolean;
    /**
     * Status of the messaging entity.
     */
    status: EntityStatus;
    /**
     * Absolute URL or the name of the queue or topic the
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardTo?: string;
    /**
     * The user provided metadata information associated with the subscription.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata?: string;
    /**
     * Absolute URL or the name of the queue or topic the dead-lettered
     * messages are to be forwarded to.
     * For example, an absolute URL input would be of the form
     * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`
     */
    forwardDeadLetteredMessagesTo?: string;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    autoDeleteOnIdle: string;
    /**
     * Availability status of the messaging entity.
     */
    availabilityStatus?: EntityAvailabilityStatus;
}

/**
 * Represents runtime info attributes of a subscription entity
 */
export declare interface SubscriptionRuntimeProperties {
    /**
     * Name of the subscription
     */
    subscriptionName: string;
    /**
     * Name of the topic
     */
    topicName: string;
    /**
     * The entity's message count.
     *
     */
    totalMessageCount: number;
    /**
     * The number of active messages in the queue.
     */
    activeMessageCount: number;
    /**
     * The number of messages that have been dead lettered.
     */
    deadLetterMessageCount: number;
    /**
     * The number of messages transferred to another queue, topic, or subscription
     */
    transferMessageCount: number;
    /**
     * The number of messages transferred to the dead letter queue.
     */
    transferDeadLetterMessageCount: number;
    /**
     * Created at timestamp
     */
    createdAt: Date;
    /**
     * Updated at timestamp
     */
    modifiedAt: Date;
    /**
     * Accessed at timestamp
     */
    accessedAt: Date;
}

export { TokenCredential }

export { TokenType }

/**
 * Represents the input for updateTopic.
 *
 */
export declare interface TopicProperties {
    /**
     * Name of the topic
     */
    readonly name: string;
    /**
     * Determines how long a message lives in the associated subscriptions.
     * Subscriptions inherit the TTL from the topic unless they are created explicitly
     * with a smaller TTL. Based on whether dead-lettering is enabled, a message whose
     * TTL has expired will either be moved to the subscription’s associated dead-letter
     * sub-queue or will be permanently deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    defaultMessageTimeToLive: string;
    /**
     * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message
     * that will cause the topic to exceed this value will fail. All messages that are
     * stored in the topic or any of its subscriptions count towards this value.
     * Multiple copies of a message that reside in one or multiple subscriptions count
     * as a single messages. For example, if message m exists once in subscription s1
     * and twice in subscription s2, m is counted as a single message.
     */
    maxSizeInMegabytes: number;
    /**
     * The maximum message size in kilobytes for messages sent to this queue/topic.
     *
     * Not applicable if service version "2017-04" is chosen when creating the `ServiceBusAdministrationClient`.
     */
    maxMessageSizeInKilobytes?: number;
    /**
     * If enabled, the topic will detect duplicate messages within the time span
     * specified by the DuplicateDetectionHistoryTimeWindow property.
     * Settable only at topic creation time.
     */
    readonly requiresDuplicateDetection: boolean;
    /**
     * Specifies the time span during which the Service Bus will detect message duplication.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    duplicateDetectionHistoryTimeWindow: string;
    /**
     * Specifies if batched operations should be allowed.
     */
    enableBatchedOperations: boolean;
    /**
     * Authorization rules on the topic
     */
    authorizationRules?: AuthorizationRule[];
    /**
     * Status of the messaging entity.
     */
    status: EntityStatus;
    /**
     * The user provided metadata information associated with the topic.
     * Used to specify textual content such as tags, labels, etc.
     * Value must not exceed 1024 bytes encoded in utf-8.
     */
    userMetadata: string;
    /**
     * Specifies whether the topic supports message ordering.
     */
    supportOrdering: boolean;
    /**
     * Max idle time before entity is deleted.
     * This is to be specified in ISO-8601 duration format
     * such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
     *
     * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations
     */
    autoDeleteOnIdle: string;
    /**
     * Specifies whether the topic should be partitioned
     */
    readonly enablePartitioning: boolean;
    /**
     * Specifies whether express entities are enabled on topic.
     */
    readonly enableExpress: boolean;
    /**
     * Availability status of the messaging entity.
     */
    readonly availabilityStatus: EntityAvailabilityStatus;
}

/**
 * Represents runtime info attributes of a topic entity
 */
export declare interface TopicRuntimeProperties {
    /**
     * Name of the topic
     */
    name: string;
    /**
     * Specifies the topic size in bytes.
     */
    sizeInBytes?: number;
    /**
     * The subscription count on given topic.
     *
     */
    subscriptionCount?: number;
    /**
     * The number of scheduled messages.
     */
    scheduledMessageCount: number;
    /**
     * Created at timestamp
     */
    createdAt: Date;
    /**
     * Updated at timestamp
     */
    modifiedAt: Date;
    /**
     * Accessed at timestamp
     */
    accessedAt: Date;
}

/**
 * Fired in response to upload or download progress.
 */
export declare type TransferProgressEvent = {
    /**
     * The number of bytes loaded so far.
     */
    loadedBytes: number;
};

/**
 * The set of options to manually propagate `Span` context for distributed tracing.
 */
export declare interface TryAddOptions {
    /**
     * The options to use when creating Spans for tracing.
     */
    tracingOptions?: OperationTracingOptions;
}

/**
 * A description of a HTTP request to be made to a remote server.
 */
export declare interface WebResourceLike {
    /**
     * The URL being accessed by the request.
     */
    url: string;
    /**
     * The HTTP method to use when making the request.
     */
    method: HttpMethods;
    /**
     * The HTTP body contents of the request.
     */
    body?: any;
    /**
     * The HTTP headers to use when making the request.
     */
    headers: HttpHeadersLike;
    /**
     * Whether or not the body of the HttpOperationResponse should be treated as a stream.
     * @deprecated Use streamResponseStatusCodes property instead.
     */
    streamResponseBody?: boolean;
    /**
     * A list of response status codes whose corresponding HttpOperationResponse body should be treated as a stream.
     */
    streamResponseStatusCodes?: Set<number>;
    /**
     * Form data, used to build the request body.
     */
    formData?: any;
    /**
     * A query string represented as an object.
     */
    query?: {
        [key: string]: any;
    };
    /**
     * If credentials (cookies) should be sent along during an XHR.
     */
    withCredentials: boolean;
    /**
     * The number of milliseconds a request can take before automatically being terminated.
     * If the request is terminated, an `AbortError` is thrown.
     */
    timeout: number;
    /**
     * Proxy configuration.
     */
    proxySettings?: ProxySettings;
    /**
     * If the connection should be reused.
     */
    keepAlive?: boolean;
    /**
     * Whether or not to decompress response according to Accept-Encoding header (node-fetch only)
     */
    decompressResponse?: boolean;
    /**
     * A unique identifier for the request. Used for logging and tracing.
     */
    requestId: string;
    /**
     * Signal of an abort controller. Can be used to abort both sending a network request and waiting for a response.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Callback which fires upon upload progress.
     */
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    /** Callback which fires upon download progress. */
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
}

export { WebSocketImpl }

export { WebSocketOptions }

/**
 * Represents the returned response of the operation along with the raw response.
 */
export declare type WithResponse<T extends object> = T & {
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse;
};

export { }
