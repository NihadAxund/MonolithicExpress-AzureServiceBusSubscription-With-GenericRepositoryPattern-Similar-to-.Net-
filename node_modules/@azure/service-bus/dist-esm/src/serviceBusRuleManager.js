// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { RetryOperationType, retry } from "@azure/core-amqp";
import { ruleManagerLogger as logger } from "./log";
import { isSqlRuleAction, } from "./serializers/ruleResourceSerializer";
import { getUniqueName } from "./util/utils";
import { throwErrorIfConnectionClosed } from "./util/errors";
import { tracingClient } from "./diagnostics/tracing";
import { getPagedAsyncIterator } from "@azure/core-paging";
/**
 * @internal
 */
export class ServiceBusRuleManagerImpl {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     */
    constructor(_context, _entityPath, _retryOptions = {}) {
        this._context = _context;
        this._entityPath = _entityPath;
        this._retryOptions = _retryOptions;
        /**
         * Denotes if close() was called on this sender
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this.entityPath = _entityPath;
        this.name = getUniqueName("ruleManager");
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    async createRule(ruleName, filter, ruleActionOrOperationOptions, options = {}) {
        let sqlRuleAction = undefined;
        let operOptions;
        if (ruleActionOrOperationOptions) {
            if (isSqlRuleAction(ruleActionOrOperationOptions)) {
                // Overload#2 - where the sqlExpression in the ruleAction is defined
                sqlRuleAction = ruleActionOrOperationOptions;
                operOptions = options;
            }
            else {
                // Overload#1 - where the sqlExpression in the ruleAction is undefined
                operOptions = { ...ruleActionOrOperationOptions, ...options };
            }
        }
        return tracingClient.withSpan("ServiceBusRuleManager.createRule", operOptions ?? {}, async (updatedOptions) => {
            const addRuleOperationPromise = async () => {
                return this._context
                    .getManagementClient(this._entityPath)
                    .addRule(ruleName, filter, sqlRuleAction?.sqlExpression, {
                    ...updatedOptions,
                    associatedLinkName: this.name,
                    requestName: "addRule",
                    timeoutInMs: this._retryOptions.timeoutInMs,
                });
            };
            const config = {
                operation: addRuleOperationPromise,
                connectionId: this._context.connectionId,
                operationType: RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: updatedOptions?.abortSignal,
            };
            return retry(config);
        });
    }
    /**
     * Get all rules associated with the subscription.
     */
    async getRules(options) {
        return tracingClient.withSpan("ServiceBusRuleManager.getRules", options ?? {}, async (updatedOptions) => {
            const getRulesOperationPromise = async () => {
                return this._context.getManagementClient(this._entityPath).getRules({
                    ...updatedOptions,
                    associatedLinkName: this.name,
                    requestName: "getRules",
                    timeoutInMs: this._retryOptions.timeoutInMs,
                });
            };
            const config = {
                operation: getRulesOperationPromise,
                connectionId: this._context.connectionId,
                operationType: RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: updatedOptions?.abortSignal,
            };
            return retry(config);
        });
    }
    /**
     * Returns an async iterable iterator to list all the rules
     * under the specified subscription.
     *
     * .byPage() returns an async iterable iterator to list the rules in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listRules(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        logger.verbose(`Performing operation - listRules() with options: %j`, options);
        const pagedResult = {
            firstPageLink: 0,
            getPage: async (pageLink, maxPageSize) => {
                const top = maxPageSize ?? 100;
                const rules = await this.getRules({
                    skip: pageLink,
                    maxCount: top,
                    ...options,
                });
                return rules.length
                    ? {
                        page: rules,
                        nextPageLink: rules.length > 0 ? pageLink + rules.length : undefined,
                    }
                    : undefined;
            },
        };
        return getPagedAsyncIterator(pagedResult);
    }
    /**
     * Deletes a rule.
     */
    async deleteRule(ruleName, options = {}) {
        return tracingClient.withSpan("ServiceBusRuleManager.deleteRule", options, async (updatedOptions) => {
            const removeRuleOperationPromise = async () => {
                return this._context.getManagementClient(this._entityPath).removeRule(ruleName, {
                    ...updatedOptions,
                    associatedLinkName: this.name,
                    requestName: "removeRule",
                    timeoutInMs: this._retryOptions.timeoutInMs,
                });
            };
            const config = {
                operation: removeRuleOperationPromise,
                connectionId: this._context.connectionId,
                operationType: RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: updatedOptions?.abortSignal,
            };
            return retry(config);
        });
    }
}
//# sourceMappingURL=serviceBusRuleManager.js.map