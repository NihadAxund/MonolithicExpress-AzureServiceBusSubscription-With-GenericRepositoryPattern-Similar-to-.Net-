{"version":3,"file":"sessionReceiver.js","sourceRoot":"","sources":["../../../src/receivers/sessionReceiver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionContext } from \"../connectionContext\";\nimport { MessageHandlers, ReceiveMessagesOptions, ServiceBusReceivedMessage } from \"..\";\nimport { PeekMessagesOptions, GetMessageIteratorOptions, SubscribeOptions } from \"../models\";\nimport { MessageSession } from \"../session/messageSession\";\nimport {\n  getAlreadyReceivingErrorMsg,\n  getReceiverClosedErrorMsg,\n  InvalidMaxMessageCountError,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwErrorIfInvalidOperationOnMessage,\n  throwTypeErrorIfParameterTypeMismatch,\n} from \"../util/errors\";\nimport { OnError, OnMessage } from \"../core/messageReceiver\";\nimport {\n  abandonMessage,\n  assertValidMessageHandlers,\n  completeMessage,\n  deadLetterMessage,\n  deferMessage,\n  getMessageIterator,\n  wrapProcessErrorHandler,\n} from \"./receiverCommon\";\nimport { defaultMaxTimeAfterFirstMessageForBatchingMs, ServiceBusReceiver } from \"./receiver\";\nimport Long from \"long\";\nimport { ServiceBusMessageImpl, DeadLetterOptions } from \"../serviceBusMessage\";\nimport {\n  Constants,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  retry,\n  ErrorNameConditionMapper,\n} from \"@azure/core-amqp\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { AmqpError } from \"rhea-promise\";\nimport { toProcessingSpanOptions } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { tracingClient } from \"../diagnostics/tracing\";\nimport { receiverLogger as logger } from \"../log\";\nimport { translateServiceBusError } from \"../serviceBusError\";\n\n/**\n *A receiver that handles sessions, including renewing the session lock.\n */\nexport interface ServiceBusSessionReceiver extends ServiceBusReceiver {\n  /**\n   * The session ID.\n   */\n  readonly sessionId: string;\n\n  /**\n   * The time in UTC until which the session is locked.\n   * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock\n   * duration as specified during the Queue/Subscription creation.\n   *\n   * Will return undefined until a AMQP receiver link has been successfully set up for the session.\n   *\n   * @readonly\n   */\n  readonly sessionLockedUntilUtc: Date;\n\n  /**\n   * Streams messages to message handlers.\n   * @param handlers - A handler that gets called for messages and errors.\n   * @param options - Options for subscribe.\n   * @returns An object that can be closed, sending any remaining messages to `handlers` and\n   * stopping new messages from arriving.\n   */\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions,\n  ): {\n    /**\n     * Causes the subscriber to stop receiving new messages.\n     */\n    close(): Promise<void>;\n  };\n\n  /**\n   * Renews the lock on the session.\n   */\n  renewSessionLock(options?: OperationOptionsBase): Promise<Date>;\n\n  /**\n   * Gets the state of the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns The state of that session\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while retrieving session state.\n   */\n  getSessionState(options?: OperationOptionsBase): Promise<any>;\n\n  /**\n   * Sets the state on the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param state - The state that needs to be set.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while setting the session state.\n   *\n   */\n  setSessionState(state: any, options?: OperationOptionsBase): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport class ServiceBusSessionReceiverImpl implements ServiceBusSessionReceiver {\n  public sessionId: string;\n  public identifier: string;\n\n  /**\n   * Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n\n  private get logPrefix(): string {\n    return `[${this._context.connectionId}|session:${this.entityPath}]`;\n  }\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   * @throws Error if an open receiver is already existing for given sessionId.\n   */\n  constructor(\n    private _messageSession: MessageSession,\n    private _context: ConnectionContext,\n    public entityPath: string,\n    public receiveMode: \"peekLock\" | \"receiveAndDelete\",\n    private _skipParsingBodyAsJson: boolean,\n    private _skipConvertingDate: boolean,\n    private _retryOptions: RetryOptions = {},\n  ) {\n    throwErrorIfConnectionClosed(_context);\n    this.sessionId = _messageSession.sessionId;\n    this.identifier = _messageSession.identifier;\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (this.isClosed) {\n      if (this._isClosed) {\n        const errorMessage = getReceiverClosedErrorMsg(this.entityPath, this.sessionId);\n        const error = new Error(errorMessage);\n        logger.logError(error, `${this.logPrefix} already closed`);\n        throw error;\n      }\n      const amqpError: AmqpError = {\n        condition: ErrorNameConditionMapper.SessionLockLostError,\n        description: `The session lock has expired on the session with id ${this.sessionId}`,\n      };\n      throw translateServiceBusError(amqpError);\n    }\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this._isReceivingMessages()) {\n      const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath, this.sessionId);\n      const error = new Error(errorMessage);\n      logger.logError(error, `${this.logPrefix} is already receiving.`);\n      throw error;\n    }\n  }\n\n  public get isClosed(): boolean {\n    return (\n      this._isClosed ||\n      !this._context.messageSessions[this._messageSession.name] ||\n      !this._messageSession.isOpen()\n    );\n  }\n\n  /**\n   * The time in UTC until which the session is locked.\n   * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock\n   * duration as specified during the Queue/Subscription creation.\n   *\n   * When the lock on the session expires\n   * - The current receiver can no longer be used to receive more messages.\n   * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.\n   * - Messages that were received in `peekLock` mode with this receiver but not yet settled\n   * will land back in the Queue/Subscription with their delivery count incremented.\n   *\n   * @readonly\n   */\n  public get sessionLockedUntilUtc(): Date {\n    return this._messageSession.sessionLockedUntilUtc;\n  }\n\n  /**\n   * Renews the lock on the session for the duration as specified during the Queue/Subscription\n   * creation. You can check the `sessionLockedUntilUtc` property for the time when the lock expires.\n   *\n   * When the lock on the session expires\n   * - The current receiver can no longer be used to receive mode messages.\n   * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.\n   * - Messages that were received in `peekLock` mode with this receiver but not yet settled\n   * will land back in the Queue/Subscription with their delivery count incremented.\n   *\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns New lock token expiry date and time in UTC format.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while renewing session lock.\n   */\n  async renewSessionLock(options?: OperationOptionsBase): Promise<Date> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    return tracingClient.withSpan(\n      \"ServiceBusSessionReceiver.renewSessionLock\",\n      options ?? {},\n      (updatedOptions) => {\n        const renewSessionLockOperationPromise = async (): Promise<Date> => {\n          this._messageSession!.sessionLockedUntilUtc = await this._context\n            .getManagementClient(this.entityPath)\n            .renewSessionLock(this.sessionId, {\n              ...updatedOptions,\n              associatedLinkName: this._messageSession.name,\n              requestName: \"renewSessionLock\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n          return this._messageSession!.sessionLockedUntilUtc!;\n        };\n        const config: RetryConfig<Date> = {\n          operation: renewSessionLockOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: options?.abortSignal,\n        };\n        return retry<Date>(config);\n      },\n    );\n  }\n\n  /**\n   * Sets the state on the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param state - The state that needs to be set.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while setting the session state.\n   */\n  async setSessionState(state: unknown, options: OperationOptionsBase = {}): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    return tracingClient.withSpan(\n      \"ServiceBusSessionReceiver.setSessionState\",\n      options ?? {},\n      (updatedOptions) => {\n        const setSessionStateOperationPromise = async (): Promise<void> => {\n          await this._context\n            .getManagementClient(this.entityPath)\n            .setSessionState(this.sessionId!, state, {\n              ...updatedOptions,\n              associatedLinkName: this._messageSession.name,\n              requestName: \"setState\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n          return;\n        };\n        const config: RetryConfig<void> = {\n          operation: setSessionStateOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: options?.abortSignal,\n        };\n        return retry<void>(config);\n      },\n    );\n  }\n\n  /**\n   * Gets the state of the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns The state of that session\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while retrieving session state.\n   */\n  async getSessionState(options: OperationOptionsBase = {}): Promise<any> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    return tracingClient.withSpan(\n      \"ServiceBusSessionReceiver.getSessionState\",\n      options ?? {},\n      (updatedOptions) => {\n        const getSessionStateOperationPromise = async (): Promise<any> => {\n          return this._context\n            .getManagementClient(this.entityPath)\n            .getSessionState(this.sessionId, {\n              ...updatedOptions,\n              associatedLinkName: this._messageSession.name,\n              requestName: \"getState\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n        };\n        const config: RetryConfig<any> = {\n          operation: getSessionStateOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: options?.abortSignal,\n        };\n        return retry<any>(config);\n      },\n    );\n  }\n\n  async peekMessages(\n    maxMessageCount: number,\n    options: PeekMessagesOptions = {},\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    const managementRequestOptions = {\n      ...options,\n      associatedLinkName: this._messageSession.name,\n      requestName: \"peekMessages\",\n      timeoutInMs: this._retryOptions?.timeoutInMs,\n      skipParsingBodyAsJson: this._skipParsingBodyAsJson,\n      skipConvertingDate: this._skipConvertingDate,\n    };\n    const peekOperationPromise = async (): Promise<ServiceBusReceivedMessage[]> => {\n      if (options.fromSequenceNumber !== undefined) {\n        return this._context\n          .getManagementClient(this.entityPath)\n          .peekBySequenceNumber(\n            options.fromSequenceNumber,\n            maxMessageCount,\n            this.sessionId,\n            options.omitMessageBody,\n            managementRequestOptions,\n          );\n      } else {\n        return this._context\n          .getManagementClient(this.entityPath)\n          .peekMessagesBySession(\n            this.sessionId,\n            maxMessageCount,\n            options.omitMessageBody,\n            managementRequestOptions,\n          );\n      }\n    };\n\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: peekOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  async receiveDeferredMessages(\n    sequenceNumbers: Long | Long[],\n    options: OperationOptionsBase = {},\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers,\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers,\n    );\n\n    const deferredSequenceNumbers = Array.isArray(sequenceNumbers)\n      ? sequenceNumbers\n      : [sequenceNumbers];\n    const receiveDeferredMessagesOperationPromise = async (): Promise<\n      ServiceBusReceivedMessage[]\n    > => {\n      const deferredMessages = await this._context\n        .getManagementClient(this.entityPath)\n        .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, this.sessionId, {\n          ...options,\n          associatedLinkName: this._messageSession.name,\n          requestName: \"receiveDeferredMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs,\n          skipParsingBodyAsJson: this._skipParsingBodyAsJson,\n          skipConvertingDate: this._skipConvertingDate,\n        });\n      return deferredMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: receiveDeferredMessagesOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  async receiveMessages(\n    maxMessageCount: number,\n    options?: ReceiveMessagesOptions,\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n    );\n    throwTypeErrorIfParameterTypeMismatch(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n      \"number\",\n    );\n\n    if (isNaN(maxMessageCount) || maxMessageCount < 1) {\n      throw new TypeError(InvalidMaxMessageCountError);\n    }\n\n    const receiveBatchOperationPromise = async (): Promise<ServiceBusReceivedMessage[]> => {\n      const receivedMessages = await this._messageSession!.receiveMessages(\n        maxMessageCount,\n        options?.maxWaitTimeInMs ?? Constants.defaultOperationTimeoutInMs,\n        defaultMaxTimeAfterFirstMessageForBatchingMs,\n        options ?? {},\n      );\n\n      return receivedMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: receiveBatchOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.receiveMessage,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config).catch((err) => {\n      throw translateServiceBusError(err);\n    });\n  }\n\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions,\n  ): {\n    close(): Promise<void>;\n  } {\n    // TODO - receiverOptions for subscribe??\n    assertValidMessageHandlers(handlers);\n\n    options = options ?? {};\n\n    const processError = wrapProcessErrorHandler(handlers);\n\n    this._registerMessageHandler(\n      async (message: ServiceBusMessageImpl) => {\n        return tracingClient.withSpan(\n          \"SessionReceiver.process\",\n          options ?? {},\n          () => handlers.processMessage(message),\n          toProcessingSpanOptions(message, this, this._context.config, \"process\"),\n        );\n      },\n      processError,\n      options,\n    );\n\n    return {\n      close: async (): Promise<void> => {\n        return this._messageSession?.receiverHelper.suspend();\n      },\n    };\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the SessionReceiver.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control whether messages should be automatically completed\n   * or if the lock on the session should be automatically renewed. You can control the\n   * maximum number of messages that should be concurrently processed. You can\n   * also provide a timeout in milliseconds to denote the amount of time to wait for a new message\n   * before closing the receiver.\n   *\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws Error if the receiver is already in state of receiving messages.\n   * @throws `ServiceBusError` if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.\n   */\n  private _registerMessageHandler(\n    onMessage: OnMessage,\n    onError: OnError,\n    options: SubscribeOptions,\n  ): void {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    const connId = this._context.connectionId;\n    throwTypeErrorIfParameterMissing(connId, \"onMessage\", onMessage);\n    throwTypeErrorIfParameterMissing(connId, \"onError\", onError);\n    if (typeof onMessage !== \"function\") {\n      throw new TypeError(\"The parameter 'onMessage' must be of type 'function'.\");\n    }\n    if (typeof onError !== \"function\") {\n      throw new TypeError(\"The parameter 'onError' must be of type 'function'.\");\n    }\n\n    try {\n      this._messageSession.subscribe(onMessage, onError, options);\n    } catch (err: any) {\n      onError({\n        error: err,\n        errorSource: \"receive\",\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host,\n        identifier: this.identifier,\n      });\n    }\n  }\n\n  getMessageIterator(\n    options?: GetMessageIteratorOptions,\n  ): AsyncIterableIterator<ServiceBusReceivedMessage> {\n    return getMessageIterator(this, options);\n  }\n\n  async completeMessage(message: ServiceBusReceivedMessage): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return completeMessage(msgImpl, this._context, this.entityPath, this._retryOptions);\n  }\n\n  async abandonMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return abandonMessage(\n      msgImpl,\n      this._context,\n      this.entityPath,\n      propertiesToModify,\n      this._retryOptions,\n    );\n  }\n\n  async deferMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deferMessage(\n      msgImpl,\n      this._context,\n      this.entityPath,\n      propertiesToModify,\n      this._retryOptions,\n    );\n  }\n\n  async deadLetterMessage(\n    message: ServiceBusReceivedMessage,\n    options?: DeadLetterOptions & { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deadLetterMessage(msgImpl, this._context, this.entityPath, options, this._retryOptions);\n  }\n\n  async renewMessageLock(): Promise<Date> {\n    throw new Error(\"Renewing message lock is an invalid operation when working with sessions.\");\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this._messageSession.close();\n    } catch (err: any) {\n      logger.logError(\n        err,\n        \"%s An error occurred while closing the SessionReceiver for session %s\",\n        this.logPrefix,\n        this.sessionId,\n      );\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  /**\n   * Indicates whether the receiver is currently receiving messages or not.\n   * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.\n   */\n  private _isReceivingMessages(): boolean {\n    return this._messageSession ? this._messageSession.isReceivingMessages : false;\n  }\n}\n"]}