// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { ConnectionConfig, createSasTokenProvider, } from "@azure/core-amqp";
import { isNamedKeyCredential, isSASCredential, } from "@azure/core-auth";
import { ConnectionContext } from "./connectionContext";
import { parseServiceBusConnectionString, } from "./util/connectionStringUtils";
// TODO: extract parseEndpoint and setCustomEndpointAddress into core-amqp
// ConnectionConfig so that it can be shared between Event Hubs and Service Bus
/**
 * Parses the host, hostname, and port from an endpoint.
 * @param endpoint - And endpoint to parse.
 * @internal
 */
export function parseEndpoint(endpoint) {
    const hostMatch = endpoint.match(/.*:\/\/([^/]*)/);
    if (!hostMatch) {
        throw new TypeError(`Invalid endpoint missing host: ${endpoint}`);
    }
    const [, host] = hostMatch;
    const [hostname, port] = host.split(":");
    return { host, hostname, port };
}
/**
 * Updates the provided ConnectionConfig to use the custom endpoint address.
 * @param config - An existing connection configuration to be updated.
 * @param customEndpointAddress - The custom endpoint address to use.
 */
function setCustomEndpointAddress(config, customEndpointAddress) {
    // The amqpHostname should match the host prior to using the custom endpoint.
    config.amqpHostname = config.host;
    const { hostname, port } = parseEndpoint(customEndpointAddress);
    // Since we specify the port separately, set host to the customEndpointAddress hostname.
    config.host = hostname;
    if (port) {
        config.port = parseInt(port, 10);
    }
}
/**
 * @internal
 *
 */
export function createConnectionContext(connectionString, credential, options) {
    const config = ConnectionConfig.create(connectionString);
    config.webSocket = options?.webSocketOptions?.webSocket;
    config.webSocketEndpointPath = "$servicebus/websocket";
    config.webSocketConstructorOptions = options?.webSocketOptions?.webSocketConstructorOptions;
    if (options?.customEndpointAddress) {
        setCustomEndpointAddress(config, options.customEndpointAddress);
    }
    return ConnectionContext.create(config, credential, options);
}
/**
 * @internal
 */
export function createConnectionContextForConnectionString(connectionString, options = {}) {
    const parsed = parseServiceBusConnectionString(connectionString);
    const sasTokenProvider = createSasTokenProvider(parsed);
    return createConnectionContext(connectionString, sasTokenProvider, options);
}
/**
 *
 * @internal
 */
export function createConnectionContextForCredential(credential, host, options = {}) {
    if (typeof host !== "string") {
        throw new TypeError("`host` parameter is not a string");
    }
    let tokenProvider;
    // host, credential and options based constructor was invoked
    if (!host.endsWith("/")) {
        host += "/";
    }
    if (isNamedKeyCredential(credential) || isSASCredential(credential)) {
        tokenProvider = createSasTokenProvider(credential);
    }
    else {
        tokenProvider = credential;
    }
    const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;
    return createConnectionContext(connectionString, tokenProvider, options);
}
/**
 * Parses a connection string and extracts the EntityPath named entity out.
 * @param connectionString - An entity specific Service Bus connection string.
 * @internal
 */
export function getEntityNameFromConnectionString(connectionString) {
    const entityPathMatch = connectionString.match(/^.+EntityPath=(.+?);{0,1}$/);
    if (entityPathMatch != null && entityPathMatch.length === 2) {
        return entityPathMatch[1];
    }
    else {
        throw new Error("No entity name present in the connection string");
    }
}
//# sourceMappingURL=constructorHelpers.js.map