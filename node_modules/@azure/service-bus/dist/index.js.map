{"version":3,"file":"index.js","sources":["../src/log.ts","../src/util/constants.ts","../src/util/parseUrl.ts","../src/util/compat/httpHeaders.ts","../src/util/compat/compatibility.ts","../src/serviceBusError.ts","../src/util/utils.ts","../src/util/atomXmlHelper.ts","../src/serializers/namespaceResourceSerializer.ts","../src/serializers/queueResourceSerializer.ts","../src/serializers/ruleResourceSerializer.ts","../src/serializers/subscriptionResourceSerializer.ts","../src/serializers/topicResourceSerializer.ts","../src/util/crypto.ts","../src/util/sasServiceClientCredentials.ts","../src/diagnostics/tracing.ts","../src/serviceBusAtomManagementClient.ts","../src/dataTransformer.ts","../src/serviceBusMessage.ts","../src/core/linkEntity.ts","../src/util/errors.ts","../src/core/managementClient.ts","../src/util/runtimeInfo.ts","../src/connectionContext.ts","../src/util/connectionStringUtils.ts","../src/constructorHelpers.ts","../src/core/shared.ts","../src/core/messageReceiver.ts","../src/core/receiverHelper.ts","../src/diagnostics/instrumentServiceBusMessage.ts","../src/receivers/receiverCommon.ts","../src/core/streamingReceiver.ts","../src/core/batchingReceiver.ts","../src/core/autoLockRenewer.ts","../src/receivers/receiver.ts","../src/receivers/sessionReceiver.ts","../src/serviceBusRuleManager.ts","../src/serviceBusMessageBatch.ts","../src/core/messageSender.ts","../src/sender.ts","../src/session/messageSession.ts","../src/util/typeGuards.ts","../src/serviceBusClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AzureLogger, createClientLogger } from \"@azure/logger\";\nimport { AmqpError } from \"rhea-promise\";\nimport { isObjectWithProperties } from \"@azure/core-util\";\n\n/**\n * The `@azure/logger` configuration for this package.\n * This will output logs using the `azure:service-bus` namespace prefix.\n * @internal\n */\nexport const logger = createServiceBusLogger(\"service-bus\");\n\n/**\n * Logging for ServiceBusReceivers of any type (session, non-session)\n * @internal\n */\nexport const receiverLogger = createServiceBusLogger(\"service-bus:receiver\");\n\n/**\n * Logging for ServiceBusSenders\n * @internal\n */\nexport const senderLogger = createServiceBusLogger(\"service-bus:sender\");\n\n/**\n * Logging for ServiceBusRuleManagers\n * @internal\n */\nexport const ruleManagerLogger = createServiceBusLogger(\"service-bus:rulemanager\");\n\n/**\n * Logging for connection management\n * @internal\n */\nexport const connectionLogger = createServiceBusLogger(\"service-bus:connection\");\n\n/**\n * Logging for the ServiceBusAdministrationClient\n * @internal\n */\nexport const administrationLogger = createServiceBusLogger(\"service-bus:administration\");\n\n/**\n * Logging related to message encoding/decoding.\n * @internal\n */\nexport const messageLogger = createServiceBusLogger(\"service-bus:messages\");\n\n/**\n * Logging related to message encoding/decoding.\n * @internal\n */\nexport const managementClientLogger = createServiceBusLogger(\"service-bus:management\");\n\n/**\n * Logs the error's stack trace to \"verbose\" if a stack trace is available.\n * @param error - Error containing a stack trace.\n * @internal\n */\nexport function logErrorStackTrace(_logger: AzureLogger, error: unknown): void {\n  if (isObjectWithProperties(error, [\"stack\"]) && error.stack) {\n    _logger.verbose(error.stack);\n  }\n}\n\n/**\n * @internal\n */\nexport interface ServiceBusLogger extends AzureLogger {\n  /**\n   * Logs an error with an associated message, formatted. If there is a stack\n   * trace in the error that will be logged to the verbose stream.\n   *\n   * Example:\n   *   receiverLogger.logError(new Error(\"hello, this is the error\"), \"this is my message\");\n   * will output:\n   *   azure:service-bus:receiver:warning this is my message : Error: hello, this is the error\n   */\n  logError(err: Error | AmqpError | undefined, ...args: any[]): void;\n}\n\n/**\n * Creates an AzureLogger with any additional methods for standardized logging (for example, with errors)\n * @internal\n */\nexport function createServiceBusLogger(namespace: string): ServiceBusLogger {\n  const _logger = createClientLogger(namespace) as ServiceBusLogger;\n\n  _logger[\"logError\"] = (err: Error | AmqpError | undefined, ...args: any[]): void => {\n    let l: typeof logger.info;\n\n    // abort errors are user initiated so we don't have to treat them as warnings, like we\n    // would with other errors.\n    if (isError(err) && err.name === \"AbortError\") {\n      l = _logger.info;\n    } else {\n      l = _logger.warning;\n    }\n\n    // tack on the error object so it also gets logged.\n    args.push(\":\", err);\n\n    // let the normal formatting work and include the error at the end.\n    l(...args);\n\n    // optionally log the stack trace if it's available but this always goes to verbose\n    if (err && (err as any).stack) {\n      _logger.verbose((err as any).stack);\n    }\n  };\n\n  return _logger;\n}\n\n/**\n * @internal\n */\nfunction isError(err: Error | AmqpError | undefined): err is Error {\n  return err != null && (err as any).name != null;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * @internal\n */\nexport const packageJsonInfo = {\n  name: \"@azure/service-bus\",\n  version: \"7.9.5\",\n};\n\n/**\n * @internal\n */\nexport const messageDispositionTimeout = 20000;\n\n/**\n * The amount of time in milliseconds that a receiver\n * will wait while draining credits before returning.\n * @internal\n */\nexport const receiveDrainTimeoutInMs = 200;\n\n/**\n * @internal\n */\nexport const max32BitNumber = Math.pow(2, 31) - 1;\n\n/**\n * Queue name identifier\n * @internal\n */\nexport const QUEUE_NAME = \"QueueName\";\n\n/**\n * Topic name identifier\n * @internal\n */\nexport const TOPIC_NAME = \"TopicName\";\n\n/**\n * Subscription name identifier\n * @internal\n */\nexport const SUBSCRIPTION_NAME = \"SubscriptionName\";\n\n/**\n * Rule name identifier\n * @internal\n */\nexport const RULE_NAME = \"RuleName\";\n\n/**\n * Accessed at field\n * @internal\n */\nexport const ACCESSED_AT = \"AccessedAt\";\n\n/**\n * Updated at field\n * @internal\n */\nexport const UPDATED_AT = \"UpdatedAt\";\n\n/**\n * Created at field\n * @internal\n */\nexport const CREATED_AT = \"CreatedAt\";\n\n/**\n * Authorization rules on the entity\n * @internal\n */\nexport const AUTHORIZATION_RULES = \"AuthorizationRules\";\n\n/**\n * Is Anonymous Accessible field\n * @internal\n */\nexport const IS_ANONYMOUS_ACCESSIBLE = \"IsAnonymousAccessible\";\n\n/**\n * Entity Availability Status field\n * @internal\n */\nexport const ENTITY_AVAILABILITY_STATUS = \"EntityAvailabilityStatus\";\n\n/**\n * Enable express option\n * @internal\n */\nexport const ENABLE_EXPRESS = \"EnableExpress\";\n\n/**\n * Is express option\n * @internal\n */\nexport const IS_EXPRESS = \"IsExpress\";\n\n/**\n * Enable Subscription Partitioning option\n * @internal\n */\nexport const ENABLE_SUBSCRIPTION_PARTITIONING = \"EnableSubscriptionPartitioning\";\n\n/**\n * Filtering Messages Before Publishing option\n * @internal\n */\nexport const FILTER_MESSAGES_BEFORE_PUBLISHING = \"FilteringMessagesBeforePublishing\";\n\n/**\n * The entity's size in bytes.\n *\n * @internal\n */\nexport const SIZE_IN_BYTES = \"SizeInBytes\";\n\n/**\n * The entity's message count.\n *\n * @internal\n */\nexport const MESSAGE_COUNT = \"MessageCount\";\n\n/**\n * The topic's subscription count.\n *\n * @internal\n */\nexport const SUBSCRIPTION_COUNT = \"SubscriptionCount\";\n\n/**\n * The topic / subscription's count details.\n *\n * @internal\n */\nexport const COUNT_DETAILS = \"CountDetails\";\n\n/**\n * The default rule name.\n *\n * @internal\n */\nexport const DEFAULT_RULE_NAME = \"$Default\";\n\n/**\n * Max idle time before entity is deleted.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n * @internal\n */\nexport const AUTO_DELETE_ON_IDLE = \"AutoDeleteOnIdle\";\n\n/**\n * The status information on response\n *\n * @internal\n */\nexport const STATUS = \"Status\";\n\n/**\n * The URL of Service Bus entity to forward messages to.\n *\n * @internal\n */\nexport const FORWARD_TO = \"ForwardTo\";\n\n/**\n * The user meta data information\n *\n * @internal\n */\nexport const USER_METADATA = \"UserMetadata\";\n\n/**\n * The maximum size in megabytes.\n *\n * @internal\n */\nexport const MAX_SIZE_IN_MEGABYTES = \"MaxSizeInMegabytes\";\n/**\n * The maximum size in kilobytes.\n *\n * @internal\n */\nexport const MAX_MESSAGE_SIZE_IN_KILOBYTES = \"MaxMessageSizeInKilobytes\";\n/**\n * The default message time to live.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n * @internal\n */\nexport const DEFAULT_MESSAGE_TIME_TO_LIVE = \"DefaultMessageTimeToLive\";\n\n/**\n * The lock duration.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n * @internal\n */\nexport const LOCK_DURATION = \"LockDuration\";\n\n/**\n * The indication if session is required or not.\n *\n * @internal\n */\nexport const REQUIRES_SESSION = \"RequiresSession\";\n\n/**\n * The indication if duplicate detection is required or not.\n *\n * @internal\n */\nexport const REQUIRES_DUPLICATE_DETECTION = \"RequiresDuplicateDetection\";\n\n/**\n * The indication if dead lettering on message expiration. If it is enabled and a message expires,\n * the Service Bus moves the message from the queue into the entity dead-letter sub-queue.\n * If disabled, message will be permanently deleted from the main entity.\n * Settable only at entity creation time.\n *\n * @internal\n */\nexport const DEAD_LETTERING_ON_MESSAGE_EXPIRATION = \"DeadLetteringOnMessageExpiration\";\n\n/**\n * The indication if dead lettering on filter evaluation exceptions.\n *\n * @internal\n */\nexport const DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS =\n  \"DeadLetteringOnFilterEvaluationExceptions\";\n\n/**\n * The history time window for duplicate detection.\n * This is specified in ISO-8601 duration format such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n * @internal\n */\nexport const DUPLICATE_DETECTION_HISTORY_TIME_WINDOW = \"DuplicateDetectionHistoryTimeWindow\";\n\n/**\n * The maximum delivery count of messages after which if it is still not settled, gets moved to the dead-letter sub-queue.\n *\n * @internal\n */\nexport const MAX_DELIVERY_COUNT = \"MaxDeliveryCount\";\n\n/**\n * Indicates if the queue has enabled batch operations.\n *\n * @internal\n */\nexport const ENABLE_BATCHED_OPERATIONS = \"EnableBatchedOperations\";\n\n/**\n * Indicates whether the topic can be ordered\n *\n * @internal\n */\nexport const SUPPORT_ORDERING = \"SupportOrdering\";\n\n/**\n * Indicates whether the topic/queue should be split across multiple partitions\n *\n * @internal\n */\nexport const ENABLE_PARTITIONING = \"EnablePartitioning\";\n\n/**\n * The URL of Service Bus entity to forward deadlettered messages to.\n *\n * @internal\n */\nexport const FORWARD_DEADLETTERED_MESSAGES_TO = \"ForwardDeadLetteredMessagesTo\";\n\n/**\n * Query string parameter to set Service Bus API version\n *\n * @internal\n */\nexport const API_VERSION_QUERY_KEY = \"api-version\";\n\n/**\n * Current API version being sent to service bus\n *\n * @internal\n */\nexport const CURRENT_API_VERSION = \"2021-05\";\n\n/**\n * Constant representing the Odata Error 'message' property\n *\n * @internal\n */\nexport const ODATA_ERROR_MESSAGE = \"message\";\n/**\n * Constant representing the 'value' property of Odata Error 'message' property\n *\n * @internal\n */\nexport const ODATA_ERROR_MESSAGE_VALUE = \"value\";\n\n/**\n * Marker for atom metadata.\n *\n * @internal\n */\nexport const XML_METADATA_MARKER = \"$\";\n\n/**\n * Marker for atom value.\n *\n * @internal\n */\nexport const XML_VALUE_MARKER = \"_\";\n\n/**\n * Constant representing the property where the atom default elements are stored.\n *\n * @internal\n */\nexport const ATOM_METADATA_MARKER = \"_\";\n\n/**\n * Known HTTP status codes as documented and referenced in ATOM based management API feature\n * https://docs.microsoft.com/dotnet/api/system.net.httpstatuscode?view=netframework-4.8\n * @internal\n */\nexport const HttpResponseCodes = {\n  100: \"Continue\",\n  101: \"SwitchingProtocols\",\n  200: \"Ok\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"NonAuthoritativeInformation\",\n  204: \"NoContent\",\n  205: \"ResetContent\",\n  206: \"PartialContent\",\n  300: \"MultipleChoices\",\n  301: \"Moved\",\n  302: \"Redirect\",\n  303: \"RedirectMethod\",\n  304: \"NotModified\",\n  305: \"UseProxy\",\n  306: \"Unused\",\n  400: \"BadRequest\",\n  401: \"Unauthorized\",\n  402: \"PaymentRequired\",\n  403: \"Forbidden\",\n  404: \"NotFound\",\n  405: \"MethodNotAllowed\",\n  406: \"NotAcceptable\",\n  407: \"ProxyAuthenticationRequired\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"LengthRequired\",\n  412: \"PreconditionFailed\",\n  413: \"RequestEntityTooLarge\",\n  414: \"RequestUriTooLong\",\n  415: \"UnsupportedMediaType\",\n  416: \"RequestRangeNotSatisfiable\",\n  417: \"ExpectationFailed\",\n  426: \"UpgradeRequired\",\n  500: \"InternalServerError\",\n  501: \"NotImplemented\",\n  502: \"BadGateway\",\n  503: \"ServiceUnavailable\",\n  504: \"GatewayTimeout\",\n  505: \"HttpVersionNotSupported\",\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * @internal\n */\nimport { URL } from \"url\";\n\n/**\n * @internal\n */\nexport const parseURL = (rawUrl: string): URL => {\n  return new URL(rawUrl);\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * A collection of HttpHeaders that can be sent with a HTTP request.\n */\nfunction getHeaderKey(headerName: string): string {\n  return headerName.toLowerCase();\n}\n\n/**\n * An individual header within a HttpHeaders collection.\n */\nexport interface HttpHeader {\n  /**\n   * The name of the header.\n   */\n  name: string;\n\n  /**\n   * The value of the header.\n   */\n  value: string;\n}\n\n/**\n * A HttpHeaders collection represented as a simple JSON object.\n */\nexport type RawHttpHeaders = { [headerName: string]: string };\n\n/**\n * A collection of HTTP header key/value pairs.\n */\nexport interface HttpHeadersLike {\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param headerName - The name of the header to set. This value is case-insensitive.\n   * @param headerValue - The value of the header to set.\n   */\n  set(headerName: string, headerValue: string | number): void;\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param headerName - The name of the header.\n   */\n  get(headerName: string): string | undefined;\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   */\n  contains(headerName: string): boolean;\n  /**\n   * Remove the header with the provided headerName. Return whether or not the header existed and\n   * was removed.\n   * @param headerName - The name of the header to remove.\n   */\n  remove(headerName: string): boolean;\n  /**\n   * Get the headers that are contained this collection as an object.\n   */\n  rawHeaders(): RawHttpHeaders;\n  /**\n   * Get the headers that are contained in this collection as an array.\n   */\n  headersArray(): HttpHeader[];\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  headerNames(): string[];\n  /**\n   * Get the header values that are contained in this collection.\n   */\n  headerValues(): string[];\n  /**\n   * Create a deep clone/copy of this HttpHeaders collection.\n   */\n  clone(): HttpHeadersLike;\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   * The result is the same as `rawHeaders()`.\n   */\n  toJson(options?: { preserveCase?: boolean }): RawHttpHeaders;\n}\n\nexport function isHttpHeadersLike(object?: unknown): object is HttpHeadersLike {\n  if (object && typeof object === \"object\") {\n    const castObject = object as {\n      rawHeaders: unknown;\n      clone: unknown;\n      get: unknown;\n      set: unknown;\n      contains: unknown;\n      remove: unknown;\n      headersArray: unknown;\n      headerValues: unknown;\n      headerNames: unknown;\n      toJson: unknown;\n    };\n    if (\n      typeof castObject.rawHeaders === \"function\" &&\n      typeof castObject.clone === \"function\" &&\n      typeof castObject.get === \"function\" &&\n      typeof castObject.set === \"function\" &&\n      typeof castObject.contains === \"function\" &&\n      typeof castObject.remove === \"function\" &&\n      typeof castObject.headersArray === \"function\" &&\n      typeof castObject.headerValues === \"function\" &&\n      typeof castObject.headerNames === \"function\" &&\n      typeof castObject.toJson === \"function\"\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * A collection of HTTP header key/value pairs.\n */\nexport class HttpHeaders implements HttpHeadersLike {\n  private readonly _headersMap: { [headerKey: string]: HttpHeader };\n\n  constructor(rawHeaders?: RawHttpHeaders) {\n    this._headersMap = {};\n    if (rawHeaders) {\n      for (const headerName in rawHeaders) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param headerName - The name of the header to set. This value is case-insensitive.\n   * @param headerValue - The value of the header to set.\n   */\n  public set(headerName: string, headerValue: string | number): void {\n    this._headersMap[getHeaderKey(headerName)] = {\n      name: headerName,\n      value: headerValue.toString(),\n    };\n  }\n\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param headerName - The name of the header.\n   */\n  public get(headerName: string): string | undefined {\n    const header: HttpHeader = this._headersMap[getHeaderKey(headerName)];\n    return !header ? undefined : header.value;\n  }\n\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   */\n  public contains(headerName: string): boolean {\n    return !!this._headersMap[getHeaderKey(headerName)];\n  }\n\n  /**\n   * Remove the header with the provided headerName. Return whether or not the header existed and\n   * was removed.\n   * @param headerName - The name of the header to remove.\n   */\n  public remove(headerName: string): boolean {\n    const result: boolean = this.contains(headerName);\n    delete this._headersMap[getHeaderKey(headerName)];\n    return result;\n  }\n\n  /**\n   * Get the headers that are contained this collection as an object.\n   */\n  public rawHeaders(): RawHttpHeaders {\n    return this.toJson({ preserveCase: true });\n  }\n\n  /**\n   * Get the headers that are contained in this collection as an array.\n   */\n  public headersArray(): HttpHeader[] {\n    const headers: HttpHeader[] = [];\n    for (const headerKey in this._headersMap) {\n      headers.push(this._headersMap[headerKey]);\n    }\n    return headers;\n  }\n\n  /**\n   * Get the header names that are contained in this collection.\n   */\n  public headerNames(): string[] {\n    const headerNames: string[] = [];\n    const headers: HttpHeader[] = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerNames.push(headers[i].name);\n    }\n    return headerNames;\n  }\n\n  /**\n   * Get the header values that are contained in this collection.\n   */\n  public headerValues(): string[] {\n    const headerValues: string[] = [];\n    const headers: HttpHeader[] = this.headersArray();\n    for (let i = 0; i < headers.length; ++i) {\n      headerValues.push(headers[i].value);\n    }\n    return headerValues;\n  }\n\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  public toJson(options: { preserveCase?: boolean } = {}): RawHttpHeaders {\n    const result: RawHttpHeaders = {};\n    if (options.preserveCase) {\n      for (const headerKey in this._headersMap) {\n        const header: HttpHeader = this._headersMap[headerKey];\n        result[header.name] = header.value;\n      }\n    } else {\n      for (const headerKey in this._headersMap) {\n        const header: HttpHeader = this._headersMap[headerKey];\n        result[getHeaderKey(header.name)] = header.value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  public toString(): string {\n    return JSON.stringify(this.toJson({ preserveCase: true }));\n  }\n\n  /**\n   * Create a deep clone/copy of this HttpHeaders collection.\n   */\n  public clone(): HttpHeaders {\n    const resultPreservingCasing: RawHttpHeaders = {};\n    for (const headerKey in this._headersMap) {\n      const header: HttpHeader = this._headersMap[headerKey];\n      resultPreservingCasing[header.name] = header.value;\n    }\n    return new HttpHeaders(resultPreservingCasing);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  HttpHeaders,\n  HttpMethods,\n  PipelineRequest,\n  PipelineResponse,\n  ProxySettings,\n} from \"@azure/core-rest-pipeline\";\nimport { HttpHeadersLike, HttpHeaders as HttpHeadersV1 } from \"./httpHeaders\";\n\n/**\n * Fired in response to upload or download progress.\n */\nexport type TransferProgressEvent = {\n  /**\n   * The number of bytes loaded so far.\n   */\n  loadedBytes: number;\n};\n\n/**\n * A description of a HTTP request to be made to a remote server.\n */\nexport interface WebResourceLike {\n  /**\n   * The URL being accessed by the request.\n   */\n  url: string;\n  /**\n   * The HTTP method to use when making the request.\n   */\n  method: HttpMethods;\n  /**\n   * The HTTP body contents of the request.\n   */\n  body?: any;\n  /**\n   * The HTTP headers to use when making the request.\n   */\n  headers: HttpHeadersLike;\n  /**\n   * Whether or not the body of the HttpOperationResponse should be treated as a stream.\n   * @deprecated Use streamResponseStatusCodes property instead.\n   */\n  streamResponseBody?: boolean;\n  /**\n   * A list of response status codes whose corresponding HttpOperationResponse body should be treated as a stream.\n   */\n  streamResponseStatusCodes?: Set<number>;\n  /**\n   * Form data, used to build the request body.\n   */\n  formData?: any;\n  /**\n   * A query string represented as an object.\n   */\n  query?: { [key: string]: any };\n  /**\n   * If credentials (cookies) should be sent along during an XHR.\n   */\n  withCredentials: boolean;\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   * If the request is terminated, an `AbortError` is thrown.\n   */\n  timeout: number;\n  /**\n   * Proxy configuration.\n   */\n  proxySettings?: ProxySettings;\n  /**\n   * If the connection should be reused.\n   */\n  keepAlive?: boolean;\n  /**\n   * Whether or not to decompress response according to Accept-Encoding header (node-fetch only)\n   */\n  decompressResponse?: boolean;\n  /**\n   * A unique identifier for the request. Used for logging and tracing.\n   */\n  requestId: string;\n\n  /**\n   * Signal of an abort controller. Can be used to abort both sending a network request and waiting for a response.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Callback which fires upon download progress. */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n}\n\n/**\n * The properties on an HTTP response which will always be present.\n */\nexport interface HttpResponse {\n  /**\n   * The raw request\n   */\n  request: WebResourceLike;\n\n  /**\n   * The HTTP response status (e.g. 200)\n   */\n  status: number;\n\n  /**\n   * The HTTP response headers.\n   */\n  headers: HttpHeadersLike;\n}\n\nfunction toHttpHeaderLike(headers: HttpHeaders): HttpHeadersLike {\n  return new HttpHeadersV1(headers.toJSON({ preserveCase: true }));\n}\n\nfunction toWebResourceLike(request: PipelineRequest): WebResourceLike {\n  return {\n    url: request.url,\n    method: request.method,\n    headers: toHttpHeaderLike(request.headers),\n    withCredentials: request.withCredentials,\n    timeout: request.timeout,\n    requestId: request.headers.get(\"x-ms-client-request-id\") || \"\",\n  };\n}\n\n/**\n * Helper to transform PipelineResponse to slimmed-down HttpResponse used in Service Bus.\n */\nexport function toHttpResponse(response: PipelineResponse): HttpResponse {\n  return {\n    request: toWebResourceLike(response.request),\n    status: response.status,\n    headers: toHttpHeaderLike(response.headers),\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isMessagingError, MessagingError, translate } from \"@azure/core-amqp\";\nimport { AmqpError } from \"rhea-promise\";\nimport { isObjectWithProperties } from \"@azure/core-util\";\n\n/**\n * Service Bus failure codes.\n */\nexport type ServiceBusErrorCode =\n  // note: This list is intended to loosely follow https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/servicebus/Azure.Messaging.ServiceBus/src/Primitives/ServiceBusFailureReason.cs\n  /**\n   * The exception was the result of a general error within the client library.\n   */\n  | \"GeneralError\"\n  /**\n   * A Service Bus resource cannot be found by the Service Bus service.\n   */\n  | \"MessagingEntityNotFound\"\n  /**\n   * The lock on the message is lost. Callers should attempt to receive and process the message again.\n   */\n  | \"MessageLockLost\"\n  /**\n   * The requested message was not found.\n   */\n  | \"MessageNotFound\"\n  /**\n   * A message is larger than the maximum size allowed for its transport.\n   */\n  | \"MessageSizeExceeded\"\n  /**\n   * An entity with the same name exists under the same namespace.\n   */\n  | \"MessagingEntityAlreadyExists\"\n  /**\n   * The Messaging Entity is disabled. Enable the entity again using Portal.\n   */\n  | \"MessagingEntityDisabled\"\n  /**\n   * The quota applied to an Service Bus resource has been exceeded while interacting with the Azure Service Bus service.\n   */\n  | \"QuotaExceeded\"\n  /**\n   * The Azure Service Bus service reports that it is busy in response to a client request to perform an operation.\n   */\n  | \"ServiceBusy\"\n  /**\n   * An operation or other request timed out while interacting with the Azure Service Bus service.\n   */\n  | \"ServiceTimeout\"\n  /**\n   * There was a general communications error encountered when interacting with the Azure Service Bus service.\n   */\n  | \"ServiceCommunicationProblem\"\n  /**\n   * The requested session cannot be locked.\n   */\n  | \"SessionCannotBeLocked\"\n  /**\n   * The lock on the session has expired. Callers should request the session again.\n   */\n  | \"SessionLockLost\"\n  /**\n   * The user doesn't have access to the entity.\n   */\n  | \"UnauthorizedAccess\";\n\n/**\n * Translation between the MessagingErrorCodes into a ServiceBusCode\n *\n * @internal\n */\nexport const wellKnownMessageCodesToServiceBusCodes: Map<string, ServiceBusErrorCode> = new Map([\n  [\"MessagingEntityNotFoundError\", \"MessagingEntityNotFound\"],\n  [\"MessageLockLostError\", \"MessageLockLost\"],\n  [\"MessageNotFoundError\", \"MessageNotFound\"],\n  [\"MessageTooLargeError\", \"MessageSizeExceeded\"],\n  [\"MessagingEntityAlreadyExistsError\", \"MessagingEntityAlreadyExists\"],\n  [\"MessagingEntityDisabledError\", \"MessagingEntityDisabled\"],\n  [\"QuotaExceededError\", \"QuotaExceeded\"],\n  [\"ServerBusyError\", \"ServiceBusy\"],\n\n  [\"OperationTimeoutError\", \"ServiceTimeout\"],\n  [\"ServiceUnavailableError\", \"ServiceTimeout\"],\n  [\"ServiceCommunicationError\", \"ServiceCommunicationProblem\"],\n  [\"SessionCannotBeLockedError\", \"SessionCannotBeLocked\"],\n  [\"SessionLockLostError\", \"SessionLockLost\"],\n  [\"UnauthorizedError\", \"UnauthorizedAccess\"],\n]);\n\n/**\n * Errors that occur within Service Bus.\n */\nexport class ServiceBusError extends MessagingError {\n  /**\n   * The reason for the failure.\n   *\n   * - **GeneralError**: The exception was the result of a general error within the client library.\n   * - **MessagingEntityNotFound**: A Service Bus resource cannot be found by the Service Bus service.\n   * - **MessageLockLost**: The lock on the message is lost. Callers should attempt to receive and process the message again.\n   * - **MessageNotFound**: The requested message was not found.\n   * - **MessageSizeExceeded**: A message is larger than the maximum size allowed for its transport.\n   * - **MessagingEntityAlreadyExists**: An entity with the same name exists under the same namespace.\n   * - **MessagingEntityDisabled**: The Messaging Entity is disabled. Enable the entity again using Portal.\n   * - **QuotaExceeded**: The quota applied to an Service Bus resource has been exceeded while interacting with the Azure Service Bus service.\n   * - **ServiceBusy**: The Azure Service Bus service reports that it is busy in response to a client request to perform an operation.\n   * - **ServiceTimeout**: An operation or other request timed out while interacting with the Azure Service Bus service.\n   * - **ServiceCommunicationProblem**: There was a general communications error encountered when interacting with the Azure Service Bus service.\n   * - **SessionCannotBeLocked**: The requested session cannot be locked.\n   * - **SessionLockLost**: The lock on the session has expired. Callers should request the session again.\n   * - **UnauthorizedAccess\"**: The user doesn't have access to the entity.\n   */\n  // NOTE: make sure this list and the list above are properly kept in sync.\n  code: ServiceBusErrorCode;\n\n  /**\n   * @param message - The error message that provides more information about the error.\n   * @param code - The reason for the failure.\n   */\n  constructor(message: string, code: ServiceBusErrorCode);\n  /**\n   * @param messagingError - An error whose properties will be copied to the ServiceBusError.\n   */\n  constructor(messagingError: MessagingError);\n  constructor(messageOrError: string | MessagingError, code?: ServiceBusErrorCode) {\n    const message = typeof messageOrError === \"string\" ? messageOrError : messageOrError.message;\n    super(message);\n\n    if (typeof messageOrError === \"string\") {\n      this.code = code ?? \"GeneralError\";\n    } else {\n      for (const prop in messageOrError) {\n        (this as any)[prop] = (messageOrError as any)[prop];\n      }\n\n      this.code = ServiceBusError.normalizeMessagingCode(messageOrError.code);\n      // For GeneralErrors, prefix the error message with the MessagingError code to provide\n      // more context to the user.\n      if (this.code === \"GeneralError\" && messageOrError.code) {\n        this.message = `${messageOrError.code}: ${this.message}`;\n      }\n    }\n\n    this.name = \"ServiceBusError\";\n  }\n\n  private static normalizeMessagingCode(oldCode?: string): ServiceBusErrorCode {\n    if (oldCode == null || !wellKnownMessageCodesToServiceBusCodes.has(oldCode)) {\n      return \"GeneralError\";\n    }\n\n    return wellKnownMessageCodesToServiceBusCodes.get(oldCode)!;\n  }\n}\n\n/**\n * Translates an error into either an Error or a ServiceBusError which provides a `reason` code that\n * can be used by clients to programmatically react to errors.\n *\n * If you are calling `@azure/core-amqp/translate` you should swap to using this function instead since it provides\n * Service Bus specific handling of the error (falling back to default translate behavior otherwise).\n *\n * @internal\n */\nexport function translateServiceBusError(err: AmqpError | Error): ServiceBusError | Error {\n  if (isServiceBusError(err)) {\n    return err;\n  }\n\n  const translatedError = translate(err);\n\n  if (isMessagingError(translatedError)) {\n    return new ServiceBusError(translatedError);\n  }\n\n  return translatedError;\n}\n\n/**\n * Determines if an error is of type `ServiceBusError`\n *\n * @param err - An error to check to see if it's of type ServiceBusError\n */\nexport function isServiceBusError(err: unknown): err is ServiceBusError {\n  return isObjectWithProperties(err, [\"name\"]) && err.name === \"ServiceBusError\";\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport Long from \"long\";\nimport { logger, receiverLogger, messageLogger, ServiceBusLogger } from \"../log\";\nimport { AmqpError, OperationTimeoutError, generate_uuid } from \"rhea-promise\";\nimport isBuffer from \"is-buffer\";\nimport { Buffer } from \"buffer\";\nimport * as Constants from \"../util/constants\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { PipelineResponse } from \"@azure/core-rest-pipeline\";\nimport { isDefined } from \"@azure/core-util\";\nimport { HttpResponse, toHttpResponse } from \"./compat\";\nimport { ErrorNameConditionMapper, StandardAbortMessage, delay } from \"@azure/core-amqp\";\nimport { translateServiceBusError } from \"../serviceBusError\";\n\n// This is the only dependency we have on DOM types, so rather than require\n// the DOM lib we can just shim this in.\n/**\n * @hidden\n * @internal\n */\ninterface Navigator {\n  hardwareConcurrency: number;\n}\n/**\n * @hidden\n * @internal\n */\ndeclare const navigator: Navigator;\n\n/**\n * @internal\n * Provides a uniue name by appending a string guid to the given string in the following format:\n * `{name}-{uuid}`.\n * @param name - The nme of the entity\n */\nexport function getUniqueName(name: string): string {\n  return `${name}-${generate_uuid()}`;\n}\n\n/**\n * @internal\n * Returns the passed identifier if it is not undefined or empty;\n * otherwise generate and returns a unique one in the following format;\n *   `{prefix}-{uuid}`.\n * @param prefix - The prefix used to generate identifier\n * @param identifier - an identifier name\n */\nexport function ensureValidIdentifier(prefix: string, identifier?: string): string {\n  return identifier ? identifier : getUniqueName(prefix);\n}\n\n/**\n * @internal\n * If you try to turn a Guid into a Buffer in .NET, the bytes of the first three groups get\n * flipped within the group, but the last two groups don't get flipped, so we end up with a\n * different byte order. This is the order of bytes needed to make Service Bus recognize the token.\n *\n * @param lockToken - The lock token whose bytes need to be reorded.\n * @returns Buffer representing reordered bytes.\n */\nexport function reorderLockToken(lockTokenBytes: Buffer): Buffer {\n  if (!lockTokenBytes || !Buffer.isBuffer(lockTokenBytes)) {\n    return lockTokenBytes;\n  }\n\n  return Buffer.from([\n    lockTokenBytes[3],\n    lockTokenBytes[2],\n    lockTokenBytes[1],\n    lockTokenBytes[0],\n\n    lockTokenBytes[5],\n    lockTokenBytes[4],\n\n    lockTokenBytes[7],\n    lockTokenBytes[6],\n\n    lockTokenBytes[8],\n    lockTokenBytes[9],\n\n    lockTokenBytes[10],\n    lockTokenBytes[11],\n    lockTokenBytes[12],\n    lockTokenBytes[13],\n    lockTokenBytes[14],\n    lockTokenBytes[15],\n  ]);\n}\n\n/**\n * @internal\n * Provides the time in milliseconds after which the lock renewal should occur.\n * @param lockedUntilUtc - The time until which the message is locked.\n */\nexport function calculateRenewAfterDuration(lockedUntilUtc: Date): number {\n  const now = Date.now();\n  const lockedUntil = lockedUntilUtc.getTime();\n  const remainingTime = lockedUntil - now;\n  receiverLogger.verbose(\"Locked until utc  : %d\", lockedUntil);\n  receiverLogger.verbose(\"Current time is   : %d\", now);\n  receiverLogger.verbose(\"Remaining time is : %d\", remainingTime);\n  if (remainingTime < 1000) {\n    return 0;\n  }\n  const buffer = Math.min(remainingTime / 2, 10000); // 10 seconds\n  const renewAfter = remainingTime - buffer;\n  receiverLogger.verbose(\"Renew after       : %d\", renewAfter);\n  return renewAfter;\n}\n\n/**\n * @internal\n * Converts the .net ticks to a JS Date object.\n *\n * - The epoch for the DateTimeOffset type is `0000-01-01`, while the epoch for JS Dates is\n * `1970-01-01`.\n * - The DateTimeOffset ticks value for the date `1970-01-01` is `621355968000000000`.\n *   - Hence, to convert it to the JS epoch; we `subtract` the delta from the given value.\n * - Ticks in DateTimeOffset is `1/10000000` second, while ticks in JS Date is `1/1000` second.\n *   - Thus, we `divide` the value by `10000` to convert it to JS Date ticks.\n *\n * @param buf - Input as a Buffer\n * @returns The JS Date object.\n */\nexport function convertTicksToDate(buf: number[]): Date {\n  const epochMicroDiff: number = 621355968000000000;\n  const longValue: Long = Long.fromBytesBE(buf);\n  const timeInMS = longValue.sub(epochMicroDiff).div(10000).toNumber();\n  const result = new Date(timeInMS);\n  logger.verbose(\"The converted date is: %s\", result.toString());\n  return result;\n}\n\n/**\n * @internal\n * Converts any given input to a Buffer.\n * @param input - The input that needs to be converted to a Buffer.\n */\nexport function toBuffer(input: unknown): Buffer {\n  let result: any;\n  messageLogger.verbose(\n    \"[utils.toBuffer] The given message body that needs to be converted to buffer is: \",\n    input,\n  );\n  if (isBuffer(input)) {\n    result = input;\n  } else {\n    // string, undefined, null, boolean, array, object, number should end up here\n    // coercing undefined to null as that will ensure that null value will be given to the\n    // customer on receive.\n    if (input === undefined) input = null;\n    try {\n      const inputStr = JSON.stringify(input);\n      result = Buffer.from(inputStr, \"utf8\");\n    } catch (err: any) {\n      const msg =\n        `An error occurred while executing JSON.stringify() on the given input ` +\n        input +\n        `${err instanceof Error ? err.stack : JSON.stringify(err)}`;\n      messageLogger.warning(\"[utils.toBuffer] \" + msg);\n      throw err instanceof Error ? err : new Error(msg);\n    }\n  }\n  messageLogger.verbose(\"[utils.toBuffer] The converted buffer is: %O.\", result);\n  return result;\n}\n\n/**\n * @internal\n * Helper utility to retrieve `string` value from given string,\n * or throws error if undefined.\n */\nexport function getString(value: unknown, nameOfProperty: string): string {\n  const result = getStringOrUndefined(value);\n  if (result === undefined) {\n    throw new Error(\n      `\"${nameOfProperty}\" received from service expected to be a string value and not undefined.`,\n    );\n  }\n  return result;\n}\n\n/**\n * @internal\n * Helper utility to retrieve `string` value from given input,\n * or undefined if not passed in.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getStringOrUndefined(value: any): string | undefined {\n  if (!isDefined(value)) {\n    return undefined;\n  }\n  return value.toString();\n}\n\n/**\n * @internal\n * Helper utility to retrieve `integer` value from given string,\n * or throws error if undefined.\n */\nexport function getInteger(value: unknown, nameOfProperty: string): number {\n  const result = getIntegerOrUndefined(value);\n  if (result === undefined) {\n    throw new Error(\n      `\"${nameOfProperty}\" received from service expected to be a number value and not undefined.`,\n    );\n  }\n  return result;\n}\n\n/**\n * @internal\n * Helper utility to retrieve `integer` value from given string,\n * or undefined if not passed in.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getIntegerOrUndefined(value: any): number | undefined {\n  if (!isDefined(value)) {\n    return undefined;\n  }\n  const result = parseInt(value.toString());\n  return isNaN(result) ? undefined : result;\n}\n\n/**\n * @internal\n * Helper utility to convert ISO-8601 time into Date type.\n */\nexport function getDate(value: string, nameOfProperty: string): Date {\n  return new Date(getString(value, nameOfProperty));\n}\n\n/**\n * @internal\n * Helper utility to retrieve `boolean` value from given string,\n * or throws error if undefined.\n */\nexport function getBoolean(value: unknown, nameOfProperty: string): boolean {\n  const result = getBooleanOrUndefined(value);\n  if (result === undefined) {\n    throw new Error(\n      `\"${nameOfProperty}\" received from service expected to be a boolean value and not undefined.`,\n    );\n  }\n  return result;\n}\n\n/**\n * @internal\n * Helper utility to retrieve `boolean` value from given string,\n * or undefined if not passed in.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getBooleanOrUndefined(value: any): boolean | undefined {\n  if (!isDefined(value)) {\n    return undefined;\n  }\n  return value.toString().trim().toLowerCase() === \"true\";\n}\n\n/**\n * @internal\n * Helps in differentiating JSON like objects from other kinds of objects.\n */\nconst EMPTY_JSON_OBJECT_CONSTRUCTOR = {}.constructor;\n\n/**\n * @internal\n * Returns `true` if given input is a JSON like object.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function isJSONLikeObject(value: any): boolean {\n  // `value.constructor === {}.constructor` differentiates among the \"object\"s,\n  //    would filter the JSON objects and won't match any array or other kinds of objects\n\n  // -------------------------------------------------------------------------------\n  // Few examples       | typeof obj ===\"object\" |  obj.constructor==={}.constructor\n  // -------------------------------------------------------------------------------\n  // {abc:1}            | true                   | true\n  // [\"a\",\"b\"]          | true                   | false\n  // [{\"a\":1},{\"b\":2}]  | true                   | false\n  // new Date()         | true                   | false\n  // 123                | false                  | false\n  // -------------------------------------------------------------------------------\n  return typeof value === \"object\" && value.constructor === EMPTY_JSON_OBJECT_CONSTRUCTOR;\n}\n\n/**\n * @internal\n * Helper utility to retrieve message count details from given input,\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getMessageCountDetails(value: any): MessageCountDetails {\n  const xmlnsPrefix = getXMLNSPrefix(value);\n  if (!isDefined(value)) {\n    value = {};\n  }\n  return {\n    activeMessageCount: parseInt(value[`${xmlnsPrefix}:ActiveMessageCount`]) || 0,\n    deadLetterMessageCount: parseInt(value[`${xmlnsPrefix}:DeadLetterMessageCount`]) || 0,\n    scheduledMessageCount: parseInt(value[`${xmlnsPrefix}:ScheduledMessageCount`]) || 0,\n    transferMessageCount: parseInt(value[`${xmlnsPrefix}:TransferMessageCount`]) || 0,\n    transferDeadLetterMessageCount:\n      parseInt(value[`${xmlnsPrefix}:TransferDeadLetterMessageCount`]) || 0,\n  };\n}\n\n/**\n * @internal\n * Gets the xmlns prefix from the root of the objects that are part of the parsed response body.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getXMLNSPrefix(value: any): string {\n  if (!value[Constants.XML_METADATA_MARKER]) {\n    throw new Error(\n      `Error occurred while parsing the response body - cannot find the XML_METADATA_MARKER \"$\" on the object ${JSON.stringify(\n        value,\n      )}`,\n    );\n  }\n  const keys = Object.keys(value[Constants.XML_METADATA_MARKER]);\n  if (keys.length !== 1) {\n    throw new Error(\n      `Error occurred while parsing the response body - unexpected number of \"xmlns:\\${prefix}\" keys at ${JSON.stringify(\n        value[Constants.XML_METADATA_MARKER],\n      )}`,\n    );\n  }\n  if (!keys[0].startsWith(\"xmlns:\")) {\n    throw new Error(\n      `Error occurred while parsing the response body - unexpected key at ${JSON.stringify(\n        value[Constants.XML_METADATA_MARKER],\n      )}`,\n    );\n  }\n  // Pick the substring that's after \"xmlns:\"\n  const xmlnsPrefix = keys[0].substring(6);\n  if (!xmlnsPrefix) {\n    throw new Error(\n      `Error occurred while parsing the response body - unexpected xmlns prefix at ${JSON.stringify(\n        value[Constants.XML_METADATA_MARKER],\n      )}`,\n    );\n  }\n  return xmlnsPrefix;\n}\n\n/**\n * Represents type of message count details in ATOM based management operations.\n * @internal\n */\nexport type MessageCountDetails = {\n  activeMessageCount: number;\n  deadLetterMessageCount: number;\n  scheduledMessageCount: number;\n  transferMessageCount: number;\n  transferDeadLetterMessageCount: number;\n};\n\n/**\n * Represents type of `AuthorizationRule` in ATOM based management operations.\n */\nexport interface AuthorizationRule {\n  /**\n   * The claim type.\n   */\n  claimType: string;\n  /**\n   * The list of rights(\"Manage\" | \"Send\" | \"Listen\").\n   */\n  accessRights?: (\"Manage\" | \"Send\" | \"Listen\")[];\n  /**\n   * The authorization rule key name.\n   */\n  keyName: string;\n  /**\n   * The primary key for the authorization rule.\n   */\n  primaryKey?: string;\n  /**\n   * The secondary key for the authorization rule.\n   */\n  secondaryKey?: string;\n}\n\n/**\n * @internal\n * Helper utility to retrieve array of `AuthorizationRule` from given input,\n * or undefined if not passed in.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getAuthorizationRulesOrUndefined(value: any): AuthorizationRule[] | undefined {\n  const authorizationRules: AuthorizationRule[] = [];\n\n  // Ignore special case as Service Bus treats \"\" as a valid value for authorization rules\n  if (typeof value === \"string\" && value.trim() === \"\") {\n    return undefined;\n  }\n\n  if (!isDefined(value)) {\n    return undefined;\n  }\n\n  const rawAuthorizationRules = value.AuthorizationRule;\n  if (Array.isArray(rawAuthorizationRules)) {\n    for (let i = 0; i < rawAuthorizationRules.length; i++) {\n      authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules[i]));\n    }\n  } else {\n    authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules));\n  }\n  return authorizationRules;\n}\n\n/**\n * @internal\n * Helper utility to build an instance of parsed authorization rule as `AuthorizationRule` from given input.\n */\nfunction buildAuthorizationRule(value: any): AuthorizationRule {\n  let accessRights;\n  if (isDefined(value[\"Rights\"])) {\n    accessRights = value[\"Rights\"][\"AccessRights\"];\n  }\n\n  const authorizationRule: AuthorizationRule = {\n    claimType: value[\"ClaimType\"],\n    accessRights,\n    keyName: value[\"KeyName\"],\n    primaryKey: value[\"PrimaryKey\"],\n    secondaryKey: value[\"SecondaryKey\"],\n  };\n\n  if (authorizationRule.accessRights && !Array.isArray(authorizationRule.accessRights)) {\n    authorizationRule.accessRights = [authorizationRule.accessRights];\n  }\n  return authorizationRule;\n}\n\n/**\n * @internal\n * Helper utility to extract output containing array of `RawAuthorizationRule` instances from given input,\n * or undefined if not passed in.\n */\nexport function getRawAuthorizationRules(authorizationRules: AuthorizationRule[] | undefined): any {\n  if (!isDefined(authorizationRules)) {\n    return undefined;\n  }\n\n  if (!Array.isArray(authorizationRules)) {\n    throw new TypeError(\n      `authorizationRules must be an array of AuthorizationRule objects or undefined, but received ${JSON.stringify(\n        authorizationRules,\n        undefined,\n        2,\n      )}`,\n    );\n  }\n\n  const rawAuthorizationRules: any[] = [];\n  for (let i = 0; i < authorizationRules.length; i++) {\n    rawAuthorizationRules.push(buildRawAuthorizationRule(authorizationRules[i]));\n  }\n  return { AuthorizationRule: rawAuthorizationRules };\n}\n\n/**\n * @internal\n * Helper utility to build an instance of raw authorization rule as RawAuthorizationRule from given `AuthorizationRule` input.\n * @param authorizationRule - parsed Authorization Rule instance\n */\nfunction buildRawAuthorizationRule(authorizationRule: AuthorizationRule): any {\n  if (!isJSONLikeObject(authorizationRule) || authorizationRule === null) {\n    throw new TypeError(\n      `Expected authorizationRule input to be a JS object value, but received ${JSON.stringify(\n        authorizationRule,\n        undefined,\n        2,\n      )}`,\n    );\n  }\n\n  const rawAuthorizationRule: any = {\n    ClaimType: authorizationRule.claimType,\n    // ClaimValue is not settable by the users, but service expects the value for PUT requests\n    ClaimValue: \"None\",\n    Rights: {\n      AccessRights: authorizationRule.accessRights,\n    },\n    KeyName: authorizationRule.keyName,\n    PrimaryKey: authorizationRule.primaryKey,\n    SecondaryKey: authorizationRule.secondaryKey,\n  };\n  rawAuthorizationRule[Constants.XML_METADATA_MARKER] = {\n    \"p5:type\": \"SharedAccessAuthorizationRule\",\n    \"xmlns:p5\": \"http://www.w3.org/2001/XMLSchema-instance\",\n  };\n  return rawAuthorizationRule;\n}\n\n/**\n * @internal\n * Helper utility to check if given string is an absolute URL\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  const _url = url.toLowerCase();\n  return _url.startsWith(\"sb://\") || _url.startsWith(\"http://\") || _url.startsWith(\"https://\");\n}\n\n/**\n * Possible values for `status` of the Service Bus messaging entities.\n */\nexport type EntityStatus =\n  | \"Active\"\n  | \"Creating\"\n  | \"Deleting\"\n  | \"ReceiveDisabled\"\n  | \"SendDisabled\"\n  | \"Disabled\"\n  | \"Renaming\"\n  | \"Restoring\"\n  | \"Unknown\";\n\n/**\n * Possible values for `availabilityStatus` of the Service Bus messaging entities.\n */\nexport type EntityAvailabilityStatus =\n  | \"Available\"\n  | \"Limited\"\n  | \"Renaming\"\n  | \"Restoring\"\n  | \"Unknown\";\n\n/**\n * @internal\n */\ntype setTimeoutArgs = (callback: (...args: any[]) => void, ms: number, ...args: any[]) => any;\n\n/**\n * An executor for a function that returns a Promise that obeys both a timeout and an\n * optional AbortSignal.\n * @param timeoutMs - The number of milliseconds to allow before throwing an OperationTimeoutError.\n * @param timeoutMessage - The message to place in the .description field for the thrown exception for Timeout.\n * @param abortSignal - The abortSignal associated with containing operation.\n * @param abortErrorMsg - The abort error message associated with containing operation.\n * @param value - The value to be resolved with after a timeout of t milliseconds.\n *\n * @internal\n */\nexport async function waitForTimeoutOrAbortOrResolve<T>(args: {\n  actionFn: () => Promise<T>;\n  timeoutMs: number;\n  timeoutMessage: string;\n  abortSignal?: AbortSignalLike;\n  // these are optional and only here for testing.\n  timeoutFunctions?: {\n    setTimeoutFn: setTimeoutArgs;\n    clearTimeoutFn: (timeoutId: any) => void;\n  };\n}): Promise<T> {\n  if (args.abortSignal && args.abortSignal.aborted) {\n    throw new AbortError(StandardAbortMessage);\n  }\n\n  let timer: any | undefined = undefined;\n  let clearAbortSignal: (() => void) | undefined = undefined;\n\n  const clearAbortSignalAndTimer = (): void => {\n    (args.timeoutFunctions?.clearTimeoutFn ?? clearTimeout)(timer);\n\n    if (clearAbortSignal) {\n      clearAbortSignal();\n    }\n  };\n\n  // eslint-disable-next-line promise/param-names\n  const abortOrTimeoutPromise = new Promise<T>((_resolve, reject) => {\n    clearAbortSignal = checkAndRegisterWithAbortSignal(reject, args.abortSignal);\n\n    timer = (args.timeoutFunctions?.setTimeoutFn ?? setTimeout)(() => {\n      reject(new OperationTimeoutError(args.timeoutMessage));\n    }, args.timeoutMs);\n  });\n\n  try {\n    return await Promise.race([abortOrTimeoutPromise, args.actionFn()]);\n  } finally {\n    clearAbortSignalAndTimer();\n  }\n}\n\n/**\n * Registers listener to the abort event on the abortSignal to call your abortFn and\n * returns a function that will clear the same listener.\n *\n * If abort signal is already aborted, then throws an AbortError and returns a function that does nothing\n *\n * @returns A function that removes any of our attached event listeners on the abort signal or an empty function if\n * the abortSignal was not defined.\n *\n * @internal\n */\nexport function checkAndRegisterWithAbortSignal(\n  onAbortFn: (abortError: AbortError) => void,\n  abortSignal?: AbortSignalLike,\n): () => void {\n  if (abortSignal == null) {\n    return () => {\n      /** Nothing to do here, no abort signal */\n    };\n  }\n\n  if (abortSignal.aborted) {\n    throw new AbortError(StandardAbortMessage);\n  }\n\n  const onAbort = (): void => {\n    abortSignal.removeEventListener(\"abort\", onAbort);\n    onAbortFn(new AbortError(StandardAbortMessage));\n  };\n\n  abortSignal.addEventListener(\"abort\", onAbort);\n\n  return () => abortSignal.removeEventListener(\"abort\", onAbort);\n}\n\n/**\n * @internal\n * The user agent prefix string for the ServiceBus client.\n * See guideline at https://azure.github.io/azure-sdk/general_azurecore.html#telemetry-policy\n */\nexport const libInfo: string = `azsdk-js-azureservicebus/${Constants.packageJsonInfo.version}`;\n\n/**\n * @internal\n * Returns the formatted prefix by removing the spaces, by appending the libInfo.\n */\nexport function formatUserAgentPrefix(prefix?: string): string {\n  let userAgentPrefix = `${(prefix || \"\").replace(\" \", \"\")}`;\n  userAgentPrefix = userAgentPrefix.length > 0 ? userAgentPrefix + \" \" : \"\";\n  return `${userAgentPrefix}${libInfo}`;\n}\n\n/**\n * @internal\n * Helper method which returns `HttpResponse` from an object of shape `PipelineResponse`.\n * TODO: remove this and use toHttpResponse() directly\n */\nexport const getHttpResponseOnly = (pipelineResponse: PipelineResponse): HttpResponse =>\n  toHttpResponse(pipelineResponse);\n\n/**\n * @internal\n * Type with the service versions for the ATOM API.\n */\nexport type ServiceBusAtomAPIVersion = \"2021-05\" | \"2017-04\";\n\n/**\n * @internal\n * Waits for one second if a sender is not sendable then check again. Throws\n * SenderBusyError if it is still not sendable.\n * Only waits when operation timeout is greater than one second.\n * @returns the actual waiting time.\n */\nexport async function waitForSendable(\n  sendLogger: ServiceBusLogger,\n  logPrefix: string,\n  name: string,\n  timeout: number,\n  sender:\n    | {\n        sendable: () => boolean;\n        credit: number;\n      }\n    | undefined,\n  outgoingAvaiable: number,\n): Promise<number> {\n  let waitTimeForSendable = 1000;\n  if (!sender?.sendable() && timeout > waitTimeForSendable) {\n    sendLogger.verbose(\n      \"%s Sender '%s', waiting for 1 second for sender to become sendable\",\n      logPrefix,\n      name,\n    );\n\n    await delay(waitTimeForSendable);\n\n    sendLogger.verbose(\n      \"%s Sender '%s' after waiting for a second, credit: %d available: %d\",\n      logPrefix,\n      name,\n      sender?.credit,\n      outgoingAvaiable,\n    );\n  } else {\n    waitTimeForSendable = 0;\n  }\n\n  if (!sender?.sendable()) {\n    // let us retry to send the message after some time.\n    const msg =\n      `[${logPrefix}] Sender \"${name}\", ` + `cannot send the message right now. Please try later.`;\n    sendLogger.warning(msg);\n    const amqpError: AmqpError = {\n      condition: ErrorNameConditionMapper.SenderBusyError,\n      description: msg,\n    };\n    throw translateServiceBusError(amqpError);\n  }\n  return waitTimeForSendable;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  PipelineResponse,\n  RestError,\n  PipelineRequest,\n  TransferProgressEvent,\n} from \"@azure/core-rest-pipeline\";\nimport { ServiceClient, OperationOptions, FullOperationResponse } from \"@azure/core-client\";\nimport { parseXML, stringifyXML } from \"@azure/core-xml\";\n\nimport * as Constants from \"./constants\";\nimport { administrationLogger as logger } from \"../log\";\nimport { Buffer } from \"buffer\";\n\nimport { parseURL } from \"./parseUrl\";\nimport { isJSONLikeObject } from \"./utils\";\nimport { isDefined } from \"@azure/core-util\";\nimport { OperationTracingOptions } from \"@azure/core-tracing\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { InternalQueueOptions } from \"../serializers/queueResourceSerializer\";\nimport { InternalTopicOptions } from \"../serializers/topicResourceSerializer\";\nimport { InternalSubscriptionOptions } from \"../serializers/subscriptionResourceSerializer\";\nimport { CreateRuleOptions } from \"../serializers/ruleResourceSerializer\";\n\n/**\n * @internal\n * Represents the internal ATOM XML serializer interface\n */\nexport interface AtomXmlSerializer {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  serialize(requestBodyInJson: object): Record<string, unknown>;\n\n  deserialize(response: FullOperationResponse): Promise<FullOperationResponse>;\n}\n\n/**\n   applies options to the pipeline request.\n  */\nfunction applyRequestOptions(\n  request: PipelineRequest,\n  options: {\n    headers?: Record<string, string>;\n    onUploadProgress?: (progress: TransferProgressEvent) => void;\n    onDownloadProgress?: (progress: TransferProgressEvent) => void;\n    abortSignal?: AbortSignalLike;\n    tracingOptions?: OperationTracingOptions;\n    timeout: number;\n  },\n): void {\n  if (options.headers) {\n    const headers = options.headers;\n    for (const headerName of Object.keys(headers)) {\n      request.headers.set(headerName, headers[headerName]);\n    }\n  }\n  request.onDownloadProgress = options.onDownloadProgress;\n  request.onUploadProgress = options.onUploadProgress;\n  request.abortSignal = options.abortSignal;\n  request.timeout = options.timeout;\n  if (options.tracingOptions) {\n    request.tracingOptions = options.tracingOptions;\n  }\n}\n\n/**\n * @internal\n * Utility to execute Atom XML operations as HTTP requests\n */\nexport async function executeAtomXmlOperation(\n  serviceBusAtomManagementClient: ServiceClient,\n  request: PipelineRequest,\n  serializer: AtomXmlSerializer,\n  operationOptions: OperationOptions,\n  requestObject?:\n    | InternalQueueOptions\n    | InternalTopicOptions\n    | InternalSubscriptionOptions\n    | CreateRuleOptions,\n): Promise<FullOperationResponse> {\n  if (requestObject) {\n    request.body = stringifyXML(serializer.serialize(requestObject), { rootName: \"entry\" });\n    if (request.method === \"PUT\") {\n      request.headers.set(\"content-length\", Buffer.byteLength(request.body));\n    }\n  }\n\n  logger.verbose(`Executing ATOM based HTTP request: ${request.body}`);\n\n  const reqPrepareOptions = {\n    headers: operationOptions.requestOptions?.customHeaders,\n    onUploadProgress: operationOptions.requestOptions?.onUploadProgress,\n    onDownloadProgress: operationOptions.requestOptions?.onDownloadProgress,\n    abortSignal: operationOptions.abortSignal,\n    tracingOptions: operationOptions.tracingOptions,\n    disableJsonStringifyOnBody: true,\n    timeout: operationOptions.requestOptions?.timeout || 0,\n  };\n  applyRequestOptions(request, reqPrepareOptions);\n  const response: PipelineResponse = await serviceBusAtomManagementClient.sendRequest(request);\n\n  logger.verbose(`Received ATOM based HTTP response: ${response.bodyAsText}`);\n\n  try {\n    if (response.bodyAsText) {\n      (response as FullOperationResponse).parsedBody = await parseXML(response.bodyAsText, {\n        includeRoot: true,\n      });\n    }\n  } catch (err: any) {\n    const error = new RestError(\n      `Error occurred while parsing the response body - expected the service to return valid xml content.`,\n      {\n        code: RestError.PARSE_ERROR,\n        statusCode: response.status,\n        request: response.request,\n        response,\n      },\n    );\n    logger.logError(err, \"Error parsing response body from Service\");\n    throw error;\n  }\n\n  return serializer.deserialize(response);\n}\n\n/**\n * @internal\n * The key-value pairs having undefined/null as the values would lead to the empty tags in the serialized XML request.\n * Empty tags in the request body is problematic because of the following reasons.\n * - ATOM based management operations throw a \"Bad Request\" error if empty tags are included in the XML request body at top level.\n * - At the inner levels, Service assigns the empty strings as values to the empty tags instead of throwing an error.\n *\n * This method recursively removes the key-value pairs with undefined/null as the values from the request object that is to be serialized.\n *\n */\nexport function sanitizeSerializableObject(resource: { [key: string]: any }): void {\n  Object.keys(resource).forEach(function (property) {\n    if (!isDefined(resource[property])) {\n      delete resource[property];\n    } else if (isJSONLikeObject(resource[property])) {\n      sanitizeSerializableObject(resource[property]);\n    }\n  });\n}\n\n/**\n * @internal\n * Serializes input information to construct the Atom XML request\n * @param resourceName - Name of the resource to be serialized like `QueueDescription`\n * @param resource - The entity details\n * @param allowedProperties - The set of properties that are allowed by the service for the\n * associated operation(s);\n */\nexport function serializeToAtomXmlRequest(\n  resourceName: string,\n  resource: unknown,\n): Record<string, unknown> {\n  const content: any = {};\n\n  content[resourceName] = Object.assign({}, resource);\n  sanitizeSerializableObject(content[resourceName]);\n\n  content[resourceName][Constants.XML_METADATA_MARKER] = {\n    xmlns: \"http://schemas.microsoft.com/netservices/2010/10/servicebus/connect\",\n    \"xmlns:i\": \"http://www.w3.org/2001/XMLSchema-instance\",\n  };\n\n  content[Constants.XML_METADATA_MARKER] = { type: \"application/xml\" };\n  const requestDetails: Record<string, unknown> = {\n    updated: new Date().toISOString(),\n    content: content,\n  };\n  requestDetails[Constants.XML_METADATA_MARKER] = {\n    xmlns: \"http://www.w3.org/2005/Atom\",\n  };\n  return requestDetails;\n}\n\n/**\n * @internal\n * Transforms response to contain the parsed data.\n * @param nameProperties - The set of 'name' properties to be constructed on the\n * resultant object e.g., QueueName, TopicName, etc.\n */\nexport async function deserializeAtomXmlResponse(\n  nameProperties: string[],\n  response: FullOperationResponse,\n): Promise<FullOperationResponse> {\n  // If received data is a non-valid HTTP response, the body is expected to contain error information\n  if (response.status < 200 || response.status >= 300) {\n    throw buildError(response);\n  }\n\n  parseAtomResult(response, nameProperties);\n\n  return response;\n}\n\n/**\n * @internal\n * Utility to deserialize the given JSON content in response body based on\n * if it's a single `entry` or `feed` and updates the `response.parsedBody` to hold the evaluated output.\n * @param response - Response containing the JSON value in `response.parsedBody`\n * @param nameProperties - The set of 'name' properties to be constructed on the\n * resultant object e.g., QueueName, TopicName, etc.\n * */\nfunction parseAtomResult(response: FullOperationResponse, nameProperties: string[]): void {\n  const atomResponseInJson = response.parsedBody;\n\n  let result: any;\n  if (!atomResponseInJson) {\n    response.parsedBody = undefined;\n    return;\n  }\n\n  if (atomResponseInJson.feed) {\n    result = parseFeedResult(atomResponseInJson.feed);\n  } else if (atomResponseInJson.entry) {\n    result = parseEntryResult(atomResponseInJson.entry);\n  }\n\n  if (result) {\n    if (Array.isArray(result)) {\n      result.forEach((entry) => {\n        setName(entry, nameProperties);\n      });\n    } else {\n      setName(result, nameProperties);\n    }\n    response.parsedBody = result;\n    return;\n  }\n\n  logger.warning(\n    \"Failure in parsing response body from service. Expected response to be in Atom XML format and have either feed or entry components, but received - %0\",\n    atomResponseInJson,\n  );\n  throw new RestError(\n    \"Error occurred while parsing the response body - expected the service to return atom xml content with either feed or entry elements.\",\n    {\n      code: RestError.PARSE_ERROR,\n      statusCode: response.status,\n      request: response.request,\n      response,\n    },\n  );\n}\n\n/**\n * @internal\n * Utility to help parse given `entry` result\n */\nfunction parseEntryResult(entry: any): Record<string, unknown> | undefined {\n  let result: any;\n\n  if (\n    typeof entry !== \"object\" ||\n    entry == null ||\n    typeof entry.content !== \"object\" ||\n    entry.content == null\n  ) {\n    return undefined;\n  }\n\n  const contentElementNames = Object.keys(entry.content).filter(function (key) {\n    return key !== Constants.XML_METADATA_MARKER;\n  });\n\n  if (contentElementNames && contentElementNames[0]) {\n    const contentRootElementName = contentElementNames[0];\n    delete entry.content[contentRootElementName][Constants.XML_METADATA_MARKER];\n    result = entry.content[contentRootElementName];\n\n    if (result) {\n      if (entry[Constants.XML_METADATA_MARKER]) {\n        result[Constants.ATOM_METADATA_MARKER] = entry[Constants.XML_METADATA_MARKER];\n      } else {\n        result[Constants.ATOM_METADATA_MARKER] = {};\n      }\n\n      result[Constants.ATOM_METADATA_MARKER][\"ContentRootElement\"] = contentRootElementName;\n\n      Object.keys(entry).forEach((property: string) => {\n        if (property !== \"content\" && property !== Constants.XML_METADATA_MARKER) {\n          result[Constants.ATOM_METADATA_MARKER][property] = entry[property];\n        }\n      });\n\n      return result;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * @internal\n * Utility to help parse link info from the given `feed` result\n */\nfunction parseLinkInfo(\n  feedLink: { [Constants.XML_METADATA_MARKER]: { rel: string; href: string } }[],\n  relationship: \"self\" | \"next\",\n): string | undefined {\n  if (!feedLink || !Array.isArray(feedLink)) {\n    return undefined;\n  }\n  for (const linkInfo of feedLink) {\n    if (linkInfo[Constants.XML_METADATA_MARKER].rel === relationship) {\n      return linkInfo[Constants.XML_METADATA_MARKER].href;\n    }\n  }\n  return undefined;\n}\n\n/**\n * @internal\n * Utility to help parse given `feed` result\n */\nfunction parseFeedResult(feed: any): Record<string, unknown>[] & { nextLink?: string } {\n  const result: Record<string, unknown>[] & { nextLink?: string } = [];\n  if (typeof feed === \"object\" && feed != null && feed.entry) {\n    if (Array.isArray(feed.entry)) {\n      feed.entry.forEach((entry: any) => {\n        const parsedEntryResult = parseEntryResult(entry);\n        if (parsedEntryResult) {\n          result.push(parsedEntryResult);\n        }\n      });\n    } else {\n      const parsedEntryResult = parseEntryResult(feed.entry);\n      if (parsedEntryResult) {\n        result.push(parsedEntryResult);\n      }\n    }\n    result.nextLink = parseLinkInfo(feed.link, \"next\");\n  }\n  return result;\n}\n\n/**\n * @internal\n */\nfunction isKnownResponseCode(\n  statusCode: number,\n): statusCode is keyof typeof Constants.HttpResponseCodes {\n  return !!(Constants.HttpResponseCodes as { [statusCode: number]: string })[statusCode];\n}\n\n/**\n * @internal\n * Extracts the applicable entity name(s) from the URL based on the known structure\n * and instantiates the corresponding name properties to the deserialized response\n *\n * The pattern matching checks to extract entity names are based on following\n * constraints dictated by the service\n * - '/' is allowed in Queue and Topic names\n * - '/' is not allowed in Namespace, Subscription and Rule names\n * - Valid pathname URL structures used in the ATOM based management API are\n *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>/Rules/<rule-name>`\n *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>`\n *     - `<namespace-component>/<any-entity-name>`\n *\n */\nfunction setName(entry: any, nameProperties: any): any {\n  if (entry[Constants.ATOM_METADATA_MARKER]) {\n    let rawUrl = entry[Constants.ATOM_METADATA_MARKER].id;\n\n    // The parsedUrl gets constructed differently for browser vs Node.\n    // It is specifically behaves different for some of the Atom based management API where\n    // the received URL in \"id\" element is of type \"sb:// ... \" and not a standard HTTP one\n    // Hence, normalizing the URL for parsing to work as expected in browser\n    if (rawUrl.startsWith(\"sb://\")) {\n      rawUrl = \"https://\" + rawUrl.substring(5);\n    }\n\n    const parsedUrl = parseURL(rawUrl);\n    const pathname: string = parsedUrl.pathname;\n\n    const firstIndexOfDelimiter = pathname.indexOf(\"/\");\n\n    if (pathname.match(\"(.*)/(.*)/Subscriptions/(.*)/Rules/(.*)\")) {\n      const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf(\"/Subscriptions/\");\n      const firstIndexOfRulesDelimiter = pathname.indexOf(\"/Rules/\");\n      entry[nameProperties[0]] = pathname.substring(\n        firstIndexOfDelimiter + 1,\n        lastIndexOfSubscriptionsDelimiter,\n      );\n      entry[nameProperties[1]] = pathname.substring(\n        lastIndexOfSubscriptionsDelimiter + 15,\n        firstIndexOfRulesDelimiter,\n      );\n      entry[nameProperties[2]] = pathname.substring(firstIndexOfRulesDelimiter + 7);\n    } else if (pathname.match(\"(.*)/(.*)/Subscriptions/(.*)\")) {\n      const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf(\"/Subscriptions/\");\n      entry[nameProperties[0]] = pathname.substring(\n        firstIndexOfDelimiter + 1,\n        lastIndexOfSubscriptionsDelimiter,\n      );\n      entry[nameProperties[1]] = pathname.substring(lastIndexOfSubscriptionsDelimiter + 15);\n    } else if (pathname.match(\"(.*)/(.*)\")) {\n      entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1);\n    }\n  }\n}\n\n/**\n * @internal\n * Utility to help construct the normalized `RestError` object based on given error\n * information and other data present in the received `response` object.\n */\nexport function buildError(response: FullOperationResponse): RestError {\n  if (!isKnownResponseCode(response.status)) {\n    throw new RestError(\n      `Service returned an error response with an unrecognized HTTP status code - ${response.status}`,\n      {\n        code: \"ServiceError\",\n        statusCode: response.status,\n        request: response.request,\n        response,\n      },\n    );\n  }\n\n  const errorBody = response.parsedBody;\n  let errorMessage;\n  if (typeof errorBody === \"string\") {\n    errorMessage = errorBody;\n  } else {\n    if (\n      !isDefined(errorBody) ||\n      !isDefined(errorBody.Error) ||\n      !isDefined(errorBody.Error.Detail)\n    ) {\n      errorMessage =\n        \"Detailed error message information not available. Look at the 'code' property on error for more information.\";\n    } else {\n      errorMessage = errorBody.Error.Detail;\n    }\n  }\n\n  const errorCode = getErrorCode(response, errorMessage);\n\n  const error: RestError = new RestError(errorMessage, {\n    code: errorCode,\n    statusCode: response.status,\n    request: response.request,\n    response,\n  });\n  return error;\n}\n\n/**\n * @internal\n * Helper utility to construct user friendly error codes based on based on given error\n * information and other data present in the received `response` object.\n */\nfunction getErrorCode(response: PipelineResponse, errorMessage: string): string {\n  if (response.status === 401) {\n    return \"UnauthorizedRequestError\";\n  }\n  if (response.status === 404) {\n    return \"MessageEntityNotFoundError\";\n  }\n  if (response.status === 409) {\n    if (response.request.method === \"DELETE\") {\n      return \"ServiceError\";\n    }\n\n    if (response.request.method === \"PUT\" && response.request.headers.get(\"If-Match\") === \"*\") {\n      return \"ServiceError\";\n    }\n\n    if (errorMessage && errorMessage.toLowerCase().includes(\"subcode=40901\")) {\n      return \"ServiceError\";\n    }\n\n    return \"MessageEntityAlreadyExistsError\";\n  }\n\n  if (response.status === 403) {\n    if (errorMessage && errorMessage.toLowerCase().includes(\"subcode=40301\")) {\n      return \"InvalidOperationError\";\n    }\n    return \"QuotaExceededError\";\n  }\n\n  if (response.status === 400) {\n    return \"ServiceError\";\n  }\n\n  if (response.status === 503) {\n    return \"ServerBusyError\";\n  }\n\n  return (Constants.HttpResponseCodes as { [statusCode: number]: string })[response.status];\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { FullOperationResponse } from \"@azure/core-client\";\nimport {\n  AtomXmlSerializer,\n  deserializeAtomXmlResponse,\n  serializeToAtomXmlRequest,\n} from \"../util/atomXmlHelper\";\nimport { getInteger, getString, getDate } from \"../util/utils\";\n\n/**\n * Represents the metadata related to a service bus namespace.\n *\n */\nexport interface NamespaceProperties {\n  /**\n   * The time at which the namespace was created.\n   */\n  createdAt: Date;\n  /**\n   * The SKU/tier of the namespace.\n   * \"Basic\", \"Standard\" and \"Premium\"\n   */\n  messagingSku: \"Basic\" | \"Premium\" | \"Standard\";\n  /**\n   * The last time at which the namespace was modified.\n   */\n  modifiedAt: Date;\n  /**\n   * Name of the namespace.\n   */\n  name: string;\n  /**\n   * Number of messaging units allocated for namespace.\n   * Valid only for Premium namespaces.\n   * messagingUnits would be set to `undefined` for Basic and Standard namespaces.\n   */\n  messagingUnits: number | undefined;\n}\n\n/**\n * @internal\n * Builds the namespace object from the raw json object gotten after deserializing the\n * response from the service\n */\nexport function buildNamespace(rawNamespace: Record<string, any>): NamespaceProperties {\n  const messagingSku = <\"Basic\" | \"Premium\" | \"Standard\">(\n    getString(rawNamespace[\"MessagingSKU\"], \"messagingSku\")\n  );\n  return {\n    createdAt: getDate(rawNamespace[\"CreatedTime\"], \"createdAt\"),\n    messagingSku: messagingSku,\n    modifiedAt: getDate(rawNamespace[\"ModifiedTime\"], \"modifiedAt\"),\n    name: getString(rawNamespace[\"Name\"], \"name\"),\n    messagingUnits:\n      messagingSku === \"Premium\"\n        ? getInteger(rawNamespace[\"MessagingUnits\"], \"messagingUnits\")\n        : undefined,\n  };\n}\n\n/**\n * @internal\n * Atom XML Serializer for Namespaces.\n */\nexport class NamespaceResourceSerializer implements AtomXmlSerializer {\n  serialize(): Record<string, unknown> {\n    return serializeToAtomXmlRequest(\"NamespaceProperties\", {});\n  }\n\n  async deserialize(response: FullOperationResponse): Promise<FullOperationResponse> {\n    return deserializeAtomXmlResponse([\"name\"], response);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { FullOperationResponse, OperationOptions } from \"@azure/core-client\";\nimport {\n  AtomXmlSerializer,\n  deserializeAtomXmlResponse,\n  serializeToAtomXmlRequest,\n} from \"../util/atomXmlHelper\";\nimport * as Constants from \"../util/constants\";\nimport {\n  AuthorizationRule,\n  getAuthorizationRulesOrUndefined,\n  getBoolean,\n  getMessageCountDetails,\n  getInteger,\n  getIntegerOrUndefined,\n  getRawAuthorizationRules,\n  getString,\n  getStringOrUndefined,\n  getDate,\n  EntityStatus,\n  EntityAvailabilityStatus,\n} from \"../util/utils\";\n\n/**\n * @internal\n * Builds the queue options object from the user provided options.\n * Handles the differences in casing for the property names,\n * converts values to string and ensures the right order as expected by the service\n */\nexport function buildQueueOptions(queue: CreateQueueOptions): InternalQueueOptions {\n  return {\n    // NOTE: this ordering is extremely important. As an example, misordering of the ForwardTo property\n    // resulted in a customer bug where the Forwarding attributes appeared to be set but the portal was\n    // not picking up on it.\n    //\n    // The authority on this ordering is here:\n    // https://github.com/Azure/azure-sdk-for-net/blob/8af2dfc32c96ef3e340f9d20013bf588d97ea756/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/QueuePropertiesExtensions.cs#L20\n\n    LockDuration: queue.lockDuration,\n    MaxSizeInMegabytes: getStringOrUndefined(queue.maxSizeInMegabytes),\n    RequiresDuplicateDetection: getStringOrUndefined(queue.requiresDuplicateDetection),\n    RequiresSession: getStringOrUndefined(queue.requiresSession),\n    DefaultMessageTimeToLive: queue.defaultMessageTimeToLive,\n    DeadLetteringOnMessageExpiration: getStringOrUndefined(queue.deadLetteringOnMessageExpiration),\n    DuplicateDetectionHistoryTimeWindow: queue.duplicateDetectionHistoryTimeWindow,\n    MaxDeliveryCount: getStringOrUndefined(queue.maxDeliveryCount),\n    EnableBatchedOperations: getStringOrUndefined(queue.enableBatchedOperations),\n    AuthorizationRules: getRawAuthorizationRules(queue.authorizationRules),\n    Status: getStringOrUndefined(queue.status),\n    ForwardTo: getStringOrUndefined(queue.forwardTo),\n    UserMetadata: getStringOrUndefined(queue.userMetadata),\n    AutoDeleteOnIdle: getStringOrUndefined(queue.autoDeleteOnIdle),\n    EnablePartitioning: getStringOrUndefined(queue.enablePartitioning),\n    ForwardDeadLetteredMessagesTo: getStringOrUndefined(queue.forwardDeadLetteredMessagesTo),\n    EntityAvailabilityStatus: getStringOrUndefined(queue.availabilityStatus),\n    EnableExpress: getStringOrUndefined(queue.enableExpress),\n    MaxMessageSizeInKilobytes: getStringOrUndefined(queue.maxMessageSizeInKilobytes),\n  };\n}\n\n/**\n * @internal\n * Builds the queue object from the raw json object gotten after deserializing the\n * response from the service\n */\nexport function buildQueue(rawQueue: Record<string, any>): QueueProperties {\n  return {\n    name: getString(rawQueue[Constants.QUEUE_NAME], \"queueName\"),\n\n    forwardTo: getStringOrUndefined(rawQueue[Constants.FORWARD_TO]),\n    userMetadata: rawQueue[Constants.USER_METADATA],\n\n    lockDuration: getString(rawQueue[Constants.LOCK_DURATION], \"lockDuration\"),\n    maxSizeInMegabytes: getInteger(rawQueue[Constants.MAX_SIZE_IN_MEGABYTES], \"maxSizeInMegabytes\"),\n\n    maxDeliveryCount: getInteger(rawQueue[Constants.MAX_DELIVERY_COUNT], \"maxDeliveryCount\"),\n\n    enablePartitioning: getBoolean(rawQueue[Constants.ENABLE_PARTITIONING], \"enablePartitioning\"),\n    requiresSession: getBoolean(rawQueue[Constants.REQUIRES_SESSION], \"requiresSession\"),\n    enableBatchedOperations: getBoolean(\n      rawQueue[Constants.ENABLE_BATCHED_OPERATIONS],\n      \"enableBatchedOperations\",\n    ),\n\n    defaultMessageTimeToLive: getString(\n      rawQueue[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE],\n      \"defaultMessageTimeToLive\",\n    ),\n    autoDeleteOnIdle: rawQueue[Constants.AUTO_DELETE_ON_IDLE],\n\n    requiresDuplicateDetection: getBoolean(\n      rawQueue[Constants.REQUIRES_DUPLICATE_DETECTION],\n      \"requiresDuplicateDetection\",\n    ),\n    duplicateDetectionHistoryTimeWindow: getString(\n      rawQueue[Constants.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW],\n      \"duplicateDetectionHistoryTimeWindow\",\n    ),\n    deadLetteringOnMessageExpiration: getBoolean(\n      rawQueue[Constants.DEAD_LETTERING_ON_MESSAGE_EXPIRATION],\n      \"deadLetteringOnMessageExpiration\",\n    ),\n    forwardDeadLetteredMessagesTo: getStringOrUndefined(\n      rawQueue[Constants.FORWARD_DEADLETTERED_MESSAGES_TO],\n    ),\n\n    authorizationRules: getAuthorizationRulesOrUndefined(rawQueue[Constants.AUTHORIZATION_RULES]),\n\n    status: rawQueue[Constants.STATUS],\n\n    enableExpress: getBoolean(rawQueue[Constants.ENABLE_EXPRESS], \"enableExpress\"),\n\n    availabilityStatus: rawQueue[Constants.ENTITY_AVAILABILITY_STATUS],\n\n    maxMessageSizeInKilobytes: getIntegerOrUndefined(\n      rawQueue[Constants.MAX_MESSAGE_SIZE_IN_KILOBYTES],\n    ),\n  };\n}\n\n/**\n * @internal\n * Builds the queue runtime info object from the raw json object gotten after deserializing the\n * response from the service\n */\nexport function buildQueueRuntimeProperties(rawQueue: Record<string, any>): QueueRuntimeProperties {\n  const messageCountDetails = getMessageCountDetails(rawQueue[Constants.COUNT_DETAILS]);\n  return {\n    name: getString(rawQueue[Constants.QUEUE_NAME], \"queueName\"),\n    sizeInBytes: getIntegerOrUndefined(rawQueue[Constants.SIZE_IN_BYTES]),\n    totalMessageCount: getIntegerOrUndefined(rawQueue[Constants.MESSAGE_COUNT]),\n    ...messageCountDetails,\n    createdAt: getDate(rawQueue[Constants.CREATED_AT], \"createdAt\"),\n    modifiedAt: getDate(rawQueue[Constants.UPDATED_AT], \"modifiedAt\"),\n    accessedAt: getDate(rawQueue[Constants.ACCESSED_AT], \"accessedAt\"),\n  };\n}\n\n/**\n * Represents settable options on a queue\n */\nexport interface CreateQueueOptions extends OperationOptions {\n  /**\n   * Determines the amount of time in seconds in which a message should be locked for\n   * processing by a receiver. After this period, the message is unlocked and available\n   * for consumption by the next receiver.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  lockDuration?: string;\n\n  /**\n   * Specifies the maximum queue size in megabytes. Any attempt to enqueue a message that\n   * will cause the queue to exceed this value will fail.\n   */\n  maxSizeInMegabytes?: number;\n\n  /**\n   * The maximum message size in kilobytes for messages sent to this queue.\n   *\n   * (Configurable only for Premium Tier Service Bus namespace.)\n   */\n  maxMessageSizeInKilobytes?: number;\n\n  /**\n   * If enabled, the topic will detect duplicate messages within the time\n   * span specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at queue creation time.\n   */\n  requiresDuplicateDetection?: boolean;\n\n  /**\n   * If set to true, the queue will be session-aware and only SessionReceiver\n   * will be supported. Session-aware queues are not supported through REST.\n   * Settable only at queue creation time.\n   */\n  requiresSession?: boolean;\n\n  /**\n   * Depending on whether DeadLettering is enabled, a message is automatically\n   * moved to the dead-letter sub-queue or deleted if it has been stored in the\n   * queue for longer than the specified time.\n   * This value is overwritten by a TTL specified on the message\n   * if and only if the message TTL is smaller than the TTL set on the queue.\n   * This value is immutable after the Queue has been created.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive?: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message\n   * from the queue into the queues dead-letter sub-queue. If disabled,\n   * message will be permanently deleted from the queue.\n   * Settable only at queue creation time.\n   */\n  deadLetteringOnMessageExpiration?: boolean;\n\n  /**\n   * Specifies the time span during which the Service Bus detects message duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  duplicateDetectionHistoryTimeWindow?: string;\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   */\n  maxDeliveryCount?: number;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations?: boolean;\n\n  /**\n   * Authorization rules on the queue\n   */\n  authorizationRules?: AuthorizationRule[];\n\n  /**\n   * Status of the messaging entity.\n   */\n  status?: EntityStatus;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the queue.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle?: string;\n\n  /**\n   * Specifies whether the queue should be partitioned.\n   */\n  enablePartitioning?: boolean;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Specifies whether express entities are enabled on queue.\n   */\n  enableExpress?: boolean;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  availabilityStatus?: EntityAvailabilityStatus;\n}\n\n/**\n * Represents the input for updateQueue.\n *\n */\nexport interface QueueProperties {\n  /**\n   * Name of the queue\n   */\n  readonly name: string;\n\n  /**\n   * Determines the amount of time in seconds in which a message should be locked for\n   * processing by a receiver. After this period, the message is unlocked and available\n   * for consumption by the next receiver.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  lockDuration: string;\n\n  /**\n   * Specifies the maximum queue size in megabytes. Any attempt to enqueue a message that\n   * will cause the queue to exceed this value will fail.\n   */\n  maxSizeInMegabytes: number;\n\n  /**\n   * The maximum message size in kilobytes for messages sent to this queue.\n   *\n   * Not applicable if service version \"2017-04\" is chosen when creating the `ServiceBusAdministrationClient`.\n   */\n  maxMessageSizeInKilobytes?: number;\n\n  /**\n   * If enabled, the topic will detect duplicate messages within the time\n   * span specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at queue creation time.\n   */\n  readonly requiresDuplicateDetection: boolean;\n\n  /**\n   * If set to true, the queue will be session-aware and only SessionReceiver\n   * will be supported. Session-aware queues are not supported through REST.\n   * Settable only at queue creation time.\n   */\n  readonly requiresSession: boolean;\n\n  /**\n   * Depending on whether DeadLettering is enabled, a message is automatically\n   * moved to the dead-letter sub-queue or deleted if it has been stored in the\n   * queue for longer than the specified time.\n   * This value is overwritten by a TTL specified on the message\n   * if and only if the message TTL is smaller than the TTL set on the queue.\n   * This value is immutable after the Queue has been created.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message\n   * from the queue into the queues dead-letter sub-queue. If disabled,\n   * message will be permanently deleted from the queue.\n   * Settable only at queue creation time.\n   */\n  deadLetteringOnMessageExpiration: boolean;\n\n  /**\n   * Specifies the time span during which the Service Bus detects message duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  duplicateDetectionHistoryTimeWindow: string;\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   */\n  maxDeliveryCount: number;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations: boolean;\n\n  /**\n   * Authorization rules on the queue\n   */\n  authorizationRules?: AuthorizationRule[];\n\n  /**\n   * Status of the messaging entity.\n   */\n  status: EntityStatus;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the queue.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle: string;\n\n  /**\n   * Specifies whether the queue should be partitioned.\n   */\n  readonly enablePartitioning: boolean;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Specifies whether express entities are enabled on queue.\n   */\n  readonly enableExpress: boolean;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  readonly availabilityStatus: EntityAvailabilityStatus;\n}\n/**\n * @internal\n * Internal representation of settable options on a queue\n */\nexport interface InternalQueueOptions {\n  /**\n   * Determines the amount of time in seconds in which a message should be locked for\n   * processing by a receiver. After this period, the message is unlocked and\n   * can be consumed by the next receiver.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  LockDuration?: string;\n\n  /**\n   * The max size in MegaBytes\n   *\n   */\n  MaxSizeInMegabytes?: string;\n\n  /**\n   * The maximum message size in kilobytes for messages sent to this queue/topic.\n   */\n  MaxMessageSizeInKilobytes?: string;\n\n  /**\n   *  If enabled, the topic will detect duplicate messages within the time\n   * span specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at queue creation time.\n   */\n  RequiresDuplicateDetection?: string;\n\n  /**\n   * If set to true, the queue will be session-aware and only SessionReceiver\n   * will be supported. Session-aware queues are not supported through REST.\n   * Settable only at queue creation time.\n   */\n  RequiresSession?: string;\n\n  /**\n   * Depending on whether DeadLettering is enabled, a message is automatically moved to\n   * the DeadLetterQueue or deleted if it has been stored in the queue for longer than\n   * the specified time. This value is overwritten by a TTL specified on the message\n   * if and only if the message TTL is smaller than the TTL set on the queue.\n   * This value is immutable after the Queue has been created.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  DefaultMessageTimeToLive?: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message\n   * from the queue into the queues dead-letter sub-queue. If disabled,\n   * message will be permanently deleted from the queue.\n   * Settable only at queue creation time.\n   */\n  DeadLetteringOnMessageExpiration?: string;\n\n  /**\n   * Specifies the time span during which the Service Bus detects message duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  DuplicateDetectionHistoryTimeWindow?: string;\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   *\n   */\n  MaxDeliveryCount?: string;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  EnableBatchedOperations?: string;\n\n  /**\n   * Authorization rules on the queue\n   */\n  AuthorizationRules?: any;\n\n  /**\n   * Status of the messaging entity.\n   */\n  Status?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  ForwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the queue.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  UserMetadata?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  AutoDeleteOnIdle?: string;\n\n  /**\n   * Specifies whether the queue should be partitioned.\n   */\n  EnablePartitioning?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  ForwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Specifies whether express entities are enabled on queue.\n   */\n  EnableExpress?: string;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  EntityAvailabilityStatus?: string;\n}\n\n/**\n * Represents runtime info attributes of a queue entity\n */\nexport interface QueueRuntimeProperties {\n  /**\n   * Name of the queue\n   */\n  name: string;\n\n  /**\n   * Created at timestamp\n   */\n  createdAt: Date;\n\n  /**\n   * Updated at timestamp\n   */\n  modifiedAt: Date;\n\n  /**\n   * Accessed at timestamp\n   */\n  accessedAt: Date;\n\n  /**\n   * The entity's message count.\n   *\n   */\n  totalMessageCount?: number;\n\n  /**\n   * The number of active messages in the queue.\n   */\n  activeMessageCount: number;\n\n  /**\n   * The number of messages that have been dead lettered.\n   */\n  deadLetterMessageCount: number;\n\n  /**\n   * The number of scheduled messages.\n   */\n  scheduledMessageCount: number;\n\n  /**\n   * The number of messages transferred to another queue, topic, or subscription\n   */\n  transferMessageCount: number;\n\n  /**\n   * The number of messages transferred to the dead letter queue.\n   */\n  transferDeadLetterMessageCount: number;\n\n  /**\n   * The entity's size in bytes.\n   *\n   */\n  sizeInBytes?: number;\n}\n\n/**\n * @internal\n * Atom XML Serializer for Queues.\n */\nexport class QueueResourceSerializer implements AtomXmlSerializer {\n  serialize(resource: InternalQueueOptions): Record<string, unknown> {\n    return serializeToAtomXmlRequest(\"QueueDescription\", resource);\n  }\n\n  async deserialize(response: FullOperationResponse): Promise<FullOperationResponse> {\n    return deserializeAtomXmlResponse([\"QueueName\"], response);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { FullOperationResponse } from \"@azure/core-client\";\nimport { CorrelationRuleFilter } from \"../core/managementClient\";\nimport {\n  AtomXmlSerializer,\n  deserializeAtomXmlResponse,\n  serializeToAtomXmlRequest,\n} from \"../util/atomXmlHelper\";\nimport * as Constants from \"../util/constants\";\nimport { isDefined, isObjectWithProperties } from \"@azure/core-util\";\nimport { getString, getStringOrUndefined } from \"../util/utils\";\n\n/**\n * @internal\n * Builds the rule object from the raw json object gotten after deserializing the\n * response from the service\n */\nexport function buildRule(rawRule: Record<string, any>): RuleProperties {\n  return {\n    name: getString(rawRule[\"RuleName\"], \"ruleName\"),\n    filter: getTopicFilter(rawRule[\"Filter\"]),\n    action: getRuleAction(rawRule[\"Action\"]),\n  };\n}\n\n/**\n * @internal\n * Helper utility to retrieve `filter` value from given input,\n * or undefined if not passed in.\n */\nfunction getTopicFilter(value: any): SqlRuleFilter | CorrelationRuleFilter {\n  let result: SqlRuleFilter | CorrelationRuleFilter;\n\n  if (isDefined(value[\"SqlExpression\"])) {\n    result = {\n      sqlExpression: value[\"SqlExpression\"],\n      sqlParameters: getKeyValuePairsOrUndefined(value[\"Parameters\"], \"SQLParameters\"),\n    };\n  } else {\n    result = {\n      correlationId: getStringOrUndefined(value[\"CorrelationId\"]),\n      subject: getStringOrUndefined(value[\"Label\"]),\n      to: getStringOrUndefined(value[\"To\"]),\n      replyTo: getStringOrUndefined(value[\"ReplyTo\"]),\n      replyToSessionId: getStringOrUndefined(value[\"ReplyToSessionId\"]),\n      sessionId: getStringOrUndefined(value[\"SessionId\"]),\n      messageId: getStringOrUndefined(value[\"MessageId\"]),\n      contentType: getStringOrUndefined(value[\"ContentType\"]),\n      applicationProperties: getKeyValuePairsOrUndefined(\n        value[\"Properties\"],\n        \"ApplicationProperties\",\n      ),\n    };\n  }\n  return result;\n}\n\n/**\n * @internal\n * Helper utility to retrieve rule `action` value from given input.\n */\nfunction getRuleAction(value: any): SqlRuleAction {\n  return {\n    sqlExpression: value[\"SqlExpression\"],\n    sqlParameters: getKeyValuePairsOrUndefined(value[\"Parameters\"], \"SQLParameters\"),\n  };\n}\n\n/**\n * Represents the options to create a rule for a subscription.\n * @internal\n */\nexport interface CreateRuleOptions {\n  /**\n   * Name of the rule\n   */\n  name: string;\n\n  /**\n   * Defines the filter expression that the rule evaluates. For `SqlRuleFilter` input,\n   * the expression string is interpreted as a SQL92 expression which must\n   * evaluate to True or False. Only one between a `CorrelationRuleFilter` or\n   * a `SqlRuleFilter` can be defined.\n   */\n  filter?: SqlRuleFilter | CorrelationRuleFilter;\n\n  /**\n   * The SQL like expression that can be executed on the message should the\n   * associated filter apply.\n   */\n  action?: SqlRuleAction;\n}\n\n/**\n * Represents all the attributes of a rule.\n */\nexport interface RuleProperties {\n  /**\n   * Name of the rule\n   */\n  readonly name: string;\n\n  /**\n   * Defines the filter expression that the rule evaluates. For `SqlRuleFilter` input,\n   * the expression string is interpreted as a SQL92 expression which must\n   * evaluate to True or False. Only one between a `CorrelationRuleFilter` or\n   * a `SqlRuleFilter` can be defined.\n   */\n  filter: SqlRuleFilter | CorrelationRuleFilter;\n\n  /**\n   * The SQL like expression that can be executed on the message should the\n   * associated filter apply.\n   */\n  action: SqlRuleAction;\n}\n\n/**\n * Represents all possible fields on SqlRuleAction\n */\nexport type SqlRuleAction = {\n  /**\n   * SQL expression to use in the rule action.\n   */\n  sqlExpression?: string;\n\n  /**\n   * SQL parameters to the SQL expression in the rule action.\n   */\n  sqlParameters?: { [key: string]: string | number | boolean };\n};\n\n/**\n * Represents all possible fields on SqlRuleFilter\n */\nexport interface SqlRuleFilter {\n  /**\n   * SQL expression to use in the rule filter. It is evaluated against the messages'\n   * user-defined properties and system properties. All system properties will be prefixed with\n   * `sys.` in the condition expression.\n   * Defaults to creating a true filter if none specified\n   */\n  sqlExpression: string;\n\n  /**\n   * SQL parameters to the SQL expression in the rule filter.\n   */\n  sqlParameters?: { [key: string]: string | number | boolean };\n}\n\n/**\n * @internal\n *\n */\nexport interface InternalRuleOptions {\n  Name: string;\n  Filter: any;\n  Action: any;\n}\n\n/**\n * @internal\n *\n */\nexport function buildInternalRuleResource(rule: CreateRuleOptions): InternalRuleOptions {\n  const resource: InternalRuleOptions = {\n    Filter: {},\n    Action: {},\n    Name: rule.name,\n  };\n\n  if (!isDefined(rule.filter)) {\n    // Defaults to creating a true filter if none specified\n    resource.Filter = {\n      SqlExpression: \"1=1\",\n    };\n    resource.Filter[Constants.XML_METADATA_MARKER] = {\n      \"p4:type\": \"SqlFilter\",\n      \"xmlns:p4\": \"http://www.w3.org/2001/XMLSchema-instance\",\n    };\n  } else {\n    if (isObjectWithProperties(rule.filter, [\"sqlExpression\"])) {\n      const sqlFilter: SqlRuleFilter = rule.filter as SqlRuleFilter;\n      resource.Filter = {\n        SqlExpression: sqlFilter.sqlExpression,\n        Parameters: buildInternalRawKeyValuePairs(sqlFilter.sqlParameters, \"sqlParameters\"),\n      };\n      resource.Filter[Constants.XML_METADATA_MARKER] = {\n        \"p4:type\": \"SqlFilter\",\n        \"xmlns:p4\": \"http://www.w3.org/2001/XMLSchema-instance\",\n      };\n    } else {\n      const correlationFilter: CorrelationRuleFilter = rule.filter as CorrelationRuleFilter;\n\n      resource.Filter = {\n        CorrelationId: correlationFilter.correlationId,\n        Label: correlationFilter.subject,\n        To: correlationFilter.to,\n        ReplyTo: correlationFilter.replyTo,\n        ReplyToSessionId: correlationFilter.replyToSessionId,\n        ContentType: correlationFilter.contentType,\n        SessionId: correlationFilter.sessionId,\n        MessageId: correlationFilter.messageId,\n        Properties: buildInternalRawKeyValuePairs(\n          correlationFilter.applicationProperties,\n          \"applicationProperties\",\n        ),\n      };\n      resource.Filter[Constants.XML_METADATA_MARKER] = {\n        \"p4:type\": \"CorrelationFilter\",\n        \"xmlns:p4\": \"http://www.w3.org/2001/XMLSchema-instance\",\n      };\n    }\n  }\n\n  if (!isDefined(rule.action) || !isDefined(rule.action.sqlExpression)) {\n    // Defaults to creating an empty rule action instance if none specified\n    resource.Action = {};\n    resource.Action[Constants.XML_METADATA_MARKER] = {\n      \"p4:type\": \"EmptyRuleAction\",\n      \"xmlns:p4\": \"http://www.w3.org/2001/XMLSchema-instance\",\n    };\n  } else {\n    resource.Action = {\n      SqlExpression: rule.action.sqlExpression,\n      Parameters: buildInternalRawKeyValuePairs(rule.action.sqlParameters, \"sqlParameters\"),\n    };\n    resource.Action[Constants.XML_METADATA_MARKER] = {\n      \"p4:type\": \"SqlRuleAction\",\n      \"xmlns:p4\": \"http://www.w3.org/2001/XMLSchema-instance\",\n    };\n  }\n\n  return resource;\n}\n\n/**\n * @internal\n * RuleResourceSerializer for serializing / deserializing Rule entities\n */\nexport class RuleResourceSerializer implements AtomXmlSerializer {\n  serialize(rule: RuleProperties): Record<string, unknown> {\n    return serializeToAtomXmlRequest(\"RuleDescription\", buildInternalRuleResource(rule));\n  }\n\n  async deserialize(response: FullOperationResponse): Promise<FullOperationResponse> {\n    return deserializeAtomXmlResponse([\"TopicName\", \"SubscriptionName\", \"RuleName\"], response);\n  }\n}\n\n/**\n * @internal\n */\nexport function isSqlRuleAction(action: unknown): action is SqlRuleAction {\n  return isObjectWithProperties(action, [\"sqlExpression\"]);\n}\n\n/**\n * Service expects the XML request with the special type names serialized in the request,\n * the request would fail otherwise.\n *\n * @internal\n */\nenum TypeMapForRequestSerialization {\n  double = \"l28:double\",\n  string = \"l28:string\",\n  long = \"l28:long\",\n  date = \"l28:dateTime\",\n  boolean = \"l28:boolean\",\n}\n\n/**\n * @internal\n */\nenum TypeMapForResponseDeserialization {\n  int = \"int\",\n  double = \"double\",\n  string = \"string\",\n  boolean = \"boolean\",\n  date = \"dateTime\",\n}\n\n/**\n * @internal\n * Internal representation of key-value pair\n */\ntype RawKeyValuePair = {\n  Key: string;\n  Value: any;\n};\n\n/**\n * @internal\n */\ninterface InternalRawKeyValuePairs {\n  KeyValueOfstringanyType: RawKeyValuePair[];\n}\n\n/**\n * Key-value pairs are supposed to be wrapped with this tag in the XML request, they are ignored otherwise.\n *\n * @internal\n */\nconst keyValuePairXMLTag = \"KeyValueOfstringanyType\";\n\n/**\n * @internal\n * Helper utility to retrieve the key-value pairs from the RawKeyValue object from given input,\n * or undefined if not passed in.\n */\nfunction getKeyValuePairsOrUndefined(\n  value: any,\n  attribute: \"ApplicationProperties\" | \"SQLParameters\",\n): { [key: string]: any } | undefined {\n  if (!value) {\n    return undefined;\n  }\n  const properties: any = {};\n  let rawProperties;\n  if (!Array.isArray(value[keyValuePairXMLTag]) && value[keyValuePairXMLTag]?.Key) {\n    // When a single property is present,\n    //    value[\"KeyValueOfstringanyType\"] is { Key: <key>, Value: [Object] }\n    // When multiple properties are present,\n    //    value[\"KeyValueOfstringanyType\"] is [ { Key: <key-1>, Value: [Object] }, { Key: <key-2>, Value: [Object] } ]\n    // For consistency, wrapping `value[\"KeyValueOfstringanyType\"]` as an array for the \"single property\" case.\n    rawProperties = [value[keyValuePairXMLTag]];\n  } else {\n    rawProperties = value[keyValuePairXMLTag];\n  }\n  if (Array.isArray(rawProperties)) {\n    for (const rawProperty of rawProperties) {\n      const key = rawProperty.Key;\n      const _value = rawProperty.Value[\"_\"];\n      const encodedValueType = rawProperty.Value[\"$\"][\"i:type\"].toString().substring(5);\n      if (\n        encodedValueType === TypeMapForResponseDeserialization.int ||\n        encodedValueType === TypeMapForResponseDeserialization.double\n      ) {\n        properties[key] = Number(_value);\n      } else if (encodedValueType === TypeMapForResponseDeserialization.string) {\n        properties[key] = _value;\n      } else if (encodedValueType === TypeMapForResponseDeserialization.boolean) {\n        properties[key] = _value === \"true\" ? true : false;\n      } else if (encodedValueType === TypeMapForResponseDeserialization.date) {\n        properties[key] = new Date(_value);\n      } else {\n        throw new TypeError(\n          `Unable to parse the key-value pairs in the response - ${JSON.stringify(rawProperty)}`,\n        );\n      }\n    }\n  } else {\n    throw new TypeError(\n      `${attribute} in the response is not an array, unable to parse the response - ${JSON.stringify(\n        value,\n      )}`,\n    );\n  }\n  return properties;\n}\n\n/**\n * @internal\n * Helper utility to extract array of user properties key-value instances from given input,\n * or undefined if not passed in.\n */\nexport function buildInternalRawKeyValuePairs(\n  parameters: { [key: string]: any } | undefined,\n  attribute: \"applicationProperties\" | \"sqlParameters\",\n): InternalRawKeyValuePairs | undefined {\n  if (!isDefined(parameters)) {\n    return undefined;\n  }\n  if (\n    Array.isArray(parameters) ||\n    typeof parameters === \"string\" ||\n    typeof parameters !== \"object\" ||\n    Object.entries(parameters).length < 1\n  ) {\n    throw new TypeError(\n      `Unsupported value for the ${attribute} ${JSON.stringify(\n        parameters,\n      )}, expected a JSON object with key-value pairs.`,\n    );\n  }\n  const rawParameters: RawKeyValuePair[] = [];\n  for (const key of Object.keys(parameters)) {\n    let type: string | number | boolean;\n    let value = parameters[key];\n    if (typeof value === \"number\") {\n      type = TypeMapForRequestSerialization.double;\n    } else if (typeof value === \"string\") {\n      type = TypeMapForRequestSerialization.string;\n    } else if (typeof value === \"boolean\") {\n      type = TypeMapForRequestSerialization.boolean;\n    } else if (value instanceof Date && !isNaN(value.valueOf())) {\n      type = TypeMapForRequestSerialization.date;\n      value = value.toJSON();\n    } else {\n      throw new TypeError(\n        `Unsupported type for the value in the ${attribute} for the key '${key}'`,\n      );\n    }\n\n    const rawParameter: RawKeyValuePair = {\n      Key: key,\n      Value: {\n        [Constants.XML_METADATA_MARKER]: {\n          \"p4:type\": type,\n          \"xmlns:l28\": \"http://www.w3.org/2001/XMLSchema\",\n        },\n        [Constants.XML_VALUE_MARKER]: value,\n      },\n    };\n    rawParameters.push(rawParameter);\n  }\n  return {\n    [keyValuePairXMLTag]: rawParameters,\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { FullOperationResponse, OperationOptions } from \"@azure/core-client\";\nimport { CorrelationRuleFilter } from \"..\";\nimport {\n  AtomXmlSerializer,\n  deserializeAtomXmlResponse,\n  serializeToAtomXmlRequest,\n} from \"../util/atomXmlHelper\";\nimport * as Constants from \"../util/constants\";\nimport {\n  EntityStatus,\n  EntityAvailabilityStatus,\n  getBoolean,\n  getMessageCountDetails,\n  getInteger,\n  getString,\n  getStringOrUndefined,\n  getDate,\n} from \"../util/utils\";\nimport {\n  buildInternalRuleResource,\n  InternalRuleOptions,\n  SqlRuleAction,\n  SqlRuleFilter,\n} from \"./ruleResourceSerializer\";\n\n/**\n * @internal\n * Builds the subscription options object from the user provided options.\n * Handles the differences in casing for the property names,\n * converts values to string and ensures the right order as expected by the service\n */\nexport function buildSubscriptionOptions(\n  subscription: CreateSubscriptionOptions,\n): InternalSubscriptionOptions {\n  return {\n    // NOTE: this ordering is extremely important. As an example, misordering of the ForwardTo property\n    // resulted in a customer bug where the Forwarding attributes appeared to be set but the portal was\n    // not picking up on it.\n    //\n    // The authority on this ordering is here:\n    // https://github.com/Azure/azure-sdk-for-net/blob/8af2dfc32c96ef3e340f9d20013bf588d97ea756/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/SubscriptionPropertiesExtensions.cs#L191\n    LockDuration: subscription.lockDuration,\n    RequiresSession: getStringOrUndefined(subscription.requiresSession),\n    DefaultMessageTimeToLive: getStringOrUndefined(subscription.defaultMessageTimeToLive),\n    DeadLetteringOnMessageExpiration: getStringOrUndefined(\n      subscription.deadLetteringOnMessageExpiration,\n    ),\n    DeadLetteringOnFilterEvaluationExceptions: getStringOrUndefined(\n      subscription.deadLetteringOnFilterEvaluationExceptions,\n    ),\n    DefaultRuleDescription: subscription.defaultRuleOptions\n      ? buildInternalRuleResource(subscription.defaultRuleOptions)\n      : undefined,\n    MaxDeliveryCount: getStringOrUndefined(subscription.maxDeliveryCount),\n    EnableBatchedOperations: getStringOrUndefined(subscription.enableBatchedOperations),\n    Status: getStringOrUndefined(subscription.status),\n    ForwardTo: getStringOrUndefined(subscription.forwardTo),\n    UserMetadata: getStringOrUndefined(subscription.userMetadata),\n    ForwardDeadLetteredMessagesTo: getStringOrUndefined(subscription.forwardDeadLetteredMessagesTo),\n    AutoDeleteOnIdle: getStringOrUndefined(subscription.autoDeleteOnIdle),\n    EntityAvailabilityStatus: getStringOrUndefined(subscription.availabilityStatus),\n  };\n}\n\n/**\n * @internal\n * Builds the subscription object from the raw json object gotten after deserializing\n * the response from the service\n */\nexport function buildSubscription(rawSubscription: Record<string, any>): SubscriptionProperties {\n  return {\n    subscriptionName: getString(rawSubscription[Constants.SUBSCRIPTION_NAME], \"subscriptionName\"),\n    topicName: getString(rawSubscription[Constants.TOPIC_NAME], \"topicName\"),\n\n    lockDuration: getString(rawSubscription[Constants.LOCK_DURATION], \"lockDuration\"),\n    maxDeliveryCount: getInteger(rawSubscription[Constants.MAX_DELIVERY_COUNT], \"maxDeliveryCount\"),\n\n    requiresSession: getBoolean(rawSubscription[Constants.REQUIRES_SESSION], \"requiresSession\"),\n    enableBatchedOperations: getBoolean(\n      rawSubscription[Constants.ENABLE_BATCHED_OPERATIONS],\n      \"enableBatchedOperations\",\n    ),\n\n    defaultMessageTimeToLive: getString(\n      rawSubscription[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE],\n      \"defaultMessageTimeToLive\",\n    ),\n    autoDeleteOnIdle: getString(rawSubscription[Constants.AUTO_DELETE_ON_IDLE], \"autoDeleteOnIdle\"),\n\n    deadLetteringOnMessageExpiration: getBoolean(\n      rawSubscription[Constants.DEAD_LETTERING_ON_MESSAGE_EXPIRATION],\n      \"deadLetteringOnMessageExpiration\",\n    ),\n    deadLetteringOnFilterEvaluationExceptions: getBoolean(\n      rawSubscription[Constants.DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS],\n      \"deadLetteringOnFilterEvaluationExceptions\",\n    ),\n    forwardDeadLetteredMessagesTo: getStringOrUndefined(\n      rawSubscription[Constants.FORWARD_DEADLETTERED_MESSAGES_TO],\n    ),\n\n    forwardTo: getStringOrUndefined(rawSubscription[Constants.FORWARD_TO]),\n    userMetadata: rawSubscription[Constants.USER_METADATA],\n\n    status: getString(rawSubscription[Constants.STATUS], \"status\") as EntityStatus,\n\n    availabilityStatus: getString(\n      rawSubscription[Constants.ENTITY_AVAILABILITY_STATUS],\n      \"availabilityStatus\",\n    ) as EntityAvailabilityStatus,\n  };\n}\n\n/**\n * @internal\n * Builds the subscription runtime info object from the raw json object gotten after deserializing\n * the response from the service\n */\nexport function buildSubscriptionRuntimeProperties(\n  rawSubscription: Record<string, any>,\n): SubscriptionRuntimeProperties {\n  const messageCountDetails = getMessageCountDetails(rawSubscription[Constants.COUNT_DETAILS]);\n  return {\n    subscriptionName: getString(rawSubscription[Constants.SUBSCRIPTION_NAME], \"subscriptionName\"),\n    topicName: getString(rawSubscription[Constants.TOPIC_NAME], \"topicName\"),\n    totalMessageCount: getInteger(rawSubscription[Constants.MESSAGE_COUNT], \"messageCount\"),\n    activeMessageCount: messageCountDetails.activeMessageCount,\n    deadLetterMessageCount: messageCountDetails.deadLetterMessageCount,\n    transferDeadLetterMessageCount: messageCountDetails.transferDeadLetterMessageCount,\n    transferMessageCount: messageCountDetails.transferMessageCount,\n    createdAt: getDate(rawSubscription[Constants.CREATED_AT], \"createdAt\"),\n    modifiedAt: getDate(rawSubscription[Constants.UPDATED_AT], \"modifiedAt\"),\n    accessedAt: getDate(rawSubscription[Constants.ACCESSED_AT], \"accessedAt\"),\n  };\n}\n\n/**\n * Represents settable options on a subscription\n */\nexport interface CreateSubscriptionOptions extends OperationOptions {\n  /**\n   * The default lock duration is applied to subscriptions that do not define a lock\n   * duration.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  lockDuration?: string;\n\n  /**\n   * If set to true, the subscription will be session-aware and only SessionReceiver\n   * will be supported. Session-aware subscription are not supported through REST.\n   * Settable only at subscription creation time.\n   */\n  requiresSession?: boolean;\n\n  /**\n   * Determines how long a message lives in the subscription. Based on whether\n   * dead-lettering is enabled, a message whose TTL has expired will either be moved\n   * to the subscriptions associated DeadLtterQueue or permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive?: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message from\n   * the queue into the subscriptions dead-letter sub-queue. If disabled, message\n   * will be permanently deleted from the subscriptions main queue.\n   * Settable only at subscription creation time.\n   */\n  deadLetteringOnMessageExpiration?: boolean;\n\n  /**\n   * Determines how the Service Bus handles a message that causes an exception during\n   * a subscriptions filter evaluation. If the value is set to true, the message that\n   * caused the exception will be moved to the subscriptions dead-letter sub-queue.\n   * Otherwise, it will be discarded. By default this parameter is set to true,\n   * allowing the user a chance to investigate the cause of the exception.\n   * It can occur from a malformed message or some incorrect assumptions being made\n   * in the filter about the form of the message. Settable only at topic creation time.\n   */\n  deadLetteringOnFilterEvaluationExceptions?: boolean;\n\n  /**\n   * Represents the options to create the default rule for the subscription.\n   */\n  defaultRuleOptions?: {\n    /**\n     * Name of the rule\n     */\n    name: string;\n\n    /**\n     * Defines the filter expression that the rule evaluates. For `SqlRuleFilter` input,\n     * the expression string is interpreted as a SQL92 expression which must\n     * evaluate to True or False. Only one between a `CorrelationRuleFilter` or\n     * a `SqlRuleFilter` can be defined.\n     */\n    filter?: SqlRuleFilter | CorrelationRuleFilter;\n\n    /**\n     * The SQL like expression that can be executed on the message should the\n     * associated filter apply.\n     */\n    action?: SqlRuleAction;\n  };\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   *\n   */\n  maxDeliveryCount?: number;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations?: boolean;\n\n  /**\n   * Status of the messaging entity.\n   */\n  status?: EntityStatus;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the subscription.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle?: string;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  availabilityStatus?: EntityAvailabilityStatus;\n}\n\n/**\n * Represents the input for updateSubscription.\n *\n */\nexport interface SubscriptionProperties {\n  /**\n   * Name of the subscription\n   */\n  readonly subscriptionName: string;\n\n  /**\n   * Name of the topic\n   */\n  readonly topicName: string;\n\n  /**\n   * The default lock duration is applied to subscriptions that do not define a lock\n   * duration.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  lockDuration: string;\n\n  /**\n   * If set to true, the subscription will be session-aware and only SessionReceiver\n   * will be supported. Session-aware subscription are not supported through REST.\n   * Settable only at subscription creation time.\n   */\n  readonly requiresSession: boolean;\n\n  /**\n   * Determines how long a message lives in the subscription. Based on whether\n   * dead-lettering is enabled, a message whose TTL has expired will either be moved\n   * to the subscriptions associated DeadLtterQueue or permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message from\n   * the queue into the subscriptions dead-letter sub-queue. If disabled, message\n   * will be permanently deleted from the subscriptions main queue.\n   * Settable only at subscription creation time.\n   */\n  deadLetteringOnMessageExpiration: boolean;\n\n  /**\n   * Determines how the Service Bus handles a message that causes an exception during\n   * a subscriptions filter evaluation. If the value is set to true, the message that\n   * caused the exception will be moved to the subscriptions dead-letter sub-queue.\n   * Otherwise, it will be discarded. By default this parameter is set to true,\n   * allowing the user a chance to investigate the cause of the exception.\n   * It can occur from a malformed message or some incorrect assumptions being made\n   * in the filter about the form of the message. Settable only at topic creation time.\n   */\n  deadLetteringOnFilterEvaluationExceptions: boolean;\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   *\n   */\n  maxDeliveryCount: number;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations: boolean;\n\n  /**\n   * Status of the messaging entity.\n   */\n  status: EntityStatus;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the subscription.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  forwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle: string;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  availabilityStatus?: EntityAvailabilityStatus;\n}\n\n/**\n * @internal\n * Internal representation of settable options on a subscription\n */\nexport interface InternalSubscriptionOptions {\n  /**\n   * The default lock duration is applied to subscriptions that do not define a lock\n   * duration.\n   * (If sessions are enabled, this lock duration is applicable for sessions and not for messages.)\n   *\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  LockDuration?: string;\n\n  /**\n   * If set to true, the subscription will be session-aware and only SessionReceiver\n   * will be supported. Session-aware subscription are not supported through REST.\n   * Settable only at subscription creation time.\n   */\n  RequiresSession?: string;\n\n  /**\n   * Determines how long a message lives in the subscription. Based on whether\n   * dead-lettering is enabled, a message whose TTL has expired will either be moved\n   * to the subscriptions associated DeadLtterQueue or permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  DefaultMessageTimeToLive?: string;\n\n  /**\n   * If it is enabled and a message expires, the Service Bus moves the message from\n   * the queue into the subscriptions dead-letter sub-queue. If disabled, message\n   * will be permanently deleted from the subscriptions main queue.\n   * Settable only at subscription creation time.\n   */\n  DeadLetteringOnMessageExpiration?: string;\n\n  /**\n   * Determines how the Service Bus handles a message that causes an exception during\n   * a subscriptions filter evaluation. If the value is set to true, the message\n   * that caused the exception will be moved to the subscriptions dead-letter sub-queue.\n   * Otherwise, it will be discarded. By default this parameter is set to true, allowing\n   * the user a chance to investigate the cause of the exception. It can occur from a\n   * malformed message or some incorrect assumptions being made in the filter about the\n   * form of the message. Settable only at topic creation time.\n   */\n  DeadLetteringOnFilterEvaluationExceptions?: string;\n\n  /**\n   * The maximum delivery count of messages after which if it is still not settled,\n   * gets moved to the dead-letter sub-queue.\n   *\n   */\n  MaxDeliveryCount?: string;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  EnableBatchedOperations?: string;\n\n  /**\n   * Status of the messaging entity.\n   */\n  Status?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  ForwardTo?: string;\n\n  /**\n   * The user provided metadata information associated with the subscription.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  UserMetadata?: string;\n\n  /**\n   * Absolute URL or the name of the queue or topic the dead-lettered\n   * messages are to be forwarded to.\n   * For example, an absolute URL input would be of the form\n   * `sb://<your-service-bus-namespace-endpoint>/<queue-or-topic-name>`\n   */\n  ForwardDeadLetteredMessagesTo?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  AutoDeleteOnIdle?: string;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  EntityAvailabilityStatus?: string;\n\n  DefaultRuleDescription?: InternalRuleOptions;\n}\n\n/**\n * Represents runtime info attributes of a subscription entity\n */\nexport interface SubscriptionRuntimeProperties {\n  /**\n   * Name of the subscription\n   */\n  subscriptionName: string;\n\n  /**\n   * Name of the topic\n   */\n  topicName: string;\n\n  /**\n   * The entity's message count.\n   *\n   */\n  totalMessageCount: number;\n\n  /**\n   * The number of active messages in the queue.\n   */\n  activeMessageCount: number;\n\n  /**\n   * The number of messages that have been dead lettered.\n   */\n  deadLetterMessageCount: number;\n\n  /**\n   * The number of messages transferred to another queue, topic, or subscription\n   */\n  transferMessageCount: number;\n\n  /**\n   * The number of messages transferred to the dead letter queue.\n   */\n  transferDeadLetterMessageCount: number;\n\n  /**\n   * Created at timestamp\n   */\n  createdAt: Date;\n\n  /**\n   * Updated at timestamp\n   */\n  modifiedAt: Date;\n\n  /**\n   * Accessed at timestamp\n   */\n  accessedAt: Date;\n}\n\n/**\n * @internal\n * SubscriptionResourceSerializer for serializing / deserializing Subscription entities\n */\nexport class SubscriptionResourceSerializer implements AtomXmlSerializer {\n  serialize(resource: InternalSubscriptionOptions): Record<string, unknown> {\n    return serializeToAtomXmlRequest(\"SubscriptionDescription\", resource);\n  }\n\n  async deserialize(response: FullOperationResponse): Promise<FullOperationResponse> {\n    return deserializeAtomXmlResponse([\"TopicName\", \"SubscriptionName\"], response);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { FullOperationResponse, OperationOptions } from \"@azure/core-client\";\nimport {\n  AtomXmlSerializer,\n  deserializeAtomXmlResponse,\n  serializeToAtomXmlRequest,\n} from \"../util/atomXmlHelper\";\nimport * as Constants from \"../util/constants\";\nimport {\n  AuthorizationRule,\n  EntityStatus,\n  EntityAvailabilityStatus,\n  getAuthorizationRulesOrUndefined,\n  getBoolean,\n  getInteger,\n  getIntegerOrUndefined,\n  getRawAuthorizationRules,\n  getString,\n  getStringOrUndefined,\n  getDate,\n  getMessageCountDetails,\n} from \"../util/utils\";\n\n/**\n * @internal\n * Builds the topic options object from the user provided options.\n * Handles the differences in casing for the property names,\n * converts values to string and ensures the right order as expected by the service\n */\nexport function buildTopicOptions(topic: CreateTopicOptions): InternalTopicOptions {\n  return {\n    // NOTE: this ordering is extremely important. As an example, misordering of the ForwardTo property\n    // resulted in a customer bug where the Forwarding attributes appeared to be set but the portal was\n    // not picking up on it.\n    //\n    // The authority on this ordering is here:\n    // https://github.com/Azure/azure-sdk-for-net/blob/8af2dfc32c96ef3e340f9d20013bf588d97ea756/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/TopicPropertiesExtensions.cs#L175\n\n    DefaultMessageTimeToLive: topic.defaultMessageTimeToLive,\n    MaxSizeInMegabytes: getStringOrUndefined(topic.maxSizeInMegabytes),\n    RequiresDuplicateDetection: getStringOrUndefined(topic.requiresDuplicateDetection),\n    DuplicateDetectionHistoryTimeWindow: topic.duplicateDetectionHistoryTimeWindow,\n    EnableBatchedOperations: getStringOrUndefined(topic.enableBatchedOperations),\n    AuthorizationRules: getRawAuthorizationRules(topic.authorizationRules),\n    Status: getStringOrUndefined(topic.status),\n    UserMetadata: getStringOrUndefined(topic.userMetadata),\n    SupportOrdering: getStringOrUndefined(topic.supportOrdering),\n    AutoDeleteOnIdle: getStringOrUndefined(topic.autoDeleteOnIdle),\n    EnablePartitioning: getStringOrUndefined(topic.enablePartitioning),\n    EntityAvailabilityStatus: getStringOrUndefined(topic.availabilityStatus),\n    EnableExpress: getStringOrUndefined(topic.enableExpress),\n    MaxMessageSizeInKilobytes: getStringOrUndefined(topic.maxMessageSizeInKilobytes),\n  };\n}\n\n/**\n * @internal\n * Builds the topic object from the raw json object gotten after deserializing the\n * response from the service\n */\nexport function buildTopic(rawTopic: Record<string, any>): TopicProperties {\n  return {\n    name: getString(rawTopic[Constants.TOPIC_NAME], \"topicName\"),\n    maxSizeInMegabytes: getInteger(rawTopic[Constants.MAX_SIZE_IN_MEGABYTES], \"maxSizeInMegabytes\"),\n\n    enablePartitioning: getBoolean(rawTopic[Constants.ENABLE_PARTITIONING], \"enablePartitioning\"),\n    supportOrdering: getBoolean(rawTopic[Constants.SUPPORT_ORDERING], \"supportOrdering\"),\n    enableBatchedOperations: getBoolean(\n      rawTopic[Constants.ENABLE_BATCHED_OPERATIONS],\n      \"enableBatchedOperations\",\n    ),\n\n    defaultMessageTimeToLive: getString(\n      rawTopic[Constants.DEFAULT_MESSAGE_TIME_TO_LIVE],\n      \"defaultMessageTimeToLive\",\n    ),\n    autoDeleteOnIdle: rawTopic[Constants.AUTO_DELETE_ON_IDLE],\n\n    requiresDuplicateDetection: getBoolean(\n      rawTopic[Constants.REQUIRES_DUPLICATE_DETECTION],\n      \"requiresDuplicateDetection\",\n    ),\n    duplicateDetectionHistoryTimeWindow: getString(\n      rawTopic[Constants.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW],\n      \"duplicateDetectionHistoryTimeWindow\",\n    ),\n\n    authorizationRules: getAuthorizationRulesOrUndefined(rawTopic[Constants.AUTHORIZATION_RULES]),\n    userMetadata: rawTopic[Constants.USER_METADATA],\n\n    status: rawTopic[Constants.STATUS],\n\n    enableExpress: getBoolean(rawTopic[Constants.ENABLE_EXPRESS], \"enableExpress\"),\n\n    availabilityStatus: rawTopic[Constants.ENTITY_AVAILABILITY_STATUS],\n\n    maxMessageSizeInKilobytes: getIntegerOrUndefined(\n      rawTopic[Constants.MAX_MESSAGE_SIZE_IN_KILOBYTES],\n    ),\n  };\n}\n\n/**\n * @internal\n * Builds the topic runtime info object from the raw json object gotten after deserializing the\n * response from the service\n */\nexport function buildTopicRuntimeProperties(rawTopic: Record<string, any>): TopicRuntimeProperties {\n  return {\n    name: getString(rawTopic[Constants.TOPIC_NAME], \"topicName\"),\n    sizeInBytes: getIntegerOrUndefined(rawTopic[Constants.SIZE_IN_BYTES]),\n    subscriptionCount: getIntegerOrUndefined(rawTopic[Constants.SUBSCRIPTION_COUNT]),\n    createdAt: getDate(rawTopic[Constants.CREATED_AT], \"createdAt\"),\n    scheduledMessageCount: getMessageCountDetails(rawTopic[Constants.COUNT_DETAILS])\n      .scheduledMessageCount,\n    modifiedAt: getDate(rawTopic[Constants.UPDATED_AT], \"modifiedAt\"),\n    accessedAt: getDate(rawTopic[Constants.ACCESSED_AT], \"accessedAt\"),\n  };\n}\n\n/**\n * Represents settable options on a topic\n */\nexport interface CreateTopicOptions extends OperationOptions {\n  /**\n   * Determines how long a message lives in the associated subscriptions.\n   * Subscriptions inherit the TTL from the topic unless they are created explicitly\n   * with a smaller TTL. Based on whether dead-lettering is enabled, a message whose\n   * TTL has expired will either be moved to the subscriptions associated dead-letter\n   * sub-queue or will be permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive?: string;\n\n  /**\n   * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message\n   * that will cause the topic to exceed this value will fail. All messages that are\n   * stored in the topic or any of its subscriptions count towards this value.\n   * Multiple copies of a message that reside in one or multiple subscriptions count\n   * as a single messages. For example, if message m exists once in subscription s1\n   * and twice in subscription s2, m is counted as a single message.\n   */\n  maxSizeInMegabytes?: number;\n\n  /**\n   * The maximum message size in kilobytes for messages sent to this topic.\n   *\n   * (Configurable only for Premium Tier Service Bus namespace.)\n   */\n  maxMessageSizeInKilobytes?: number;\n\n  /**\n   * If enabled, the topic will detect duplicate messages within the time span\n   * specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at topic creation time.\n   */\n  requiresDuplicateDetection?: boolean;\n\n  /**\n   * Specifies the time span during which the Service Bus will detect message duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  duplicateDetectionHistoryTimeWindow?: string;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations?: boolean;\n\n  /**\n   * Authorization rules on the topic\n   */\n  authorizationRules?: AuthorizationRule[];\n\n  /**\n   * Status of the messaging entity.\n   */\n  status?: EntityStatus;\n\n  /**\n   * The user provided metadata information associated with the topic.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata?: string;\n\n  /**\n   * Specifies whether the topic supports message ordering.\n   */\n  supportOrdering?: boolean;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle?: string;\n\n  /**\n   * Specifies whether the topic should be partitioned\n   */\n  enablePartitioning?: boolean;\n\n  /**\n   * Specifies whether express entities are enabled on topic.\n   */\n  enableExpress?: boolean;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  availabilityStatus?: EntityAvailabilityStatus;\n}\n\n/**\n * Represents the input for updateTopic.\n *\n */\nexport interface TopicProperties {\n  /**\n   * Name of the topic\n   */\n  readonly name: string;\n\n  /**\n   * Determines how long a message lives in the associated subscriptions.\n   * Subscriptions inherit the TTL from the topic unless they are created explicitly\n   * with a smaller TTL. Based on whether dead-lettering is enabled, a message whose\n   * TTL has expired will either be moved to the subscriptions associated dead-letter\n   * sub-queue or will be permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  defaultMessageTimeToLive: string;\n\n  /**\n   * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message\n   * that will cause the topic to exceed this value will fail. All messages that are\n   * stored in the topic or any of its subscriptions count towards this value.\n   * Multiple copies of a message that reside in one or multiple subscriptions count\n   * as a single messages. For example, if message m exists once in subscription s1\n   * and twice in subscription s2, m is counted as a single message.\n   */\n  maxSizeInMegabytes: number;\n\n  /**\n   * The maximum message size in kilobytes for messages sent to this queue/topic.\n   *\n   * Not applicable if service version \"2017-04\" is chosen when creating the `ServiceBusAdministrationClient`.\n   */\n  maxMessageSizeInKilobytes?: number;\n\n  /**\n   * If enabled, the topic will detect duplicate messages within the time span\n   * specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at topic creation time.\n   */\n  readonly requiresDuplicateDetection: boolean;\n\n  /**\n   * Specifies the time span during which the Service Bus will detect message duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  duplicateDetectionHistoryTimeWindow: string;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  enableBatchedOperations: boolean;\n\n  /**\n   * Authorization rules on the topic\n   */\n  authorizationRules?: AuthorizationRule[];\n\n  /**\n   * Status of the messaging entity.\n   */\n  status: EntityStatus;\n\n  /**\n   * The user provided metadata information associated with the topic.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  userMetadata: string;\n\n  /**\n   * Specifies whether the topic supports message ordering.\n   */\n  supportOrdering: boolean;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  autoDeleteOnIdle: string;\n\n  /**\n   * Specifies whether the topic should be partitioned\n   */\n  readonly enablePartitioning: boolean;\n\n  /**\n   * Specifies whether express entities are enabled on topic.\n   */\n  readonly enableExpress: boolean;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  readonly availabilityStatus: EntityAvailabilityStatus;\n}\n\n/**\n * @internal\n * Internal representation of settable options on a topic\n */\nexport interface InternalTopicOptions {\n  /**\n   * Determines how long a message lives in the associated subscriptions. Subscriptions\n   * inherit the TTL from the topic unless they are created explicitly with a smaller TTL.\n   * Based on whether dead-lettering is enabled, a message whose TTL has expired will\n   * either be moved to the subscriptions associated DeadLtterQueue or will be\n   * permanently deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  DefaultMessageTimeToLive?: string;\n\n  /**\n   * Specifies the maximum topic size in megabytes. Any attempt to enqueue a message\n   * that will cause the topic to exceed this value will fail. All messages that are\n   * stored in the topic or any of its subscriptions count towards this value.\n   * Multiple copies of a message that reside in one or multiple subscriptions count\n   * as a single messages. For example, if message m exists once in subscription s1\n   * and twice in subscription s2, m is counted as a single message.\n   */\n  MaxSizeInMegabytes?: string;\n\n  /**\n   * The maximum message size in kilobytes for messages sent to this queue/topic\n   *\n   */\n  MaxMessageSizeInKilobytes?: string;\n\n  /**\n   * If enabled, the topic will detect duplicate messages within the time span\n   * specified by the DuplicateDetectionHistoryTimeWindow property.\n   * Settable only at topic creation time.\n   */\n  RequiresDuplicateDetection?: string;\n\n  /**\n   * Specifies the time span during which the Service Bus will detect message\n   * duplication.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  DuplicateDetectionHistoryTimeWindow?: string;\n\n  /**\n   * Specifies if batched operations should be allowed.\n   */\n  EnableBatchedOperations?: string;\n\n  /**\n   * Authorization rules on the topic\n   */\n  AuthorizationRules?: any;\n\n  /**\n   * Status of the messaging entity.\n   */\n  Status?: string;\n\n  /**\n   * The user provided metadata information associated with the topic.\n   * Used to specify textual content such as tags, labels, etc.\n   * Value must not exceed 1024 bytes encoded in utf-8.\n   */\n  UserMetadata?: string;\n\n  /**\n   * Specifies whether the topic supports message ordering.\n   */\n  SupportOrdering?: string;\n\n  /**\n   * Max idle time before entity is deleted.\n   * This is to be specified in ISO-8601 duration format\n   * such as \"PT1M\" for 1 minute, \"PT5S\" for 5 seconds.\n   *\n   * More on ISO-8601 duration format: https://en.wikipedia.org/wiki/ISO_8601#Durations\n   */\n  AutoDeleteOnIdle?: string;\n\n  /**\n   * Specifies whether the topic should be partitioned\n   */\n  EnablePartitioning?: string;\n\n  /**\n   * Specifies whether express entities are enabled on queue.\n   */\n  EnableExpress?: string;\n\n  /**\n   * Availability status of the messaging entity.\n   */\n  EntityAvailabilityStatus?: string;\n}\n\n/**\n * Represents runtime info attributes of a topic entity\n */\nexport interface TopicRuntimeProperties {\n  /**\n   * Name of the topic\n   */\n  name: string;\n\n  /**\n   * Specifies the topic size in bytes.\n   */\n  sizeInBytes?: number;\n\n  /**\n   * The subscription count on given topic.\n   *\n   */\n  subscriptionCount?: number;\n\n  /**\n   * The number of scheduled messages.\n   */\n  scheduledMessageCount: number;\n\n  /**\n   * Created at timestamp\n   */\n  createdAt: Date;\n\n  /**\n   * Updated at timestamp\n   */\n  modifiedAt: Date;\n\n  /**\n   * Accessed at timestamp\n   */\n  accessedAt: Date;\n}\n\n/**\n * @internal\n * TopicResourceSerializer for serializing / deserializing Topic entities\n */\nexport class TopicResourceSerializer implements AtomXmlSerializer {\n  serialize(resource: InternalTopicOptions): Record<string, unknown> {\n    return serializeToAtomXmlRequest(\"TopicDescription\", resource);\n  }\n  async deserialize(response: FullOperationResponse): Promise<FullOperationResponse> {\n    return deserializeAtomXmlResponse([\"TopicName\"], response);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport crypto from \"crypto\";\n\n/**\n * @internal\n */\nexport async function generateKey(secret: string, stringToSign: string): Promise<string> {\n  const result = encodeURIComponent(\n    crypto.createHmac(\"sha256\", secret).update(stringToSign).digest(\"base64\"),\n  );\n  return result;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AccessToken, NamedKeyCredential } from \"@azure/core-auth\";\nimport { createHttpHeaders, PipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { generateKey } from \"./crypto\";\nimport { createSasTokenProvider, SasTokenProvider } from \"@azure/core-amqp\";\n\n/**\n * @internal\n */\nexport class SasServiceClientCredentials {\n  /**\n   * The NamedKeyCredential containing the key name and secret key value.\n   */\n  private _credential: NamedKeyCredential;\n\n  /**\n   * A SasTokenProvider provides a method to retrieve an `AccessToken`.\n   */\n  private _tokenProvider: SasTokenProvider;\n  /**\n   * Creates a new sasServiceClientCredentials object.\n   *\n   * @param credential - The NamedKeyCredential containing the key name and secret key value.\n   */\n  constructor(credential: NamedKeyCredential) {\n    this._credential = credential;\n    this._tokenProvider = createSasTokenProvider(credential);\n  }\n\n  private async _generateSignature(targetUri: string, expirationDate: number): Promise<string> {\n    const stringToSign = `${targetUri}\\n${expirationDate}`;\n    const result = await generateKey(this._credential.key, stringToSign);\n    return result;\n  }\n\n  /**\n   * Signs a request with the Authentication header.\n   *\n   * @param request - The {@link PipelineRequest} to be signed.\n   * @returns The signed request object.\n   */\n  async signRequest(request: PipelineRequest): Promise<PipelineRequest> {\n    if (!request.headers) request.headers = createHttpHeaders();\n\n    const targetUri = encodeURIComponent(request.url.toLowerCase()).toLowerCase();\n\n    const date = new Date();\n    date.setMinutes(date.getMinutes() + 5);\n    const expirationDate = Math.round(date.getTime() / 1000);\n    const signature = await this._generateSignature(targetUri, expirationDate);\n    request.headers.set(\n      \"authorization\",\n      `SharedAccessSignature sig=${signature}&se=${expirationDate}&skn=${this._credential.name}&sr=${targetUri}`,\n    );\n    request.withCredentials = true;\n    return request;\n  }\n\n  getToken(audience: string): Promise<AccessToken> {\n    return this._tokenProvider.getToken(audience);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createTracingClient, TracingSpanOptions, TracingSpanKind } from \"@azure/core-tracing\";\nimport { ConnectionConfig } from \"@azure/core-amqp\";\nimport { packageJsonInfo } from \"../util/constants\";\n\n/**\n * The names of the operations that can be instrumented.\n */\nexport type MessagingOperationNames = \"publish\" | \"receive\" | \"process\" | \"settle\";\n\n/**\n * The {@link TracingClient} that is used to add tracing spans.\n */\nexport const tracingClient = createTracingClient({\n  namespace: \"Microsoft.ServiceBus\",\n  packageName: packageJsonInfo.name,\n  packageVersion: packageJsonInfo.version,\n});\n\n/**\n * Creates {@link TracingSpanOptions} from the provided data.\n * @param serviceBusConfig - The configuration object containing initial attributes to set on the span.\n * @param spanKind - The {@link TracingSpanKind} for the newly created span.\n * @param operation - The operation type.\n * @returns a {@link TracingSpanOptions} that can be passed to a {@link TracingClient}\n */\nexport function toSpanOptions(\n  serviceBusConfig: Pick<ConnectionConfig, \"host\"> & { entityPath: string },\n  operation: MessagingOperationNames,\n  spanKind?: TracingSpanKind,\n): TracingSpanOptions {\n  const propertyName =\n    operation === \"process\" || operation === \"receive\"\n      ? \"messaging.source.name\"\n      : \"messaging.destination.name\";\n\n  const spanOptions: TracingSpanOptions = {\n    spanAttributes: {\n      \"messaging.system\": \"servicebus\",\n      [propertyName]: serviceBusConfig.entityPath,\n      \"messaging.operation\": operation,\n      \"net.peer.name\": serviceBusConfig.host,\n    },\n  };\n  if (spanKind) {\n    spanOptions.spanKind = spanKind;\n  }\n  return spanOptions;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants as AMQPConstants, parseConnectionString } from \"@azure/core-amqp\";\nimport {\n  TokenCredential,\n  isTokenCredential,\n  NamedKeyCredential,\n  isNamedKeyCredential,\n} from \"@azure/core-auth\";\nimport {\n  ServiceClient,\n  OperationOptions,\n  CommonClientOptions,\n  FullOperationResponse,\n} from \"@azure/core-client\";\nimport { PagedAsyncIterableIterator, PageSettings } from \"@azure/core-paging\";\nimport {\n  bearerTokenAuthenticationPolicy,\n  RestError,\n  PipelineResponse,\n  createPipelineFromOptions,\n  PipelineRequest,\n  createPipelineRequest,\n  PipelinePolicy,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { CorrelationRuleFilter } from \"./core/managementClient\";\nimport { administrationLogger as logger } from \"./log\";\nimport {\n  buildNamespace,\n  NamespaceProperties,\n  NamespaceResourceSerializer,\n} from \"./serializers/namespaceResourceSerializer\";\nimport {\n  buildQueue,\n  buildQueueOptions,\n  buildQueueRuntimeProperties,\n  CreateQueueOptions,\n  InternalQueueOptions,\n  QueueProperties,\n  QueueResourceSerializer,\n  QueueRuntimeProperties,\n} from \"./serializers/queueResourceSerializer\";\nimport {\n  buildRule,\n  CreateRuleOptions,\n  isSqlRuleAction,\n  RuleProperties,\n  RuleResourceSerializer,\n  SqlRuleAction,\n  SqlRuleFilter,\n} from \"./serializers/ruleResourceSerializer\";\nimport {\n  buildSubscription,\n  buildSubscriptionOptions,\n  buildSubscriptionRuntimeProperties,\n  CreateSubscriptionOptions,\n  InternalSubscriptionOptions,\n  SubscriptionProperties,\n  SubscriptionResourceSerializer,\n  SubscriptionRuntimeProperties,\n} from \"./serializers/subscriptionResourceSerializer\";\nimport {\n  buildTopic,\n  buildTopicOptions,\n  buildTopicRuntimeProperties,\n  CreateTopicOptions,\n  InternalTopicOptions,\n  TopicProperties,\n  TopicResourceSerializer,\n  TopicRuntimeProperties,\n} from \"./serializers/topicResourceSerializer\";\nimport { AtomXmlSerializer, executeAtomXmlOperation } from \"./util/atomXmlHelper\";\nimport * as Constants from \"./util/constants\";\nimport { parseURL } from \"./util/parseUrl\";\nimport { SasServiceClientCredentials } from \"./util/sasServiceClientCredentials\";\nimport { tracingClient } from \"./diagnostics/tracing\";\nimport { isDefined } from \"@azure/core-util\";\nimport {\n  formatUserAgentPrefix,\n  getHttpResponseOnly,\n  isAbsoluteUrl,\n  isJSONLikeObject,\n  ServiceBusAtomAPIVersion,\n} from \"./util/utils\";\nimport { HttpResponse } from \"./util/compat\";\n\n/**\n * Request options for list<entity-type>() operations\n */\nexport interface ListRequestOptions {\n  /**\n   * Count of entities to fetch.\n   */\n  maxCount?: number;\n\n  /**\n   * Count of entities to skip from being fetched.\n   */\n  skip?: number;\n}\n\n/**\n * Represents the returned response of the operation along with the raw response.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type WithResponse<T extends object> = T & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse;\n};\n\n/**\n * Represents the client options of the `ServiceBusAdministrationClient`.\n */\nexport interface ServiceBusAdministrationClientOptions extends CommonClientOptions {\n  /**\n   * Service version of the ATOM API.\n   *\n   * Currently supported = \"2021-05\" | \"2017-04\"\n   *\n   * Defaults to \"2021-05\".\n   */\n  serviceVersion?: \"2021-05\" | \"2017-04\";\n}\n\n/**\n * Represents the result of list operation on entities which also contains the `continuationToken` to start iterating over from.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type EntitiesResponse<T extends object> = WithResponse<Array<T>> &\n  Pick<PageSettings, \"continuationToken\">;\n\nfunction signingPolicy(credentials: {\n  signRequest(request: PipelineRequest): Promise<PipelineRequest>;\n}): PipelinePolicy {\n  return {\n    name: \"signingPolicy\",\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const signed = await credentials.signRequest(request);\n      return next(signed);\n    },\n  };\n}\n\n/**\n * All operations return promises that resolve to an object that has the relevant output.\n * These objects also have a property called `_response` that you can use if you want to\n * access the direct response from the service.\n */\nexport class ServiceBusAdministrationClient extends ServiceClient {\n  /**\n   * Reference to the endpoint as extracted from input connection string.\n   */\n  private endpoint: string;\n\n  /**\n   * Reference to the endpoint with protocol prefix as extracted from input connection string.\n   */\n  private endpointWithProtocol: string;\n\n  private serviceVersion: ServiceBusAtomAPIVersion;\n\n  /**\n   * Singleton instances of serializers used across the various operations.\n   */\n  private namespaceResourceSerializer: AtomXmlSerializer;\n  private queueResourceSerializer: AtomXmlSerializer;\n  private topicResourceSerializer: AtomXmlSerializer;\n  private subscriptionResourceSerializer: AtomXmlSerializer;\n  private ruleResourceSerializer: AtomXmlSerializer;\n\n  /**\n   * Credentials used to generate tokens as required for the various operations.\n   */\n  private credentials: SasServiceClientCredentials | TokenCredential;\n\n  /**\n   * Initializes a new instance of the ServiceBusAdministrationClient class.\n   * @param connectionString - The connection string needed for the client to connect to Azure.\n   * @param options - PipelineOptions\n   */\n  // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n  constructor(connectionString: string, options?: ServiceBusAdministrationClientOptions);\n  /**\n   *\n   * @param fullyQualifiedNamespace - The fully qualified namespace of your Service Bus instance which is\n   * likely to be similar to <yournamespace>.servicebus.windows.net.\n   * @param credential - A credential object used by the client to get the token to authenticate the connection\n   * with the Azure Service Bus. See &commat;azure/identity for creating the credentials.\n   * If you're using your own implementation of the `TokenCredential` interface against AAD, then set the \"scopes\" for service-bus\n   * to be `[\"https://servicebus.azure.net//user_impersonation\"]` to get the appropriate token.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * @param options - PipelineOptions\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    credential: TokenCredential | NamedKeyCredential,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusAdministrationClientOptions,\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    credentialOrOptions2?:\n      | TokenCredential\n      | NamedKeyCredential\n      | ServiceBusAdministrationClientOptions,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options3?: ServiceBusAdministrationClientOptions,\n  ) {\n    let options: ServiceBusAdministrationClientOptions;\n    let fullyQualifiedNamespace: string;\n    let credentials: SasServiceClientCredentials | TokenCredential;\n    let authPolicy: PipelinePolicy;\n    if (isTokenCredential(credentialOrOptions2)) {\n      fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;\n      options = options3 || {};\n      credentials = credentialOrOptions2;\n      authPolicy = bearerTokenAuthenticationPolicy({\n        credential: credentials,\n        scopes: AMQPConstants.aadServiceBusScope,\n      });\n    } else if (isNamedKeyCredential(credentialOrOptions2)) {\n      fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;\n      credentials = new SasServiceClientCredentials(credentialOrOptions2);\n      options = options3 || {};\n      authPolicy = signingPolicy(credentials as SasServiceClientCredentials);\n    } else {\n      const connectionString = fullyQualifiedNamespaceOrConnectionString1;\n      options = credentialOrOptions2 || {};\n      const connectionStringObj: any = parseConnectionString(connectionString);\n      if (connectionStringObj.Endpoint === undefined) {\n        throw new Error(\"Missing Endpoint in connection string.\");\n      }\n      try {\n        fullyQualifiedNamespace = connectionStringObj.Endpoint.match(\".*://([^/]*)\")[1];\n      } catch (error: any) {\n        throw new Error(\"Endpoint in the connection string is not valid.\");\n      }\n      credentials = new SasServiceClientCredentials({\n        key: connectionStringObj.SharedAccessKey,\n        name: connectionStringObj.SharedAccessKeyName,\n      });\n      authPolicy = signingPolicy(credentials as SasServiceClientCredentials);\n    }\n\n    const userAgentPrefix = formatUserAgentPrefix(options.userAgentOptions?.userAgentPrefix);\n    const serviceClientOptions = createPipelineFromOptions({\n      ...options,\n      userAgentOptions: {\n        userAgentPrefix,\n      },\n    });\n    serviceClientOptions.addPolicy(authPolicy);\n    super({ pipeline: serviceClientOptions });\n    this.endpoint = fullyQualifiedNamespace;\n    this.endpointWithProtocol = fullyQualifiedNamespace.endsWith(\"/\")\n      ? \"sb://\" + fullyQualifiedNamespace\n      : \"sb://\" + fullyQualifiedNamespace + \"/\";\n    this.serviceVersion = options.serviceVersion ?? Constants.CURRENT_API_VERSION;\n    this.credentials = credentials;\n    this.namespaceResourceSerializer = new NamespaceResourceSerializer();\n    this.queueResourceSerializer = new QueueResourceSerializer();\n    this.topicResourceSerializer = new TopicResourceSerializer();\n    this.subscriptionResourceSerializer = new SubscriptionResourceSerializer();\n    this.ruleResourceSerializer = new RuleResourceSerializer();\n  }\n\n  /**\n   * Returns an object representing the metadata related to a service bus namespace.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   */\n  async getNamespaceProperties(\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<NamespaceProperties>> {\n    logger.verbose(`Performing management operation - getNamespaceProperties()`);\n\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getNamespaceProperties\",\n      operationOptions,\n      async (updatedOptions) => {\n        const response = await this.getResource(\n          \"$namespaceinfo\",\n          this.namespaceResourceSerializer,\n          updatedOptions,\n        );\n        return this.buildNamespacePropertiesResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Creates a queue with given name, configured using the given options\n   * @param options - Options to configure the Queue being created(For example, you can configure a queue to support partitions or sessions)\n   *  and the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async createQueue(\n    queueName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options: CreateQueueOptions = {},\n  ): Promise<WithResponse<QueueProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.createQueue\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - createQueue() for \"${queueName}\" with options: %j`,\n          options,\n        );\n        const response = await this.putResource(\n          queueName,\n          buildQueueOptions(options || {}),\n          this.queueResourceSerializer,\n          false,\n          updatedOptions,\n        );\n\n        return this.buildQueueResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Queue and its properties.\n   * If you want to get the Queue runtime info like message count details, use `getQueueRuntimeProperties` API.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getQueue(\n    queueName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<QueueProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getQueue\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getQueue() for \"${queueName}\"`);\n        const response = await this.getResource(\n          queueName,\n          this.queueResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildQueueResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Queue runtime info like message count details.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getQueueRuntimeProperties(\n    queueName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<QueueRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getQueueRuntimeProperties\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getQueueRuntimeProperties() for \"${queueName}\"`,\n        );\n        const response = await this.getResource(\n          queueName,\n          this.queueResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildQueueRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns a list of objects, each representing a Queue along with its properties.\n   * If you want to get the runtime info of the queues like message count, use `getQueuesRuntimeProperties` API instead.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getQueues(\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<QueueProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getQueues\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getQueues() with options: %j`, options);\n        const response = await this.listResources(\n          \"$Resources/Queues\",\n          updatedOptions,\n          this.queueResourceSerializer,\n        );\n\n        return this.buildListQueuesResponse(response);\n      },\n    );\n  }\n\n  private async *listQueuesPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<QueueProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getQueues({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listQueuesAll(\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<QueueProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listQueuesPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the queues.\n   *\n   * .byPage() returns an async iterable iterator to list the queues in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listQueues(\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<QueueProperties, EntitiesResponse<QueueProperties>> {\n    logger.verbose(`Performing management operation - listQueues() with options: %j`, options);\n    const iter = this.listQueuesAll(options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listQueuesPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Returns a list of objects, each representing a Queue's runtime info like message count details.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getQueuesRuntimeProperties(\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<QueueRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getQueuesRuntimeProperties\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getQueuesRuntimeProperties() with options: %j`,\n          options,\n        );\n        const response = await this.listResources(\n          \"$Resources/Queues\",\n          updatedOptions,\n          this.queueResourceSerializer,\n        );\n\n        return this.buildListQueuesRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  private async *listQueuesRuntimePropertiesPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<QueueRuntimeProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getQueuesRuntimeProperties({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listQueuesRuntimePropertiesAll(\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<QueueRuntimeProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listQueuesRuntimePropertiesPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list runtime info of the queues.\n   *\n   * .byPage() returns an async iterable iterator to list runtime info of the queues in pages.\n   *\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listQueuesRuntimeProperties(\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<QueueRuntimeProperties, EntitiesResponse<QueueRuntimeProperties>> {\n    logger.verbose(\n      `Performing management operation - listQueuesRuntimeProperties() with options: %j`,\n      options,\n    );\n    const iter = this.listQueuesRuntimePropertiesAll(options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listQueuesRuntimePropertiesPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Updates the queue based on the queue properties provided.\n   * All queue properties must be set even though only a subset of them are actually updatable.\n   * Therefore, the suggested flow is to use the output from `getQueue()`, update the desired properties in it, and then pass the modified object to `updateQueue()`.\n   *\n   * The properties that cannot be updated are marked as readonly in the `QueueProperties` interface.\n   *\n   * @param queue - Object representing the properties of the queue and the raw response.\n   * `requiresSession`, `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the queue.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateQueue(\n    queue: WithResponse<QueueProperties>,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<QueueProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.updateQueue\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - updateQueue() for \"${queue.name}\" with options: %j`,\n          queue,\n        );\n\n        if (!isJSONLikeObject(queue) || queue == null) {\n          throw new TypeError(\n            `Parameter \"queue\" must be an object of type \"QueueDescription\" and cannot be undefined or null.`,\n          );\n        }\n\n        if (!queue.name) {\n          throw new TypeError(`\"name\" attribute of the parameter \"queue\" cannot be undefined.`);\n        }\n\n        const response = await this.putResource(\n          queue.name,\n          buildQueueOptions(queue),\n          this.queueResourceSerializer,\n          true,\n          updatedOptions,\n        );\n\n        return this.buildQueueResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Deletes a queue.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteQueue(\n    queueName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n    // eslint-disable-next-line @typescript-eslint/ban-types\n  ): Promise<WithResponse<{}>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.deleteQueue\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - deleteQueue() for \"${queueName}\"`);\n        const response = await this.deleteResource(\n          queueName,\n          this.queueResourceSerializer,\n          updatedOptions,\n        );\n\n        return { _response: getHttpResponseOnly(response) };\n      },\n    );\n  }\n\n  /**\n   * Checks whether a given queue exists or not.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   */\n  // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n  async queueExists(queueName: string, operationOptions: OperationOptions = {}): Promise<boolean> {\n    logger.verbose(`Performing management operation - queueExists() for \"${queueName}\"`);\n    const { span, updatedOptions } = tracingClient.startSpan(\n      \"ServiceBusAdministrationClient.queueExists\",\n      operationOptions,\n    );\n    try {\n      await this.getQueue(queueName, updatedOptions);\n      span.setStatus({ status: \"success\" });\n      return true;\n    } catch (e: any) {\n      span.setStatus({ status: \"error\", error: e });\n      return false;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a topic with given name, configured using the given options\n   * @param options - Options to configure the Topic being created(For example, you can configure a topic to support partitions)\n   * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async createTopic(\n    topicName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options: CreateTopicOptions = {},\n  ): Promise<WithResponse<TopicProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.createTopic\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - createTopic() for \"${topicName}\" with options: %j`,\n          options,\n        );\n        const response = await this.putResource(\n          topicName,\n          buildTopicOptions(options || {}),\n          this.topicResourceSerializer,\n          false,\n          updatedOptions,\n        );\n\n        return this.buildTopicResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Topic and its properties.\n   * If you want to get the Topic runtime info like subscription count details, use `getTopicRuntimeProperties` API.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getTopic(\n    topicName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<TopicProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getTopic\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getTopic() for \"${topicName}\"`);\n        const response = await this.getResource(\n          topicName,\n          this.topicResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildTopicResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Topic runtime info like subscription count.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getTopicRuntimeProperties(\n    topicName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<TopicRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getTopicRuntimeProperties\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getTopicRuntimeProperties() for \"${topicName}\"`,\n        );\n        const response = await this.getResource(\n          topicName,\n          this.topicResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildTopicRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns a list of objects, each representing a Topic along with its properties.\n   * If you want to get the runtime info of the topics like subscription count, use `getTopicsRuntimeProperties` API instead.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getTopics(\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<TopicProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getTopics\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getTopics() with options: %j`, options);\n        const response = await this.listResources(\n          \"$Resources/Topics\",\n          updatedOptions,\n          this.topicResourceSerializer,\n        );\n\n        return this.buildListTopicsResponse(response);\n      },\n    );\n  }\n\n  private async *listTopicsPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<TopicProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getTopics({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listTopicsAll(\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<TopicProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listTopicsPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the topics.\n   *\n   * .byPage() returns an async iterable iterator to list the topics in pages.\n   *\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listTopics(\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<TopicProperties, EntitiesResponse<TopicProperties>> {\n    logger.verbose(`Performing management operation - listTopics() with options: %j`, options);\n    const iter = this.listTopicsAll(options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listTopicsPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Returns a list of objects, each representing a Topic's runtime info like subscription count.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getTopicsRuntimeProperties(\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<TopicRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getTopicsRuntimeProperties\",\n\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getTopicsRuntimeProperties() with options: %j`,\n          options,\n        );\n        const response = await this.listResources(\n          \"$Resources/Topics\",\n          updatedOptions,\n          this.topicResourceSerializer,\n        );\n\n        return this.buildListTopicsRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  private async *listTopicsRuntimePropertiesPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<TopicRuntimeProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getTopicsRuntimeProperties({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listTopicsRuntimePropertiesAll(\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<TopicRuntimeProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listTopicsRuntimePropertiesPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list runtime info of the topics.\n   *\n   * .byPage() returns an async iterable iterator to list runtime info of the topics in pages.\n   *\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listTopicsRuntimeProperties(\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<TopicRuntimeProperties, EntitiesResponse<TopicRuntimeProperties>> {\n    logger.verbose(\n      `Performing management operation - listTopicsRuntimeProperties() with options: %j`,\n      options,\n    );\n    const iter = this.listTopicsRuntimePropertiesAll(options);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listTopicsRuntimePropertiesPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Updates the topic based on the topic properties provided.\n   * All topic properties must be set even though only a subset of them are actually updatable.\n   * Therefore, the suggested flow is to use the output from `getTopic()`, update the desired properties in it, and then pass the modified object to `updateTopic()`.\n   *\n   * The properties that cannot be updated are marked as readonly in the `TopicProperties` interface.\n   *\n   * @param topic - Object representing the properties of the topic and the raw response.\n   * `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the topic.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateTopic(\n    topic: WithResponse<TopicProperties>,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<TopicProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.updateTopic\",\n\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - updateTopic() for \"${topic.name}\" with options: %j`,\n          topic,\n        );\n\n        if (!isJSONLikeObject(topic) || topic == null) {\n          throw new TypeError(\n            `Parameter \"topic\" must be an object of type \"TopicDescription\" and cannot be undefined or null.`,\n          );\n        }\n\n        if (!topic.name) {\n          throw new TypeError(`\"name\" attribute of the parameter \"topic\" cannot be undefined.`);\n        }\n\n        const response = await this.putResource(\n          topic.name,\n          buildTopicOptions(topic),\n          this.topicResourceSerializer,\n          true,\n          updatedOptions,\n        );\n\n        return this.buildTopicResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Deletes a topic.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteTopic(\n    topicName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n    // eslint-disable-next-line @typescript-eslint/ban-types\n  ): Promise<WithResponse<{}>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.deleteTopic\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - deleteTopic() for \"${topicName}\"`);\n        const response = await this.deleteResource(\n          topicName,\n          this.topicResourceSerializer,\n          updatedOptions,\n        );\n\n        return { _response: getHttpResponseOnly(response) };\n      },\n    );\n  }\n\n  /**\n   * Checks whether a given topic exists or not.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   */\n  // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n  async topicExists(topicName: string, operationOptions?: OperationOptions): Promise<boolean> {\n    logger.verbose(`Performing management operation - topicExists() for \"${topicName}\"`);\n    const { span, updatedOptions } = tracingClient.startSpan(\n      \"ServiceBusAdministrationClient.topicExists\",\n      operationOptions,\n    );\n    try {\n      span.setStatus({ status: \"success\" });\n      await this.getTopic(topicName, updatedOptions);\n      return true;\n    } catch (e: any) {\n      span.setStatus({ status: \"error\", error: e });\n      return false;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a subscription with given name, configured using the given options\n   * @param options - Options to configure the Subscription being created(For example, you can configure a Subscription to support partitions or sessions)\n   * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async createSubscription(\n    topicName: string,\n    subscriptionName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options: CreateSubscriptionOptions = {},\n  ): Promise<WithResponse<SubscriptionProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.createSubscription\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - createSubscription() for \"${subscriptionName}\" with options: %j`,\n          options,\n        );\n        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n        const response = await this.putResource(\n          fullPath,\n          buildSubscriptionOptions(options || {}),\n          this.subscriptionResourceSerializer,\n          false,\n          updatedOptions,\n        );\n\n        return this.buildSubscriptionResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Subscription and its properties.\n   * If you want to get the Subscription runtime info like message count details, use `getSubscriptionRuntimeProperties` API.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getSubscription(\n    topicName: string,\n    subscriptionName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<SubscriptionProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getSubscription\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getSubscription() for \"${subscriptionName}\"`,\n        );\n        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n        const response = await this.getResource(\n          fullPath,\n          this.subscriptionResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildSubscriptionResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Subscription runtime info like message count details.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getSubscriptionRuntimeProperties(\n    topicName: string,\n    subscriptionName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<SubscriptionRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getSubscriptionRuntimeProperties\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getSubscriptionRuntimeProperties() for \"${subscriptionName}\"`,\n        );\n        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n        const response = await this.getResource(\n          fullPath,\n          this.subscriptionResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildSubscriptionRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns a list of objects, each representing a Subscription along with its properties.\n   * If you want to get the runtime info of the subscriptions like message count, use `getSubscriptionsRuntimeProperties` API instead.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getSubscriptions(\n    topicName: string,\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<SubscriptionProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getSubscriptions\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getSubscriptions() with options: %j`,\n          options,\n        );\n        const response = await this.listResources(\n          topicName + \"/Subscriptions/\",\n          updatedOptions,\n          this.subscriptionResourceSerializer,\n        );\n\n        return this.buildListSubscriptionsResponse(response);\n      },\n    );\n  }\n\n  private async *listSubscriptionsPage(\n    topicName: string,\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<SubscriptionProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getSubscriptions(topicName, {\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listSubscriptionsAll(\n    topicName: string,\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<SubscriptionProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listSubscriptionsPage(topicName, marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   *\n   * Returns an async iterable iterator to list all the subscriptions\n   * under the specified topic.\n   *\n   * .byPage() returns an async iterable iterator to list the subscriptions in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listSubscriptions(\n    topicName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<SubscriptionProperties, EntitiesResponse<SubscriptionProperties>> {\n    logger.verbose(\n      `Performing management operation - listSubscriptions() with options: %j`,\n      options,\n    );\n    const iter = this.listSubscriptionsAll(topicName, options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listSubscriptionsPage(topicName, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Returns a list of objects, each representing a Subscription's runtime info like message count details.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getSubscriptionsRuntimeProperties(\n    topicName: string,\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<SubscriptionRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getSubscriptionsRuntimeProperties\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getSubscriptionsRuntimeProperties() with options: %j`,\n          options,\n        );\n        const response = await this.listResources(\n          topicName + \"/Subscriptions/\",\n          updatedOptions,\n          this.subscriptionResourceSerializer,\n        );\n\n        return this.buildListSubscriptionsRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  private async *listSubscriptionsRuntimePropertiesPage(\n    topicName: string,\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<SubscriptionRuntimeProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getSubscriptionsRuntimeProperties(topicName, {\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listSubscriptionsRuntimePropertiesAll(\n    topicName: string,\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<SubscriptionRuntimeProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listSubscriptionsRuntimePropertiesPage(\n      topicName,\n      marker,\n      options,\n    )) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list runtime info of the subscriptions\n   * under the specified topic.\n   *\n   * .byPage() returns an async iterable iterator to list runtime info of subscriptions in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listSubscriptionsRuntimeProperties(\n    topicName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<\n    SubscriptionRuntimeProperties,\n    EntitiesResponse<SubscriptionRuntimeProperties>\n  > {\n    logger.verbose(\n      `Performing management operation - listSubscriptionsRuntimeProperties() with options: %j`,\n      options,\n    );\n    const iter = this.listSubscriptionsRuntimePropertiesAll(topicName, options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listSubscriptionsRuntimePropertiesPage(topicName, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Updates the subscription based on the subscription properties provided.\n   * All subscription properties must be set even though only a subset of them are actually updatable.\n   * Therefore, the suggested flow is to use the output from `getSubscription()`, update the desired properties in it, and then pass the modified object to `updateSubscription()`.\n   *\n   * The properties that cannot be updated are marked as readonly in the `SubscriptionProperties` interface.\n   * @param subscription - Object representing the properties of the subscription and the raw response.\n   * `subscriptionName`, `topicName`, and `requiresSession` can't be updated after creating the subscription.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateSubscription(\n    subscription: WithResponse<SubscriptionProperties>,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<SubscriptionProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.updateSubscription\",\n\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - updateSubscription() for \"${subscription.subscriptionName}\" with options: %j`,\n          subscription,\n        );\n\n        if (!isJSONLikeObject(subscription) || subscription == null) {\n          throw new TypeError(\n            `Parameter \"subscription\" must be an object of type \"SubscriptionDescription\" and cannot be undefined or null.`,\n          );\n        }\n\n        if (!subscription.topicName || !subscription.subscriptionName) {\n          throw new TypeError(\n            `The attributes \"topicName\" and \"subscriptionName\" of the parameter \"subscription\" cannot be undefined.`,\n          );\n        }\n\n        const fullPath = this.getSubscriptionPath(\n          subscription.topicName,\n          subscription.subscriptionName,\n        );\n\n        const response = await this.putResource(\n          fullPath,\n          buildSubscriptionOptions(subscription),\n          this.subscriptionResourceSerializer,\n          true,\n          updatedOptions,\n        );\n\n        return this.buildSubscriptionResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Deletes a subscription.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteSubscription(\n    topicName: string,\n    subscriptionName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n    // eslint-disable-next-line @typescript-eslint/ban-types\n  ): Promise<WithResponse<{}>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.deleteSubscription\",\n\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - deleteSubscription() for \"${subscriptionName}\"`,\n        );\n        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n        const response = await this.deleteResource(\n          fullPath,\n          this.subscriptionResourceSerializer,\n          updatedOptions,\n        );\n\n        return { _response: getHttpResponseOnly(response) };\n      },\n    );\n  }\n\n  /**\n   * Checks whether a given subscription exists in the topic or not.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   */\n  async subscriptionExists(\n    topicName: string,\n    subscriptionName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<boolean> {\n    logger.verbose(\n      `Performing management operation - subscriptionExists() for \"${topicName}\" and \"${subscriptionName}\"`,\n    );\n    const { span, updatedOptions } = tracingClient.startSpan(\n      \"ServiceBusAdministrationClient.subscriptionExists\",\n      operationOptions,\n    );\n    try {\n      span.setStatus({ status: \"success\" });\n      await this.getSubscription(topicName, subscriptionName, updatedOptions);\n      return true;\n    } catch (e: any) {\n      span.setStatus({ status: \"error\", error: e });\n      return false;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a rule with given name, configured using the given options.\n   * @param ruleFilter - Defines the filter expression that the rule evaluates.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  createRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    ruleFilter: SqlRuleFilter | CorrelationRuleFilter,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions?: OperationOptions,\n  ): Promise<WithResponse<RuleProperties>>;\n  /**\n   * Creates a rule with given name, configured using the given options.\n   * @param ruleFilter - Defines the filter expression that the rule evaluates.\n   * @param ruleAction - The SQL like expression that can be executed on the message should the associated filter apply.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  createRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    ruleFilter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleAction: SqlRuleAction,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions?: OperationOptions,\n  ): Promise<WithResponse<RuleProperties>>;\n  async createRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    ruleFilter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleActionOrOperationOptions?: SqlRuleAction | OperationOptions,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions?: OperationOptions,\n  ): Promise<WithResponse<RuleProperties>> {\n    let ruleAction: SqlRuleAction | undefined = undefined;\n    let operOptions: OperationOptions | undefined;\n    if (ruleActionOrOperationOptions) {\n      if (isSqlRuleAction(ruleActionOrOperationOptions)) {\n        // Overload#2 - where the sqlExpression in the ruleAction is defined\n        ruleAction = ruleActionOrOperationOptions;\n        operOptions = operationOptions;\n      } else {\n        // Overload#1\n        // Overload#2 - where the sqlExpression in the ruleAction is undefined\n        operOptions = { ...ruleActionOrOperationOptions, ...operationOptions };\n      }\n    }\n\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.createRule\",\n      operOptions ?? {},\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - createRule() for \"${ruleName}\" with filter: \"%j\"`,\n          ruleFilter,\n        );\n        const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);\n        const response = await this.putResource(\n          fullPath,\n          { name: ruleName, filter: ruleFilter, action: ruleAction },\n          this.ruleResourceSerializer,\n          false,\n          updatedOptions,\n        );\n        return this.buildRuleResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Rule with the given name along with all its properties.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<RuleProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getRule\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getRule() for \"${ruleName}\"`);\n        const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);\n        const response = await this.getResource(\n          fullPath,\n          this.ruleResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildRuleResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Lists existing rules.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getRules(\n    topicName: string,\n    subscriptionName: string,\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<RuleProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getRules\",\n\n      options,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getRules() with options: %j`, options);\n        const fullPath = this.getSubscriptionPath(topicName, subscriptionName) + \"/Rules/\";\n        const response = await this.listResources(\n          fullPath,\n          updatedOptions,\n          this.ruleResourceSerializer,\n        );\n\n        return this.buildListRulesResponse(response);\n      },\n    );\n  }\n\n  private async *listRulesPage(\n    topicName: string,\n    subscriptionName: string,\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<RuleProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getRules(topicName, subscriptionName, {\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listRulesAll(\n    topicName: string,\n    subscriptionName: string,\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<RuleProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listRulesPage(topicName, subscriptionName, marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the rules\n   * under the specified subscription.\n   *\n   * .byPage() returns an async iterable iterator to list the rules in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listRules(\n    topicName: string,\n    subscriptionName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<RuleProperties, EntitiesResponse<RuleProperties>> {\n    logger.verbose(`Performing management operation - listRules() with options: %j`, options);\n    const iter = this.listRulesAll(topicName, subscriptionName, options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listRulesPage(topicName, subscriptionName, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Updates properties on the Rule by the given name based on the given options.\n   * All rule properties must be set even if one of them is being updated.\n   * Therefore, the suggested flow is to use the output from `getRule()`, update the desired properties in it, and then pass the modified object to `updateRule()`.\n   *\n   * @param rule - Options to configure the Rule being updated and the raw response.\n   * For example, you can configure the filter to apply on associated Topic/Subscription.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateRule(\n    topicName: string,\n    subscriptionName: string,\n    rule: WithResponse<RuleProperties>,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions?: OperationOptions,\n  ): Promise<WithResponse<RuleProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.updateRule\",\n      operationOptions ?? {},\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - updateRule() for \"${rule.name}\" with options: %j`,\n          rule,\n        );\n\n        if (!isJSONLikeObject(rule) || rule === null) {\n          throw new TypeError(\n            `Parameter \"rule\" must be an object of type \"RuleDescription\" and cannot be undefined or null.`,\n          );\n        }\n\n        if (!rule.name) {\n          throw new TypeError(`\"name\" attribute of the parameter \"rule\" cannot be undefined.`);\n        }\n\n        const fullPath = this.getRulePath(topicName, subscriptionName, rule.name);\n        const response = await this.putResource(\n          fullPath,\n          rule,\n          this.ruleResourceSerializer,\n          true,\n          updatedOptions,\n        );\n\n        return this.buildRuleResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Deletes a rule.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions?: OperationOptions,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n  ): Promise<WithResponse<{}>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.deleteRule\",\n      operationOptions ?? {},\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - deleteRule() for \"${ruleName}\"`);\n        const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);\n        const response = await this.deleteResource(\n          fullPath,\n          this.ruleResourceSerializer,\n          updatedOptions,\n        );\n\n        return { _response: getHttpResponseOnly(response) };\n      },\n    );\n  }\n\n  /**\n   * Checks whether a given rule exists or not.\n   *\n   */\n  async ruleExists(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    operationOptions: OperationOptions = {},\n  ): Promise<boolean> {\n    logger.verbose(`Performing management operation - ruleExists() for \"${ruleName}\"`);\n    const { span, updatedOptions } = tracingClient.startSpan(\n      \"ServiceBusAdministrationClient.ruleExists\",\n      operationOptions,\n    );\n    try {\n      span.setStatus({ status: \"success\" });\n      await this.getRule(topicName, subscriptionName, ruleName, updatedOptions);\n      return true;\n    } catch (e: any) {\n      span.setStatus({ status: \"error\", error: e });\n      return false;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates or updates a resource based on `isUpdate` parameter.\n   */\n  private async putResource(\n    name: string,\n    entityFields:\n      | InternalQueueOptions\n      | InternalTopicOptions\n      | InternalSubscriptionOptions\n      | CreateRuleOptions,\n    serializer: AtomXmlSerializer,\n    isUpdate: boolean = false,\n    operationOptions: OperationOptions = {},\n  ): Promise<PipelineResponse> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.putResource\",\n      operationOptions,\n      async (updatedOptions) => {\n        const request: PipelineRequest = createPipelineRequest({\n          url: this.getUrl(name),\n          method: \"PUT\",\n        });\n        if (isUpdate) {\n          request.headers.set(\"If-Match\", \"*\");\n        }\n\n        const queueOrSubscriptionFields = entityFields as\n          | InternalQueueOptions\n          | InternalSubscriptionOptions;\n        if (\n          queueOrSubscriptionFields.ForwardTo ||\n          queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo\n        ) {\n          const token =\n            this.credentials instanceof SasServiceClientCredentials\n              ? (await this.credentials.getToken(this.endpoint)).token\n              : (await this.credentials.getToken([AMQPConstants.aadServiceBusScope]))!.token;\n\n          if (queueOrSubscriptionFields.ForwardTo) {\n            request.headers.set(\"ServiceBusSupplementaryAuthorization\", token);\n            if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardTo)) {\n              queueOrSubscriptionFields.ForwardTo = this.endpointWithProtocol.concat(\n                queueOrSubscriptionFields.ForwardTo,\n              );\n            }\n          }\n          if (queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {\n            request.headers.set(\"ServiceBusDlqSupplementaryAuthorization\", token);\n            if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo)) {\n              queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo =\n                this.endpointWithProtocol.concat(\n                  queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo,\n                );\n            }\n          }\n        }\n\n        request.headers.set(\"content-type\", \"application/atom+xml;type=entry;charset=utf-8\");\n\n        return executeAtomXmlOperation(this, request, serializer, updatedOptions, entityFields);\n      },\n    );\n  }\n\n  /**\n   * Gets a resource.\n   */\n  private async getResource(\n    name: string,\n    serializer: AtomXmlSerializer,\n    operationOptions: OperationOptions = {},\n  ): Promise<FullOperationResponse> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getResource\",\n      operationOptions,\n      async (updatedOptions) => {\n        const request = createPipelineRequest({\n          url: this.getUrl(name),\n          method: \"GET\",\n        });\n\n        const response = await executeAtomXmlOperation(this, request, serializer, updatedOptions);\n        if (\n          !isDefined(response.parsedBody) ||\n          (Array.isArray(response.parsedBody) && response.parsedBody.length === 0)\n        ) {\n          const err = new RestError(\n            `The messaging entity \"${name}\" being requested cannot be found.`,\n            {\n              code: \"MessageEntityNotFoundError\",\n              statusCode: response.status,\n              request,\n              response,\n            },\n          );\n          throw err;\n        }\n        return response;\n      },\n    );\n  }\n\n  /**\n   * Lists existing resources\n   */\n  private async listResources(\n    name: string,\n    options: ListRequestOptions & OperationOptions = {},\n    serializer: AtomXmlSerializer,\n  ): Promise<FullOperationResponse> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.listResources\",\n      options,\n      async (updatedOptions) => {\n        const queryParams: { [key: string]: string } = {};\n        if (options) {\n          if (options.skip) {\n            queryParams[\"$skip\"] = options.skip.toString();\n          }\n          if (options.maxCount) {\n            queryParams[\"$top\"] = options.maxCount.toString();\n          }\n        }\n\n        const request = createPipelineRequest({\n          url: this.getUrl(name, queryParams),\n          method: \"GET\",\n        });\n\n        return executeAtomXmlOperation(this, request, serializer, updatedOptions);\n      },\n    );\n  }\n\n  /**\n   * Deletes a resource.\n   */\n  private async deleteResource(\n    name: string,\n    serializer: AtomXmlSerializer,\n    operationOptions: OperationOptions = {},\n  ): Promise<FullOperationResponse> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.deleteResource\",\n      operationOptions,\n      async (updatedOptions) => {\n        const request = createPipelineRequest({\n          url: this.getUrl(name),\n          method: \"DELETE\",\n        });\n        return executeAtomXmlOperation(this, request, serializer, updatedOptions);\n      },\n    );\n  }\n\n  private getUrl(path: string, queryParams?: { [key: string]: string }): string {\n    const baseUri = `https://${this.endpoint}/${path}`;\n\n    const requestUrl = new URL(baseUri);\n    requestUrl.searchParams.set(Constants.API_VERSION_QUERY_KEY, this.serviceVersion);\n\n    if (queryParams) {\n      for (const key of Object.keys(queryParams)) {\n        requestUrl.searchParams.set(key, queryParams[key]);\n      }\n    }\n\n    return requestUrl.toString();\n  }\n\n  private getSubscriptionPath(topicName: string, subscriptionName: string): string {\n    return topicName + \"/Subscriptions/\" + subscriptionName;\n  }\n\n  private getRulePath(topicName: string, subscriptionName: string, ruleName: string): string {\n    return topicName + \"/Subscriptions/\" + subscriptionName + \"/Rules/\" + ruleName;\n  }\n\n  private getMarkerFromNextLinkUrl(url: string): string | undefined {\n    if (!url) {\n      return undefined;\n    }\n    try {\n      const value = parseURL(url).searchParams.get(Constants.XML_METADATA_MARKER + \"skip\");\n      return value !== null ? value : undefined;\n    } catch (error: any) {\n      throw new Error(\n        `Unable to parse the '${Constants.XML_METADATA_MARKER}skip' from the next-link in the response ` +\n          error,\n      );\n    }\n  }\n\n  private buildNamespacePropertiesResponse(\n    response: FullOperationResponse,\n  ): WithResponse<NamespaceProperties> {\n    try {\n      const namespace = buildNamespace(response.parsedBody);\n      const namespaceResponse: WithResponse<NamespaceProperties> = Object.defineProperty(\n        namespace || {},\n        \"_response\",\n        { value: getHttpResponseOnly(response) },\n      ) as WithResponse<NamespaceProperties>;\n      return namespaceResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a namespace object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListQueuesResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<QueueProperties> {\n    try {\n      const queues: QueueProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawQueueArray: any = response.parsedBody;\n      for (let i = 0; i < rawQueueArray.length; i++) {\n        const queue = buildQueue(rawQueueArray[i]);\n        if (queue) {\n          queues.push(queue);\n        }\n      }\n      const listQueuesResponse: EntitiesResponse<QueueProperties> = Object.defineProperty(\n        queues,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as EntitiesResponse<QueueProperties>;\n      listQueuesResponse.continuationToken = nextMarker;\n      return listQueuesResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListQueuesRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<QueueRuntimeProperties> {\n    try {\n      const queues: QueueRuntimeProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawQueueArray: any = response.parsedBody;\n      for (let i = 0; i < rawQueueArray.length; i++) {\n        const queue = buildQueueRuntimeProperties(rawQueueArray[i]);\n        if (queue) {\n          queues.push(queue);\n        }\n      }\n      const listQueuesResponse: EntitiesResponse<QueueRuntimeProperties> = Object.defineProperty(\n        queues,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as EntitiesResponse<QueueRuntimeProperties>;\n      listQueuesResponse.continuationToken = nextMarker;\n      return listQueuesResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildQueueResponse(response: FullOperationResponse): WithResponse<QueueProperties> {\n    try {\n      const queue = buildQueue(response.parsedBody);\n      const queueResponse: WithResponse<QueueProperties> = Object.defineProperty(\n        queue || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<QueueProperties>;\n      return queueResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a queue object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildQueueRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): WithResponse<QueueRuntimeProperties> {\n    try {\n      const queue = buildQueueRuntimeProperties(response.parsedBody);\n      const queueResponse: WithResponse<QueueRuntimeProperties> = Object.defineProperty(\n        queue || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<QueueRuntimeProperties>;\n      return queueResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a queue object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListTopicsResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<TopicProperties> {\n    try {\n      const topics: TopicProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawTopicArray: any = response.parsedBody;\n      for (let i = 0; i < rawTopicArray.length; i++) {\n        const topic = buildTopic(rawTopicArray[i]);\n        if (topic) {\n          topics.push(topic);\n        }\n      }\n      const listTopicsResponse: EntitiesResponse<TopicProperties> = Object.defineProperty(\n        topics,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as EntitiesResponse<TopicProperties>;\n      listTopicsResponse.continuationToken = nextMarker;\n      return listTopicsResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListTopicsRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<TopicRuntimeProperties> {\n    try {\n      const topics: TopicRuntimeProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawTopicArray: any = response.parsedBody;\n      for (let i = 0; i < rawTopicArray.length; i++) {\n        const topic = buildTopicRuntimeProperties(rawTopicArray[i]);\n        if (topic) {\n          topics.push(topic);\n        }\n      }\n      const listTopicsResponse: EntitiesResponse<TopicRuntimeProperties> = Object.defineProperty(\n        topics,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as EntitiesResponse<TopicRuntimeProperties>;\n      listTopicsResponse.continuationToken = nextMarker;\n      return listTopicsResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n  private buildTopicResponse(response: FullOperationResponse): WithResponse<TopicProperties> {\n    try {\n      const topic = buildTopic(response.parsedBody);\n      const topicResponse: WithResponse<TopicProperties> = Object.defineProperty(\n        topic || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<TopicProperties>;\n      return topicResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a topic object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildTopicRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): WithResponse<TopicRuntimeProperties> {\n    try {\n      const topic = buildTopicRuntimeProperties(response.parsedBody);\n      const topicResponse: WithResponse<TopicRuntimeProperties> = Object.defineProperty(\n        topic || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<TopicRuntimeProperties>;\n      return topicResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a topic object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListSubscriptionsResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<SubscriptionProperties> {\n    try {\n      const subscriptions: SubscriptionProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawSubscriptionArray: any = response.parsedBody;\n      for (let i = 0; i < rawSubscriptionArray.length; i++) {\n        const subscription = buildSubscription(rawSubscriptionArray[i]);\n        if (subscription) {\n          subscriptions.push(subscription);\n        }\n      }\n      const listSubscriptionsResponse: EntitiesResponse<SubscriptionProperties> =\n        Object.defineProperty(subscriptions, \"_response\", {\n          value: getHttpResponseOnly(response),\n        }) as EntitiesResponse<SubscriptionProperties>;\n      listSubscriptionsResponse.continuationToken = nextMarker;\n      return listSubscriptionsResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListSubscriptionsRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<SubscriptionRuntimeProperties> {\n    try {\n      const subscriptions: SubscriptionRuntimeProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawSubscriptionArray: any = response.parsedBody;\n      for (let i = 0; i < rawSubscriptionArray.length; i++) {\n        const subscription = buildSubscriptionRuntimeProperties(rawSubscriptionArray[i]);\n        if (subscription) {\n          subscriptions.push(subscription);\n        }\n      }\n      const listSubscriptionsResponse: EntitiesResponse<SubscriptionRuntimeProperties> =\n        Object.defineProperty(subscriptions, \"_response\", {\n          value: getHttpResponseOnly(response),\n        }) as EntitiesResponse<SubscriptionRuntimeProperties>;\n      listSubscriptionsResponse.continuationToken = nextMarker;\n      return listSubscriptionsResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildSubscriptionResponse(\n    response: FullOperationResponse,\n  ): WithResponse<SubscriptionProperties> {\n    try {\n      const subscription = buildSubscription(response.parsedBody);\n      const subscriptionResponse: WithResponse<SubscriptionProperties> = Object.defineProperty(\n        subscription || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<SubscriptionProperties>;\n      return subscriptionResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildSubscriptionRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): WithResponse<SubscriptionRuntimeProperties> {\n    try {\n      const subscription = buildSubscriptionRuntimeProperties(response.parsedBody);\n      const subscriptionResponse: WithResponse<SubscriptionRuntimeProperties> =\n        Object.defineProperty(subscription || {}, \"_response\", {\n          value: getHttpResponseOnly(response),\n        }) as WithResponse<SubscriptionRuntimeProperties>;\n      return subscriptionResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListRulesResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<RuleProperties> {\n    try {\n      const rules: RuleProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawRuleArray: any = response.parsedBody;\n      for (let i = 0; i < rawRuleArray.length; i++) {\n        const rule = buildRule(rawRuleArray[i]);\n        if (rule) {\n          rules.push(rule);\n        }\n      }\n      const listRulesResponse: EntitiesResponse<RuleProperties> = Object.defineProperty(\n        rules,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as EntitiesResponse<RuleProperties>;\n      listRulesResponse.continuationToken = nextMarker;\n      return listRulesResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of rules using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildRuleResponse(response: FullOperationResponse): WithResponse<RuleProperties> {\n    try {\n      const rule = buildRule(response.parsedBody);\n      const ruleResponse: WithResponse<RuleProperties> = Object.defineProperty(\n        rule || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<RuleProperties>;\n      return ruleResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a rule object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private throwIfInvalidContinuationToken(token: string | undefined): void {\n    if (!(token === undefined || (typeof token === \"string\" && Number(token) >= 0))) {\n      throw new Error(`Invalid continuationToken ${token} provided`);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { message } from \"rhea-promise\";\nimport isBuffer from \"is-buffer\";\nimport { Buffer } from \"buffer\";\nimport { logErrorStackTrace, logger } from \"./log\";\n\n/** @internal */\nexport const dataSectionTypeCode = 0x75 as const;\n/** @internal */\nexport const sequenceSectionTypeCode = 0x76 as const;\n/** @internal */\nexport const valueSectionTypeCode = 0x77 as const;\n\n/**\n * Mirror of the internal Section interface in rhea.\n *\n * @internal\n */\nexport interface RheaAmqpSection {\n  typecode:\n    | typeof dataSectionTypeCode\n    | typeof sequenceSectionTypeCode\n    | typeof valueSectionTypeCode;\n  content: any;\n}\n\n/**\n * The default data transformer that will be used by the Azure SDK.\n * @internal\n */\nexport const defaultDataTransformer = {\n  /**\n   * A function that takes the body property from an EventData object\n   * and returns an encoded body (some form of AMQP type).\n   *\n   * @param body - The AMQP message body\n   * @returns The encoded AMQP message body as an AMQP Data type\n   * (data section in rhea terms). Section object with following properties:\n   * - typecode: 117 (0x75)\n   * - content: The given AMQP message body as a Buffer.\n   * - multiple: true | undefined.\n   */\n  encode(body: unknown, bodyType: \"data\" | \"value\" | \"sequence\"): any {\n    let result: any;\n    if (bodyType === \"value\") {\n      // TODO: Expose value_section from `rhea` similar to the data_section and sequence_section. Right now there isn't a way to create a value section officially.\n      result = message.data_section(body);\n      result.typecode = valueSectionTypeCode;\n    } else if (bodyType === \"sequence\") {\n      result = message.sequence_section(body);\n    } else if (isBuffer(body) || body instanceof Uint8Array) {\n      result = message.data_section(body);\n    } else {\n      // string, undefined, null, boolean, array, object, number should end up here\n      // coercing undefined to null as that will ensure that null value will be given to the\n      // customer on receive.\n      if (body === undefined) body = null; // tslint:disable-line\n      try {\n        const bodyStr = JSON.stringify(body);\n        result = message.data_section(Buffer.from(bodyStr, \"utf8\"));\n      } catch (err: any) {\n        const msg =\n          `An error occurred while executing JSON.stringify() on the given body ` +\n          body +\n          `${err ? err.stack : JSON.stringify(err)}`;\n        logger.warning(\"[encode] \" + msg);\n        logErrorStackTrace(logger, err);\n        throw new Error(msg);\n      }\n    }\n    return result;\n  },\n  /**\n   * A function that takes the body property from an AMQP message\n   * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.\n   * If it cannot decode the body then it returns the body\n   * as-is.\n   *\n   * NOTE: Use this to decode a message body when you know that the entire contents are _only_ contained\n   * in the 'data' section of the message (for instance, messages from the $mgmt link). Otherwise\n   * use 'defaultDataTransformer.decodeWithType', which can handle data coming from separate sections\n   * of the AMQP mesage.\n   *\n   * @param body - The AMQP message body\n   * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body content.\n   * @returns decoded body or the given body as-is.\n   */\n  decode(body: unknown, skipParsingBodyAsJson: boolean): unknown {\n    let actualContent = body;\n\n    if (isRheaAmqpSection(body)) {\n      actualContent = body.content;\n    }\n\n    return skipParsingBodyAsJson ? actualContent : tryToJsonDecode(actualContent);\n  },\n  /**\n   * A function that takes the body property from an AMQP message, which can come from either\n   * the 'data', 'value' or 'sequence' sections of an AMQP message.\n   *\n   * If the body is not a JSON string the the raw contents will be returned, along with the bodyType\n   * indicating which part of the AMQP message the body was decoded from.\n   *\n   * @param body - The AMQP message body as received from rhea.\n   * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body.\n   * @returns The decoded/raw body and the body type.\n   */\n  decodeWithType(\n    body: unknown | RheaAmqpSection,\n    skipParsingBodyAsJson: boolean,\n  ): { body: unknown; bodyType: \"data\" | \"sequence\" | \"value\" } {\n    try {\n      if (isRheaAmqpSection(body)) {\n        switch (body.typecode) {\n          case dataSectionTypeCode:\n            return {\n              body: skipParsingBodyAsJson ? body.content : tryToJsonDecode(body.content),\n              bodyType: \"data\",\n            };\n          case sequenceSectionTypeCode:\n            // typecode:\n            // handle sequences\n            return { body: body.content, bodyType: \"sequence\" };\n          case valueSectionTypeCode:\n            // value\n            return { body: body.content, bodyType: \"value\" };\n        }\n      } else {\n        // not sure - we have to try to infer the proper bodyType and content\n        if (isBuffer(body)) {\n          // This indicates that we are getting the AMQP described type. Let us try decoding it.\n          return { body: skipParsingBodyAsJson ? body : tryToJsonDecode(body), bodyType: \"data\" };\n        } else {\n          return { body: body, bodyType: \"value\" };\n        }\n      }\n    } catch (err: any) {\n      logger.verbose(\n        \"[decode] An error occurred while decoding the received message body. The error is: %O\",\n        err,\n      );\n      throw err;\n    }\n  },\n};\n\n/** @internal */\nexport function isRheaAmqpSection(\n  possibleSection: any | RheaAmqpSection,\n): possibleSection is RheaAmqpSection {\n  return (\n    possibleSection != null &&\n    typeof possibleSection.typecode === \"number\" &&\n    (possibleSection.typecode === dataSectionTypeCode ||\n      possibleSection.typecode === valueSectionTypeCode ||\n      possibleSection.typecode === sequenceSectionTypeCode)\n  );\n}\n\n/**\n * Attempts to decode 'body' as a JSON string. If it fails it returns body\n * verbatim.\n *\n * @param body - An AMQP message body.\n * @returns A JSON decoded object, or body if body was not a JSON string.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function tryToJsonDecode(body: any): any {\n  let processedBody = body;\n  try {\n    // Trying to stringify and JSON.parse() anything else will fail flat and we shall return\n    // the original type back\n    const bodyStr: string = processedBody.toString(\"utf8\");\n    processedBody = JSON.parse(bodyStr);\n  } catch (err: any) {\n    logger.verbose(\n      \"[decode] An error occurred while trying JSON.parse() on the received body. \" +\n        \"The error is %O\",\n      err,\n    );\n  }\n  return processedBody;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AmqpAnnotatedMessage, Constants } from \"@azure/core-amqp\";\nimport { Buffer } from \"buffer\";\nimport Long from \"long\";\nimport {\n  Delivery,\n  DeliveryAnnotations,\n  MessageAnnotations,\n  uuid_to_string,\n  Message as RheaMessage,\n} from \"rhea-promise\";\nimport { defaultDataTransformer } from \"./dataTransformer\";\nimport { messageLogger as logger } from \"./log\";\nimport { ReceiveMode } from \"./models\";\nimport { isDefined, isObjectWithProperties } from \"@azure/core-util\";\nimport { reorderLockToken } from \"./util/utils\";\n\n/**\n * @internal\n */\nexport enum DispositionType {\n  complete = \"complete\",\n  deadletter = \"deadletter\",\n  abandon = \"abandon\",\n  defer = \"defer\",\n}\n\n/**\n * @internal\n * Describes the delivery annotations for Service Bus.\n */\nexport interface ServiceBusDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * @internal\n * Describes the message annotations for Service Bus.\n */\nexport interface ServiceBusMessageAnnotations extends MessageAnnotations {\n  /**\n   * Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * Annontation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * Annotation for the message being locked until.\n   */\n  \"x-opt-locked-until\"?: Date | number;\n  /**\n   * Annotation for the message state.\n   */\n  \"x-opt-message-state\"?: number;\n}\n\n/**\n * Describes the reason and error description for dead lettering a message using the `deadLetter()`\n * method on the message received from Service Bus.\n */\nexport interface DeadLetterOptions {\n  /**\n   * The reason for deadlettering the message.\n   */\n  deadLetterReason: string;\n  /**\n   * The error description for deadlettering the message.\n   */\n  deadLetterErrorDescription: string;\n}\n\n/**\n * Describes the message to be sent to Service Bus.\n */\nexport interface ServiceBusMessage {\n  /**\n   * The message body that needs to be sent or is received.\n   * If the application receiving the message is not using this SDK,\n   * convert your body payload to a byte array or Buffer for better\n   * cross-language compatibility.\n   */\n  body: any;\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  correlationId?: string | number | Buffer;\n  /**\n   * The partition key for sending a message to a partitioned entity.\n   * Maximum length is 128 characters. For {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning | partitioned entities},\n   * setting this value enables assigning related messages to the same internal partition,\n   * so that submission sequence order is correctly recorded. The partition is chosen by a hash\n   * function over this value and cannot be chosen directly.\n   * - For session-aware entities, the `sessionId` property overrides this value.\n   * - For non partitioned entities, partition key will be ignored\n   *\n   */\n  partitionKey?: string;\n  /**\n   * The partition key for sending a message into an entity\n   * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a\n   * transfer queue in the scope of a transaction, this value selects the transfer queue partition:\n   * This is functionally equivalent to `partitionKey` property and ensures that messages are kept\n   * together and in order as they are transferred.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via | Transfers and Send Via}.\n   */\n\n  // Will be required later for implementing Transactions\n  // viaPartitionKey?: string;\n\n  /**\n   * The session identifier for a session-aware entity. Maximum\n   * length is 128 characters. For session-aware entities, this application-defined value specifies\n   * the session affiliation of the message. Messages with the same session identifier are subject\n   * to summary locking and enable exact in-order processing and demultiplexing. For\n   * session-unaware entities, this value is ignored.\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions | Message Sessions}.\n   */\n  sessionId?: string;\n  /**\n   * The session identifier augmenting the `replyTo` address.\n   * Maximum length is 128 characters. This value augments the ReplyTo information and specifies\n   * which SessionId should be set for the reply when sent to the reply entity.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  replyToSessionId?: string;\n  /**\n   * The messages time to live value. This value is the relative\n   * duration after which the message expires, starting from the instant the message has been\n   * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,\n   * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level\n   * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is\n   * silently adjusted if it does. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-expiration | Expiration}.\n   */\n  timeToLive?: number;\n  /**\n   * The application specific label. This property enables the\n   * application to indicate the purpose of the message to the receiver in a standardized. fashion,\n   * similar to an email subject line. The mapped AMQP property is \"subject\".\n   */\n  subject?: string;\n  /**\n   * The \"to\" address. This property is reserved for future use in routing\n   * scenarios and presently ignored by the broker itself. Applications can use this value in\n   * rule-driven {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding | auto-forward chaining}\n   * scenarios to indicate the intended logical destination of the message.\n   */\n  to?: string;\n  /**\n   * The address of an entity to send replies to. This optional and\n   * application-defined value is a standard way to express a reply path to the receiver of the\n   * message. When a sender expects a reply, it sets the value to the absolute or relative path of\n   * the queue or topic it expects the reply to be sent to. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  replyTo?: string;\n  /**\n   * The date and time in UTC at which the message will\n   * be enqueued. This property returns the time in UTC; when setting the property, the\n   * supplied DateTime value must also be in UTC. This value is for delayed message sending.\n   * It is utilized to delay messages sending to a specific time in the future. Message enqueuing\n   * time does not mean that the message will be sent at the same time. It will get enqueued,\n   * but the actual sending time depends on the queue's workload and its state.\n   */\n  scheduledEnqueueTimeUtc?: Date;\n  /**\n   * The application specific properties which can be\n   * used for custom message metadata.\n   */\n  applicationProperties?: { [key: string]: number | boolean | string | Date | null };\n}\n\n/**\n * @internal\n * Gets the error message for when a property on given message is not of expected type\n */\nexport function getMessagePropertyTypeMismatchError(msg: ServiceBusMessage): Error | undefined {\n  if (msg.contentType != null && typeof msg.contentType !== \"string\") {\n    return new TypeError(\"The property 'contentType' on the message must be of type 'string'\");\n  }\n\n  if (msg.subject != null && typeof msg.subject !== \"string\") {\n    return new TypeError(\"The property 'label' on the message must be of type 'string'\");\n  }\n\n  if (msg.to != null && typeof msg.to !== \"string\") {\n    return new TypeError(\"The property 'to' on the message must be of type 'string'\");\n  }\n\n  if (msg.replyTo != null && typeof msg.replyTo !== \"string\") {\n    return new TypeError(\"The property 'replyTo' on the message must be of type 'string'\");\n  }\n\n  if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== \"string\") {\n    return new TypeError(\"The property 'replyToSessionId' on the message must be of type 'string'\");\n  }\n\n  if (msg.timeToLive != null && typeof msg.timeToLive !== \"number\") {\n    return new TypeError(\"The property 'timeToLive' on the message must be of type 'number'\");\n  }\n\n  if (msg.sessionId != null && typeof msg.sessionId !== \"string\") {\n    return new TypeError(\"The property 'sessionId' on the message must be of type 'string'\");\n  }\n\n  if (\n    msg.messageId != null &&\n    typeof msg.messageId !== \"string\" &&\n    typeof msg.messageId !== \"number\" &&\n    !Buffer.isBuffer(msg.messageId)\n  ) {\n    return new TypeError(\n      \"The property 'messageId' on the message must be of type string, number or Buffer\",\n    );\n  }\n\n  if (\n    msg.correlationId != null &&\n    typeof msg.correlationId !== \"string\" &&\n    typeof msg.correlationId !== \"number\" &&\n    !Buffer.isBuffer(msg.correlationId)\n  ) {\n    return new TypeError(\n      \"The property 'correlationId' on the message must be of type string, number or Buffer\",\n    );\n  }\n  return;\n}\n\n/**\n * @internal\n * Converts given ServiceBusMessage to RheaMessage\n */\nexport function toRheaMessage(\n  msg: ServiceBusMessage | ServiceBusReceivedMessage | AmqpAnnotatedMessage,\n  encoder: Pick<typeof defaultDataTransformer, \"encode\">,\n): RheaMessage {\n  let amqpMsg: RheaMessage;\n  if (isAmqpAnnotatedMessage(msg)) {\n    amqpMsg = {\n      ...AmqpAnnotatedMessage.toRheaMessage(msg),\n      body: encoder.encode(msg.body, msg.bodyType ?? \"data\"),\n    };\n  } else {\n    let bodyType: \"data\" | \"sequence\" | \"value\" = \"data\";\n\n    if (isServiceBusReceivedMessage(msg)) {\n      /*\n       * TODO: this is a bit complicated.\n       *\n       * It seems reasonable to expect to be able to round-trip a message (ie,\n       * receive a message, and then send it again, possibly to another queue / topic).\n       * If the user does that we need to make sure to respect their original AMQP\n       * type so when the message is re - encoded we don't put 'body' into the wrong spot.\n       *\n       * The complication is that we need to decide if we're okay with respecting a field\n       * from the rawAmqpMessage, which up until now we've treated as just vestigial\n       * information on send. My hope is that the use case of \"alter the sb message in some\n       * incompatible way with the underying _rawAmqpMessage.bodyType\" is not common\n       * enough for us to try to do anything more than what I'm doing here.\n       */\n      bodyType = msg._rawAmqpMessage.bodyType ?? \"data\";\n    }\n\n    // TODO: it seems sensible that we'd also do this for AMQPAnnotated message.\n    const validationError = getMessagePropertyTypeMismatchError(msg);\n\n    if (validationError) {\n      throw validationError;\n    }\n\n    amqpMsg = {\n      body: encoder.encode(msg.body, bodyType),\n      message_annotations: {},\n    };\n\n    if (msg.timeToLive) {\n      amqpMsg.ttl = Math.min(msg.timeToLive, Constants.maxUint32Value);\n      amqpMsg.creation_time = new Date();\n      amqpMsg.absolute_expiry_time = new Date(\n        Math.min(amqpMsg.creation_time.getTime() + amqpMsg.ttl, Constants.maxAbsoluteExpiryTime),\n      );\n    }\n  }\n\n  if (isAmqpAnnotatedMessage(msg)) {\n    return amqpMsg;\n  }\n\n  if (msg.applicationProperties != null) {\n    amqpMsg.application_properties = msg.applicationProperties;\n  }\n  if (msg.contentType != null) {\n    amqpMsg.content_type = msg.contentType;\n  }\n  if (msg.sessionId != null) {\n    if (msg.sessionId.length > Constants.maxSessionIdLength) {\n      throw new Error(\n        \"Length of 'sessionId' property on the message cannot be greater than 128 characters.\",\n      );\n    }\n\n    amqpMsg.group_id = msg.sessionId;\n  }\n  if (msg.replyTo != null) {\n    amqpMsg.reply_to = msg.replyTo;\n  }\n  if (msg.to != null) {\n    amqpMsg.to = msg.to;\n  }\n  if (msg.subject != null) {\n    amqpMsg.subject = msg.subject;\n  }\n\n  updateMessageId(amqpMsg, msg.messageId);\n\n  if (msg.correlationId != null) {\n    amqpMsg.correlation_id = msg.correlationId;\n  }\n  if (msg.replyToSessionId != null) {\n    amqpMsg.reply_to_group_id = msg.replyToSessionId;\n  }\n  if (msg.partitionKey != null) {\n    if (msg.partitionKey.length > Constants.maxPartitionKeyLength) {\n      throw new Error(\n        \"Length of 'partitionKey' property on the message cannot be greater than 128 characters.\",\n      );\n    }\n    amqpMsg.message_annotations![Constants.partitionKey] = msg.partitionKey;\n  }\n\n  // Will be required later for implementing Transactions\n  // if (msg.viaPartitionKey != null) {\n  //   if (msg.viaPartitionKey.length > Constants.maxPartitionKeyLength) {\n  //     throw new Error(\n  //       \"Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters.\"\n  //     );\n  //   }\n  //   amqpMsg.message_annotations![Constants.viaPartitionKey] = msg.viaPartitionKey;\n  // }\n\n  updateScheduledTime(amqpMsg, msg.scheduledEnqueueTimeUtc);\n\n  logger.verbose(\"SBMessage to RheaMessage: %O\", amqpMsg);\n  return amqpMsg;\n}\n\n/** @internal */\nexport function updateMessageId(\n  rheaMessage: RheaMessage,\n  messageId: RheaMessage[\"message_id\"],\n): void {\n  if (messageId != null) {\n    if (typeof messageId === \"string\" && messageId.length > Constants.maxMessageIdLength) {\n      throw new Error(\n        `Length of 'messageId' property on the message cannot be greater than ${Constants.maxMessageIdLength} characters.`,\n      );\n    }\n\n    rheaMessage.message_id = messageId;\n  }\n}\n\n/** @internal */\nexport function updateScheduledTime(\n  rheaMessage: RheaMessage,\n  scheduledEnqueuedTimeUtc: Date | undefined,\n): void {\n  if (scheduledEnqueuedTimeUtc != null) {\n    rheaMessage.message_annotations = rheaMessage.message_annotations ?? {};\n    rheaMessage.message_annotations[Constants.scheduledEnqueueTime] = scheduledEnqueuedTimeUtc;\n  }\n}\n\n/**\n * Describes the message received from Service Bus during peek operations and so cannot be settled.\n */\nexport interface ServiceBusReceivedMessage extends ServiceBusMessage {\n  /**\n   * The reason for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterReason?: string;\n  /**\n   * The error description for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterErrorDescription?: string;\n  /**\n   * The lock token is a reference to the lock that is being held by the broker in\n   * `peekLock` receive mode. Locks are used internally settle messages as explained in the\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement | product documentation in more detail}\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   * @readonly\n   */\n  readonly lockToken?: string;\n  /**\n   * Number of deliveries that have been attempted for this message. The count is\n   * incremented when a message lock expires, or the message is explicitly abandoned using the\n   * `abandon()` method on the message.\n   * @readonly\n   */\n  readonly deliveryCount?: number;\n  /**\n   * The UTC instant at which the message has been accepted and stored in Service Bus.\n   * @readonly\n   */\n  readonly enqueuedTimeUtc?: Date;\n  /**\n   * The UTC instant at which the message is marked for removal and no longer available for\n   * retrieval from the entity due to expiration. This property is computed from 2 other properties\n   * on the message: `enqueuedTimeUtc` + `timeToLive`.\n   */\n  readonly expiresAtUtc?: Date;\n  /**\n   * The UTC instant until which the message is held locked in the queue/subscription.\n   * When the lock expires, the `deliveryCount` is incremented and the message is again available\n   * for retrieval.\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   */\n  lockedUntilUtc?: Date;\n  /**\n   * The original sequence number of the message. For\n   * messages that have been auto-forwarded, this property reflects the sequence number that had\n   * first been assigned to the message at its original point of submission.\n   * @readonly\n   */\n  readonly enqueuedSequenceNumber?: number;\n  /**\n   * The unique number assigned to a message by Service Bus.\n   * The sequence number is a unique 64-bit integer assigned to a message as it is accepted\n   * and stored by the broker and functions as its true identifier. For partitioned entities,\n   * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.\n   * They roll over to 0 when the 48-64 bit range is exhausted.\n   *\n   * **Max safe integer** that Javascript currently supports is `2^53 - 1`. The sequence number\n   * is an AMQP `Long` type which can be upto 64 bits long. To represent that we are using a\n   * library named {@link https://github.com/dcodeIO/long.js | long.js}. We expect customers\n   * to use the **`Long`** type exported by this library.\n   * @readonly\n   */\n  readonly sequenceNumber?: Long;\n  /**\n   * The name of the queue or subscription that this message\n   * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered\n   * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the\n   * entity in which the message was dead-lettered.\n   * @readonly\n   */\n  readonly deadLetterSource?: string;\n  /**\n   * State of the message can be active, deferred or scheduled. Deferred messages have deferred state,\n   * scheduled messages have scheduled state, all other messages have active state.\n   */\n  readonly state: \"active\" | \"deferred\" | \"scheduled\";\n  /**\n   * The underlying raw amqp message.\n   * @readonly\n   */\n  readonly _rawAmqpMessage: AmqpAnnotatedMessage;\n}\n\n/**\n * @internal\n * Converts given RheaMessage to ServiceBusReceivedMessage\n */\nexport function fromRheaMessage(\n  rheaMessage: RheaMessage,\n  options: {\n    skipParsingBodyAsJson: boolean;\n    skipConvertingDate?: boolean;\n    delivery?: Delivery;\n    shouldReorderLockToken?: boolean;\n  },\n): ServiceBusReceivedMessage {\n  if (!rheaMessage) {\n    rheaMessage = {\n      body: undefined,\n    };\n  }\n  const {\n    skipParsingBodyAsJson,\n    delivery,\n    shouldReorderLockToken,\n    skipConvertingDate = false,\n  } = options;\n  const { body, bodyType } = defaultDataTransformer.decodeWithType(\n    rheaMessage.body,\n    skipParsingBodyAsJson,\n  );\n\n  const sbmsg: ServiceBusMessage = {\n    body: body,\n  };\n\n  if (rheaMessage.application_properties != null) {\n    sbmsg.applicationProperties = skipConvertingDate\n      ? rheaMessage.application_properties\n      : convertDatesToNumbers(rheaMessage.application_properties);\n  }\n  if (rheaMessage.content_type != null) {\n    sbmsg.contentType = rheaMessage.content_type;\n  }\n  if (rheaMessage.group_id != null) {\n    sbmsg.sessionId = rheaMessage.group_id;\n  }\n  if (rheaMessage.reply_to != null) {\n    sbmsg.replyTo = rheaMessage.reply_to;\n  }\n  if (rheaMessage.to != null) {\n    sbmsg.to = rheaMessage.to;\n  }\n  if (rheaMessage.subject != null) {\n    sbmsg.subject = rheaMessage.subject;\n  }\n  if (rheaMessage.message_id != null) {\n    sbmsg.messageId = rheaMessage.message_id;\n  }\n  if (rheaMessage.correlation_id != null) {\n    sbmsg.correlationId = rheaMessage.correlation_id;\n  }\n  if (rheaMessage.reply_to_group_id != null) {\n    sbmsg.replyToSessionId = rheaMessage.reply_to_group_id;\n  }\n\n  if (rheaMessage.message_annotations != null) {\n    if (rheaMessage.message_annotations[Constants.partitionKey] != null) {\n      sbmsg.partitionKey = rheaMessage.message_annotations[Constants.partitionKey];\n    }\n\n    // Will be required later for implementing Transactions\n    // if (msg.message_annotations[Constants.viaPartitionKey] != null) {\n    //   sbmsg.viaPartitionKey = msg.message_annotations[Constants.viaPartitionKey];\n    // }\n\n    if (rheaMessage.message_annotations[Constants.scheduledEnqueueTime] != null) {\n      sbmsg.scheduledEnqueueTimeUtc =\n        rheaMessage.message_annotations[Constants.scheduledEnqueueTime];\n    }\n  }\n\n  type PartialWritable<T> = Partial<{\n    -readonly [P in keyof T]: T[P];\n  }>;\n  const props: PartialWritable<ServiceBusReceivedMessage> & {\n    state: \"active\" | \"deferred\" | \"scheduled\";\n  } = { state: \"active\" };\n  if (rheaMessage.message_annotations != null) {\n    if (rheaMessage.message_annotations[Constants.deadLetterSource] != null) {\n      props.deadLetterSource = rheaMessage.message_annotations[Constants.deadLetterSource];\n    }\n    const messageState = rheaMessage.message_annotations[Constants.messageState];\n    if (messageState === 1) {\n      props.state = \"deferred\";\n    } else if (messageState === 2) {\n      props.state = \"scheduled\";\n    }\n    if (rheaMessage.message_annotations[Constants.enqueueSequenceNumber] != null) {\n      props.enqueuedSequenceNumber =\n        rheaMessage.message_annotations[Constants.enqueueSequenceNumber];\n    }\n    if (rheaMessage.message_annotations[Constants.sequenceNumber] != null) {\n      if (Buffer.isBuffer(rheaMessage.message_annotations[Constants.sequenceNumber])) {\n        props.sequenceNumber = Long.fromBytesBE(\n          rheaMessage.message_annotations[Constants.sequenceNumber],\n        );\n      } else {\n        props.sequenceNumber = Long.fromNumber(\n          rheaMessage.message_annotations[Constants.sequenceNumber],\n        );\n      }\n    }\n    if (rheaMessage.message_annotations[Constants.enqueuedTime] != null) {\n      props.enqueuedTimeUtc = new Date(\n        rheaMessage.message_annotations[Constants.enqueuedTime] as number,\n      );\n    }\n    if (rheaMessage.message_annotations[Constants.lockedUntil] != null) {\n      props.lockedUntilUtc = new Date(\n        rheaMessage.message_annotations[Constants.lockedUntil] as number,\n      );\n    }\n  }\n\n  const rawMessage = AmqpAnnotatedMessage.fromRheaMessage(rheaMessage);\n  rawMessage.bodyType = bodyType;\n  if (rheaMessage.ttl == null) {\n    rheaMessage.ttl = rawMessage.header?.timeToLive ?? Constants.maxDurationValue;\n  }\n  if (props.enqueuedTimeUtc) {\n    props.expiresAtUtc = new Date(\n      Math.min(props.enqueuedTimeUtc.getTime() + rheaMessage.ttl, Constants.maxDurationValue),\n    );\n  }\n\n  if (rawMessage.applicationProperties) {\n    rawMessage.applicationProperties = skipConvertingDate\n      ? rawMessage.applicationProperties\n      : convertDatesToNumbers(rawMessage.applicationProperties);\n  }\n  if (rawMessage.deliveryAnnotations) {\n    rawMessage.deliveryAnnotations = skipConvertingDate\n      ? rawMessage.deliveryAnnotations\n      : convertDatesToNumbers(rawMessage.deliveryAnnotations);\n  }\n  if (rawMessage.messageAnnotations) {\n    rawMessage.messageAnnotations = skipConvertingDate\n      ? rawMessage.messageAnnotations\n      : convertDatesToNumbers(rawMessage.messageAnnotations);\n  }\n\n  if (rawMessage.header?.timeToLive) {\n    sbmsg.timeToLive = rawMessage.header.timeToLive;\n  }\n\n  const rcvdsbmsg: ServiceBusReceivedMessage = {\n    _rawAmqpMessage: rawMessage,\n    deliveryCount: rheaMessage.delivery_count,\n    lockToken:\n      delivery && delivery.tag && delivery.tag.length !== 0\n        ? uuid_to_string(\n            shouldReorderLockToken === true\n              ? reorderLockToken(\n                  typeof delivery.tag === \"string\" ? Buffer.from(delivery.tag) : delivery.tag,\n                )\n              : typeof delivery.tag === \"string\"\n                ? Buffer.from(delivery.tag)\n                : delivery.tag,\n          )\n        : undefined,\n    ...sbmsg,\n    ...props,\n    deadLetterReason: sbmsg.applicationProperties?.DeadLetterReason as string | undefined,\n    deadLetterErrorDescription: sbmsg.applicationProperties?.DeadLetterErrorDescription as\n      | string\n      | undefined,\n  };\n\n  logger.verbose(\"AmqpMessage to ServiceBusReceivedMessage: %O\", rcvdsbmsg);\n  return rcvdsbmsg;\n}\n\n/**\n * @internal\n */\nexport function isServiceBusMessage(possible: unknown): possible is ServiceBusMessage {\n  return isObjectWithProperties(possible, [\"body\"]);\n}\n\n/**\n * @internal\n */\nexport function isAmqpAnnotatedMessage(possible: unknown): possible is AmqpAnnotatedMessage {\n  return (\n    isObjectWithProperties(possible, [\"body\", \"bodyType\"]) &&\n    possible.constructor.name !== ServiceBusMessageImpl.name\n  );\n}\n\n/**\n * @internal\n */\nexport function isServiceBusReceivedMessage(\n  possible: unknown,\n): possible is ServiceBusReceivedMessage {\n  return isServiceBusMessage(possible) && \"_rawAmqpMessage\" in possible;\n}\n\n/**\n * Describes the message received from Service Bus.\n *\n * @internal\n */\nexport class ServiceBusMessageImpl implements ServiceBusReceivedMessage {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The application specific properties.\n   */\n  applicationProperties?: { [key: string]: any };\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload. The identifier\n   * is a free-form string and can reflect a GUID or an identifier derived from the application\n   * context. If enabled, the\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection | duplicate detection}\n   * identifies and removes second and further submissions of messages with the same MessageId.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  correlationId?: string | number | Buffer;\n  /**\n   * The partition key for sending a message to a\n   * partitioned entity. Maximum length is 128 characters. For {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning | partitioned entities},\n   * setting this value enables assigning related messages to the same internal partition,\n   * so that submission sequence order is correctly recorded. The partition is chosen by a hash\n   * function over this value and cannot be chosen directly. For session-aware entities,\n   * the `sessionId` property overrides this value.\n   */\n  partitionKey?: string;\n  /**\n   * The partition key for sending a message into an entity\n   * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a\n   * transfer queue in the scope of a transaction, this value selects the transfer queue partition:\n   * This is functionally equivalent to `partitionKey` property and ensures that messages are kept\n   * together and in order as they are transferred.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via | Transfers and Send Via}.\n   */\n  // Will be required later for implementing Transactions\n  // viaPartitionKey?: string;\n  /**\n   * The session identifier for a session-aware entity. Maximum\n   * length is 128 characters. For session-aware entities, this application-defined value specifies\n   * the session affiliation of the message. Messages with the same session identifier are subject\n   * to summary locking and enable exact in-order processing and demultiplexing. For\n   * session-unaware entities, this value is ignored.\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions | Message Sessions}.\n   */\n  sessionId?: string;\n  /**\n   * The session identifier augmenting the `replyTo` address.\n   * Maximum length is 128 characters. This value augments the ReplyTo information and specifies\n   * which SessionId should be set for the reply when sent to the reply entity.\n   * See {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  replyToSessionId?: string;\n  /**\n   * The messages time to live value. This value is the relative\n   * duration after which the message expires, starting from the instant the message has been\n   * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,\n   * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level\n   * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is\n   * silently adjusted if it does. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-expiration | Expiration}.\n   */\n  timeToLive?: number;\n  /**\n   * The application specific label. This property enables the\n   * application to indicate the purpose of the message to the receiver in a standardized. fashion,\n   * similar to an email subject line. The mapped AMQP property is \"subject\".\n   */\n  subject?: string;\n  /**\n   * The \"to\" address. This property is reserved for future use in routing\n   * scenarios and presently ignored by the broker itself. Applications can use this value in\n   * rule-driven {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding | auto-forward chaining}\n   * scenarios to indicate the intended logical destination of the message.\n   */\n  to?: string;\n  /**\n   * The address of an entity to send replies to. This optional and\n   * application-defined value is a standard way to express a reply path to the receiver of the\n   * message. When a sender expects a reply, it sets the value to the absolute or relative path of\n   * the queue or topic it expects the reply to be sent to. See\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  replyTo?: string;\n  /**\n   * The date and time in UTC at which the message will\n   * be enqueued. This property returns the time in UTC; when setting the property, the\n   * supplied DateTime value must also be in UTC. This value is for delayed message sending.\n   * It is utilized to delay messages sending to a specific time in the future. Message enqueuing\n   * time does not mean that the message will be sent at the same time. It will get enqueued,\n   * but the actual sending time depends on the queue's workload and its state.\n   */\n  scheduledEnqueueTimeUtc?: Date;\n  /**\n   * The lock token is a reference to the lock that is being held by the broker in\n   * `peekLock` receive mode. Locks are used internally settle messages as explained in the\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement | product documentation in more detail}\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   * @readonly\n   */\n  readonly lockToken?: string;\n  /**\n   * Number of deliveries that have been attempted for this message. The count is\n   * incremented when a message lock expires, or the message is explicitly abandoned using the\n   * `abandon()` method on the message.\n   * @readonly\n   */\n  readonly deliveryCount?: number;\n  /**\n   * The UTC instant at which the message has been accepted and stored in Service Bus.\n   * @readonly\n   */\n  readonly enqueuedTimeUtc?: Date;\n  /**\n   * The UTC instant at which the message is marked for removal and no longer available for\n   * retrieval from the entity due to expiration. This property is computed from 2 other properties\n   * on the message: `enqueuedTimeUtc` + `timeToLive`.\n   */\n  readonly expiresAtUtc?: Date;\n  /**\n   * The UTC instant until which the message is held locked in the queue/subscription.\n   * When the lock expires, the `deliveryCount` is incremented and the message is again available\n   * for retrieval.\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   */\n  lockedUntilUtc?: Date;\n  /**\n   * The original sequence number of the message. For\n   * messages that have been auto-forwarded, this property reflects the sequence number that had\n   * first been assigned to the message at its original point of submission.\n   * @readonly\n   */\n  readonly enqueuedSequenceNumber?: number;\n  /**\n   * The unique number assigned to a message by Service Bus.\n   * The sequence number is a unique 64-bit integer assigned to a message as it is accepted\n   * and stored by the broker and functions as its true identifier. For partitioned entities,\n   * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.\n   * They roll over to 0 when the 48-64 bit range is exhausted.\n   * @readonly\n   */\n  readonly sequenceNumber?: Long;\n  /**\n   * The name of the queue or subscription that this message\n   * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered\n   * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the\n   * entity in which the message was dead-lettered.\n   * @readonly\n   */\n  readonly deadLetterSource?: string;\n  /**\n   * State of the message can be active, deferred or scheduled. Deferred messages have deferred state,\n   * scheduled messages have scheduled state, all other messages have active state.\n   */\n  readonly state: \"active\" | \"deferred\" | \"scheduled\";\n  /**\n   * The associated delivery of the received message.\n   */\n  readonly delivery: Delivery;\n  /**\n   * The underlying raw amqp annotated message.\n   * @readonly\n   */\n  readonly _rawAmqpMessage: AmqpAnnotatedMessage;\n  /**\n   * The reason for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterReason?: string;\n  /**\n   * The error description for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterErrorDescription?: string;\n  /**\n   * @internal\n   */\n  constructor(\n    msg: RheaMessage,\n    delivery: Delivery,\n    shouldReorderLockToken: boolean,\n    receiveMode: ReceiveMode,\n    skipParsingBodyAsJson: boolean,\n    skipConvertingDate: boolean,\n  ) {\n    const { _rawAmqpMessage, ...restOfMessageProps } = fromRheaMessage(\n      msg,\n\n      { skipParsingBodyAsJson, delivery, shouldReorderLockToken, skipConvertingDate },\n    );\n    this._rawAmqpMessage = _rawAmqpMessage; // need to initialize _rawAmqpMessage property to make compiler happy\n    Object.assign(this, restOfMessageProps);\n    this.state = restOfMessageProps.state; // to suppress error TS2564: Property 'state' has no initializer and is not definitely assigned in the constructor.\n\n    // Lock on a message is applicable only in peekLock mode, but the service sets\n    // the lock token even in receiveAndDelete mode if the entity in question is partitioned.\n    if (receiveMode === \"receiveAndDelete\") {\n      this.lockToken = undefined;\n    }\n    this.delivery = delivery;\n  }\n\n  /**\n   * Creates a clone of the current message to allow it to be re-sent to the queue\n   * @returns ServiceBusMessage\n   */\n  clone(): ServiceBusMessage {\n    // We are returning a ServiceBusMessage object because that object can then be sent to Service Bus\n    const clone: ServiceBusMessage = {\n      body: this.body,\n      contentType: this.contentType,\n      correlationId: this.correlationId,\n      subject: this.subject,\n      messageId: this.messageId,\n      partitionKey: this.partitionKey,\n      replyTo: this.replyTo,\n      replyToSessionId: this.replyToSessionId,\n      scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,\n      sessionId: this.sessionId,\n      timeToLive: this.timeToLive,\n      to: this.to,\n      applicationProperties: this.applicationProperties,\n      // Will be required later for implementing Transactions\n      // viaPartitionKey: this.viaPartitionKey\n    };\n\n    return clone;\n  }\n}\n\n/**\n * Converts any Date objects into a number representing date.getTime().\n * Recursively checks for any Date objects in arrays and objects.\n * @internal\n */\nfunction convertDatesToNumbers<T = unknown>(thing: T): T {\n  // fast exit\n  if (!isDefined(thing)) return thing;\n\n  // When 'thing' is a Date, return the number representation\n  if (\n    typeof thing === \"object\" &&\n    isObjectWithProperties(thing, [\"getTime\"]) &&\n    typeof thing.getTime === \"function\"\n  ) {\n    return thing.getTime();\n  }\n\n  /*\n    Examples:\n    [0, 'foo', new Date(), { nested: new Date()}]\n  */\n  if (Array.isArray(thing)) {\n    const result = [];\n    for (const element of thing) {\n      result.push(convertDatesToNumbers(element));\n    }\n    return result as unknown as T;\n  }\n\n  /*\n    Examples:\n    { foo: new Date(), children: { nested: new Date() }}\n  */\n  if (typeof thing === \"object\" && isDefined<object>(thing)) {\n    const thingShallowCopy = { ...thing };\n    for (const key of Object.keys(thingShallowCopy)) {\n      (thingShallowCopy as any)[key] = convertDatesToNumbers((thingShallowCopy as any)[key]);\n    }\n    return thingShallowCopy;\n  }\n\n  return thing;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Constants,\n  TokenType,\n  defaultCancellableLock,\n  RequestResponseLink,\n  StandardAbortMessage,\n  isSasTokenProvider,\n} from \"@azure/core-amqp\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport {\n  AwaitableSender,\n  AwaitableSenderOptions,\n  generate_uuid,\n  Receiver,\n  ReceiverOptions,\n  SenderOptions,\n} from \"rhea-promise\";\nimport { getUniqueName } from \"../util/utils\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { ServiceBusLogger } from \"../log\";\nimport { ServiceBusError } from \"../serviceBusError\";\n\n/**\n * @internal\n * Options passed to the constructor of LinkEntity\n */\nexport interface LinkEntityOptions {\n  /**\n   * The client entity address in one of the following forms:\n   */\n  address?: string;\n  /**\n   * The client entity token audience in one of the following forms:\n   */\n  audience?: string;\n}\n\n/**\n * A simple grouping of the sender and receiver options. Only used\n * with the ManagementClient today.\n *\n * @internal\n */\nexport interface RequestResponseLinkOptions {\n  senderOptions: SenderOptions;\n  receiverOptions: ReceiverOptions;\n  name?: string;\n}\n\n/**\n * @internal\n */\nexport type NonSessionReceiverType =\n  | \"batching\" // batching receiver\n  | \"streaming\"; // streaming receiver\n\n/**\n * @internal\n */\nexport type ReceiverType = NonSessionReceiverType | \"session\"; // message session\n\n/**\n * @internal\n */\ntype LinkOptionsT<LinkT extends Receiver | AwaitableSender | RequestResponseLink> =\n  LinkT extends Receiver\n    ? ReceiverOptions\n    : LinkT extends AwaitableSender\n      ? AwaitableSenderOptions\n      : LinkT extends RequestResponseLink\n        ? RequestResponseLinkOptions\n        : never;\n\n/**\n * @internal\n */\ntype LinkTypeT<LinkT extends Receiver | AwaitableSender | RequestResponseLink> =\n  LinkT extends Receiver\n    ? ReceiverType\n    : LinkT extends AwaitableSender\n      ? \"sender\" // sender\n      : LinkT extends RequestResponseLink\n        ? \"mgmt\" // management link\n        : never;\n\n/**\n * @internal\n * Describes the base class for entities like MessageSender, MessageReceiver and Management client.\n */\nexport abstract class LinkEntity<LinkT extends Receiver | AwaitableSender | RequestResponseLink> {\n  /**\n   * The unique name for the entity in the format:\n   * `${name of the entity}-${guid}`.\n   */\n  name: string;\n  /**\n   * The client entity address in one of the following forms:\n   *\n   * **Sender**\n   * - `\"<queue-name>\"`.\n   * - `\"<topic-name>\"`.\n   *\n   * **Receiver**\n   * - `\"<queue-name>\"`.\n   * - `\"<topic-name>\"`.\n   *\n   * **ManagementClient**\n   * -`\"$management\"`.\n   */\n  address: string;\n  /**\n   * The client entity token audience in one of the following forms:\n   *\n   * **Sender**\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<queue-name>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<topic-name>\"`\n   *\n   * **Receiver**\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<queue-name>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<topic-name>\"`\n   *\n   * **ManagementClient**\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management\"`.\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management\"`.\n   */\n  audience: string;\n  /**\n   * Provides relevant information about the amqp connection,\n   * cbs and $management sessions, token provider, sender and receivers.\n   */\n  protected _context: ConnectionContext;\n  /**\n   * The token renewal timer that keeps track of when\n   * the Client Entity is due for token renewal.\n   */\n  private _tokenRenewalTimer?: NodeJS.Timeout;\n  /**\n   * Indicates token timeout\n   */\n  protected _tokenTimeout?: number;\n\n  /**\n   * The actual rhea link (of type Receiver or AwaitableSender) or RequestResponseLink\n   */\n  private _link?: LinkT;\n\n  /**\n   * The log prefix for any log messages.\n   */\n  private _logPrefix: string;\n\n  public get logPrefix(): string {\n    return this._logPrefix;\n  }\n\n  /**\n   * Indicates that close() has been called on this link and\n   * that it should not be allowed to reopen.\n   */\n  private _wasClosedPermanently: boolean = false;\n\n  /**\n   * A lock that ensures that opening and closing this\n   * link properly cooperate.\n   */\n  private _openLock: string = `linkEntity-${generate_uuid()}`;\n\n  /**\n   * Creates a new ClientEntity instance.\n   * @param baseName - The base name to use for the link. A unique ID will be appended to this.\n   * @param entityPath - The entity path (ex: 'your-queue')\n   * @param context - The connection context.\n   * @param options - Options that can be provided while creating the LinkEntity.\n   */\n  constructor(\n    public readonly baseName: string,\n    public readonly entityPath: string,\n    context: ConnectionContext,\n    private _linkType: LinkTypeT<LinkT>,\n    private _logger: ServiceBusLogger,\n    options?: LinkEntityOptions,\n  ) {\n    if (!options) options = {};\n    this._context = context;\n    this.address = options.address || \"\";\n    this.audience = options.audience || \"\";\n    this.name = getUniqueName(baseName);\n    this._logPrefix = `[${context.connectionId}|${this._linkType}:${this.name}]`;\n  }\n\n  /**\n   * Determines whether the AMQP link is open. If open then returns true else returns false.\n   */\n  isOpen(): boolean {\n    const result: boolean = this._link ? this._link.isOpen() : false;\n    this._logger.verbose(`${this._logPrefix} is open? ${result}`);\n    return result;\n  }\n\n  /**\n   * Initializes this LinkEntity, setting this._link with the result of  `createRheaLink`, which\n   * is implemented by child classes.\n   *\n   * @returns A Promise that resolves when the link has been properly initialized\n   * @throws `AbortError` if the link has been closed via 'close'\n   */\n  async initLink(options: LinkOptionsT<LinkT>, abortSignal?: AbortSignalLike): Promise<void> {\n    // we'll check that the connection isn't in the process of recycling (and if so, wait for it to complete)\n    await this._context.readyToOpenLink();\n\n    this._logger.verbose(\n      `${this._logPrefix} Attempting to acquire lock token ${this._openLock} for initializing link`,\n    );\n    return defaultCancellableLock.acquire(\n      this._openLock,\n      () => {\n        this._logger.verbose(\n          `${this._logPrefix} Lock ${this._openLock} acquired for initializing link`,\n        );\n        return this._initLinkImpl(options, abortSignal);\n      },\n      {\n        abortSignal: abortSignal,\n        timeoutInMs: Constants.defaultOperationTimeoutInMs,\n      },\n    );\n  }\n\n  private async _initLinkImpl(\n    options: LinkOptionsT<LinkT>,\n    abortSignal?: AbortSignalLike,\n  ): Promise<void> {\n    const checkAborted = (): void => {\n      if (abortSignal?.aborted) {\n        this._link?.close();\n        throw new AbortError(StandardAbortMessage);\n      }\n    };\n\n    const connectionId = this._context.connectionId;\n    checkAborted();\n\n    if (options.name) {\n      this.name = options.name;\n      this._logPrefix = `[${connectionId}|${this._linkType}:${this.name}]`;\n    }\n\n    if (this._wasClosedPermanently) {\n      this._logger.verbose(`${this._logPrefix} Link has been permanently closed. Not reopening.`);\n      throw new AbortError(`Link has been permanently closed. Not reopening.`);\n    }\n\n    if (this.isOpen()) {\n      this._logger.verbose(`${this._logPrefix} Link is already open. Returning.`);\n      return;\n    }\n\n    this._logger.verbose(\n      `${this._logPrefix} Is not open and is not currently connecting. Opening.`,\n    );\n\n    try {\n      await this._negotiateClaim({\n        abortSignal,\n        setTokenRenewal: false,\n        timeoutInMs: Constants.defaultOperationTimeoutInMs,\n      });\n\n      checkAborted();\n      this.checkIfConnectionReady();\n\n      this._logger.verbose(`${this._logPrefix} Creating with options %O`, options);\n      this._link = await this.createRheaLink(options);\n      checkAborted();\n\n      this._ensureTokenRenewal();\n\n      this._logger.verbose(`${this._logPrefix} Link has been created.`);\n    } catch (err: any) {\n      this._logger.logError(err, `${this._logPrefix} Error thrown when creating the link`);\n      await this.closeLinkImpl();\n      throw err;\n    }\n  }\n\n  /**\n   * Clears token renewal for current link, removes current LinkEntity instance from cache,\n   * and closes the underlying AMQP link.\n   * Once closed, this instance of LinkEntity is not meant to be re-used.\n   */\n  async close(): Promise<void> {\n    // Set the flag to indicate that this instance of LinkEntity is not meant to be re-used.\n    this._wasClosedPermanently = true;\n\n    this._logger.verbose(`${this.logPrefix} permanently closing this link.`);\n\n    this.removeLinkFromContext();\n\n    await this.closeLink();\n    this._logger.verbose(`${this.logPrefix} permanently closed this link.`);\n  }\n\n  /**\n   * NOTE: This method should be implemented by any child classes to actually create the underlying\n   * Rhea link (AwaitableSender or Receiver or RequestResponseLink)\n   *\n   */\n  protected abstract createRheaLink(_options: LinkOptionsT<LinkT>): Promise<LinkT>;\n\n  /**\n   * Clears this link from context's link cache.\n   */\n  protected abstract removeLinkFromContext(): void;\n\n  /**\n   * Closes the internally held rhea link, stops the token renewal timer and sets\n   * the this._link field to undefined.\n   */\n  protected closeLink(): Promise<void> {\n    this._logger.verbose(\n      `${this._logPrefix} Attempting to acquire lock token ${this._openLock} for closing link`,\n    );\n    return defaultCancellableLock.acquire(\n      this._openLock,\n      () => {\n        this._logger.verbose(`${this._logPrefix} Lock ${this._openLock} acquired for closing link`);\n        return this.closeLinkImpl();\n      },\n      { abortSignal: undefined, timeoutInMs: undefined },\n    );\n  }\n\n  private async closeLinkImpl(): Promise<void> {\n    this._logger.verbose(`${this._logPrefix} closeLinkImpl() called`);\n\n    clearTimeout(this._tokenRenewalTimer as NodeJS.Timeout);\n    this._tokenRenewalTimer = undefined;\n\n    if (this._link) {\n      try {\n        const link = this._link;\n        this._link = undefined;\n\n        // This should take care of closing the link and it's underlying session. This should also\n        // remove them from the internal map.\n        await link.close();\n        this._logger.verbose(`${this._logPrefix} closed.`);\n      } catch (err: any) {\n        this._logger.logError(err, `${this._logPrefix} An error occurred while closing the link`);\n      }\n    }\n  }\n\n  /**\n   * Provides the current type of the ClientEntity.\n   * @returns The entity type.\n   */\n  private get _type(): string {\n    let result = \"LinkEntity\";\n    if ((this as any).constructor && (this as any).constructor.name) {\n      result = (this as any).constructor.name;\n    }\n    return result;\n  }\n\n  protected get wasClosedPermanently(): boolean {\n    return this._wasClosedPermanently;\n  }\n\n  protected get link(): LinkT | undefined {\n    return this._link;\n  }\n\n  /**\n   * Negotiates the cbs claim for the ClientEntity.\n   * @param setTokenRenewal - Set the token renewal timer. Default false.\n   */\n  private async _negotiateClaim({\n    abortSignal,\n    setTokenRenewal,\n    timeoutInMs,\n  }: {\n    setTokenRenewal: boolean;\n    abortSignal: AbortSignalLike | undefined;\n    timeoutInMs: number;\n  }): Promise<void> {\n    this._logger.verbose(`${this._logPrefix} negotiateclaim() has been called`);\n\n    // Wait for the connectionContext to be ready to open the link.\n    this.checkIfConnectionReady();\n\n    // Acquire the lock and establish a cbs session if it does not exist on the connection.\n    // Although node.js is single threaded, we need a locking mechanism to ensure that a\n    // race condition does not happen while creating a shared resource (in this case the\n    // cbs session, since we want to have exactly 1 cbs session per connection).\n    this._logger.verbose(\n      \"%s Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: \" +\n        \"'%s' with address: '%s'.\",\n      this.logPrefix,\n      this._context.cbsSession.cbsLock,\n      this._type,\n      this.name,\n      this.address,\n    );\n\n    const startTime = Date.now();\n    if (!this._context.cbsSession.isOpen()) {\n      await defaultCancellableLock.acquire(\n        this._context.cbsSession.cbsLock,\n        () => {\n          this.checkIfConnectionReady();\n          return this._context.cbsSession.init({ abortSignal, timeoutInMs });\n        },\n        {\n          abortSignal,\n          timeoutInMs: timeoutInMs - (Date.now() - startTime),\n        },\n      );\n    }\n\n    let tokenObject: AccessToken;\n    let tokenType: TokenType;\n    if (isSasTokenProvider(this._context.tokenCredential)) {\n      tokenObject = await this._context.tokenCredential.getToken(this.audience);\n      tokenType = TokenType.CbsTokenTypeSas;\n\n      // renew sas token in every 45 minutes\n      this._tokenTimeout = (3600 - 900) * 1000;\n    } else {\n      const aadToken = await this._context.tokenCredential.getToken(Constants.aadServiceBusScope);\n      if (!aadToken) {\n        throw new Error(`Failed to get token from the provided \"TokenCredential\" object`);\n      }\n      tokenObject = aadToken;\n      tokenType = TokenType.CbsTokenTypeJwt;\n      this._tokenTimeout = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;\n    }\n    this._logger.verbose(\n      \"%s %s: calling negotiateClaim for audience '%s'.\",\n      this.logPrefix,\n      this._type,\n      this.audience,\n    );\n    // Acquire the lock to negotiate the CBS claim.\n    this._logger.verbose(\n      \"%s Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.\",\n      this.logPrefix,\n      this._context.negotiateClaimLock,\n      this._type,\n      this.name,\n      this.address,\n    );\n    if (!tokenObject) {\n      throw new Error(\"Token cannot be null\");\n    }\n    await defaultCancellableLock.acquire(\n      this._context.negotiateClaimLock,\n      () => {\n        this.checkIfConnectionReady();\n        return this._context.cbsSession.negotiateClaim(\n          this.audience,\n          tokenObject.token,\n          tokenType,\n          {\n            abortSignal,\n            timeoutInMs: timeoutInMs - (Date.now() - startTime),\n          },\n        );\n      },\n      {\n        abortSignal,\n        timeoutInMs: timeoutInMs - (Date.now() - startTime),\n      },\n    );\n    this._logger.verbose(\n      \"%s Negotiated claim for %s '%s' with with address: %s\",\n      this.logPrefix,\n      this._type,\n      this.name,\n      this.address,\n    );\n    if (setTokenRenewal) {\n      this._ensureTokenRenewal();\n    }\n  }\n\n  /**\n   * Checks to see if the connection is in a \"reopening\" state. If it is\n   * we need to _not_ use it otherwise we'll trigger some race conditions\n   * within rhea (for instance, errors about _process not being defined).\n   */\n  private checkIfConnectionReady(): void {\n    if (!this._context.isConnectionClosing()) {\n      return;\n    }\n\n    this._logger.verbose(\n      `${this._logPrefix} Connection is reopening, aborting link initialization.`,\n    );\n    const err = new ServiceBusError(\n      \"Connection is reopening, aborting link initialization.\",\n      \"GeneralError\",\n    );\n    err.retryable = true;\n    throw err;\n  }\n\n  /**\n   * Ensures that the token is renewed within the predefined renewal margin.\n   */\n  private _ensureTokenRenewal(): void {\n    if (!this._tokenTimeout) {\n      return;\n    }\n    // Clear the existing token renewal timer.\n    // This scenario can happen if the connection goes down and is brought back up\n    // before the `nextRenewalTimeout` was reached.\n    if (this._tokenRenewalTimer) {\n      clearTimeout(this._tokenRenewalTimer);\n    }\n    this._tokenRenewalTimer = setTimeout(async () => {\n      try {\n        await this._negotiateClaim({\n          setTokenRenewal: true,\n          abortSignal: undefined,\n          timeoutInMs: Constants.defaultOperationTimeoutInMs,\n        });\n      } catch (err: any) {\n        this._logger.logError(\n          err,\n          \"%s %s '%s' with address %s, an error occurred while renewing the token\",\n          this.logPrefix,\n          this._type,\n          this.name,\n          this.address,\n        );\n      }\n    }, this._tokenTimeout);\n    this._logger.verbose(\n      \"%s %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).\",\n      this.logPrefix,\n      this._type,\n      this.name,\n      this.address,\n      this._tokenTimeout,\n      new Date(Date.now() + this._tokenTimeout).toString(),\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport Long from \"long\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { logger, receiverLogger } from \"../log\";\nimport { ReceiveMode } from \"../models\";\nimport {\n  isAmqpAnnotatedMessage,\n  isServiceBusMessage,\n  ServiceBusReceivedMessage,\n} from \"../serviceBusMessage\";\nimport { isDefined } from \"@azure/core-util\";\n\n/**\n * Error message to use when EntityPath in connection string does not match the\n * queue or topic name passed to the methods in the ServiceBusClient that create\n * senders and receivers.\n *\n * @internal\n */\nexport const entityPathMisMatchError =\n  \"The queue or topic name provided does not match the EntityPath in the connection string passed to the ServiceBusClient constructor.\";\n\n/**\n * Error message for when maxMessageCount provided is invalid.\n *\n * @internal\n */\nexport const InvalidMaxMessageCountError = \"'maxMessageCount' must be a number greater than 0.\";\n\n/**\n * @internal\n * Logs and throws Error if the current AMQP connection is closed.\n * @param context - The ConnectionContext associated with the current AMQP connection.\n */\nexport function throwErrorIfConnectionClosed(context: ConnectionContext): void {\n  if (context && context.wasConnectionCloseCalled) {\n    const errorMessage = \"The underlying AMQP connection is closed.\";\n    const error = new Error(errorMessage);\n    logger.warning(`[${context.connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Gets the error message when a sender is used when its already closed\n * @param entityPath - Value of the `entityPath` property on the client which denotes its name\n */\nexport function getSenderClosedErrorMsg(entityPath: string): string {\n  return (\n    `The sender for \"${entityPath}\" has been closed and can no longer be used. ` +\n    `Please create a new sender using the \"createSender\" method on the ServiceBusClient.`\n  );\n}\n\n/**\n * @internal\n * Gets the error message when a receiver is used when its already closed\n * @param entityPath - Value of the `entityPath` property on the client which denotes its name\n * @param sessionId - If using session receiver, then the id of the session\n */\nexport function getReceiverClosedErrorMsg(entityPath: string, sessionId?: string): string {\n  if (!isDefined(sessionId)) {\n    return (\n      `The receiver for \"${entityPath}\" has been closed and can no longer be used. ` +\n      `Please create a new receiver using the \"createReceiver\" method on the ServiceBusClient.`\n    );\n  }\n  return (\n    `The receiver for session \"${sessionId}\" in \"${entityPath}\" has been closed and can no ` +\n    `longer be used. Please create a new receiver using the \"acceptSession\" or \"acceptNextSession\" method on the ServiceBusClient.`\n  );\n}\n\n/**\n * @internal\n * @param entityPath - Value of the `entityPath` property on the client which denotes its name\n * @param sessionId - If using session receiver, then the id of the session\n */\nexport function getAlreadyReceivingErrorMsg(entityPath: string, sessionId?: string): string {\n  if (!isDefined(sessionId)) {\n    return `The receiver for \"${entityPath}\" is already receiving messages.`;\n  }\n  return `The receiver for session \"${sessionId}\" for \"${entityPath}\" is already receiving messages.`;\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is undefined or null\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to check\n * @param parameterValue - Value of the parameter to check\n */\nexport function throwTypeErrorIfParameterMissing(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: unknown,\n): void {\n  if (parameterValue === undefined || parameterValue === null) {\n    const error = new TypeError(`Missing parameter \"${parameterName}\"`);\n    logger.warning(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not an instance of expected type\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to type check\n * @param parameterValue - Value of the parameter to type check\n * @param constructor - Constructor function of the expected parameter type\n */\nexport function throwTypeErrorIfNotInstanceOfParameterType(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: unknown,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  constructor: Function,\n): void {\n  if (!(parameterValue instanceof constructor)) {\n    const error = new TypeError(\n      `The parameter \"${parameterName}\" should be an instance of \"${constructor.name}\"`,\n    );\n    logger.warning(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not of expected type\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to type check\n * @param parameterValue - Value of the parameter to type check\n * @param expectedType - Expected type of the parameter\n */\nexport function throwTypeErrorIfParameterTypeMismatch(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: unknown,\n  expectedType: string,\n): void {\n  if (typeof parameterValue !== expectedType) {\n    const error = new TypeError(\n      `The parameter \"${parameterName}\" should be of type \"${expectedType}\"`,\n    );\n    logger.warning(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not of type `Long` or an array of type `Long`\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to type check\n * @param parameterValue - Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterNotLong(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: unknown,\n): TypeError | undefined {\n  if (Array.isArray(parameterValue)) {\n    return throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue);\n  }\n  if (Long.isLong(parameterValue)) {\n    return;\n  }\n  const error = new TypeError(`The parameter \"${parameterName}\" should be of type \"Long\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not an array of type `Long`\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to type check\n * @param parameterValue - Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterNotLongArray(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any[],\n): TypeError | undefined {\n  if (parameterValue.every((item) => Long.isLong(item))) {\n    return;\n  }\n  const error = new TypeError(`The parameter \"${parameterName}\" should be an array of type \"Long\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is an empty string\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to type check\n * @param parameterValue - Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterIsEmptyString(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: string,\n): TypeError | undefined {\n  if (parameterValue !== \"\") {\n    return;\n  }\n  const error = new TypeError(`Empty string not allowed in parameter \"${parameterName}\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * The error message for operations on the receiver that are invalid for a message received in receiveAndDelete mode.\n */\nexport const InvalidOperationInReceiveAndDeleteMode =\n  \"The operation is not supported in 'receiveAndDelete' receive mode.\";\n\n/**\n * @internal\n * The error message for operations on the receiver that are invalid for a peeked message.\n */\nexport const InvalidOperationForPeekedMessage =\n  \"This operation is not supported for peeked messages. Only messages received using 'receiveMessages()', 'subscribe()' and 'getMessageIterator()' methods on the receiver in 'peekLock' receive mode can be settled.\";\n\n/**\n * @internal\n * The error message for when one attempts to settle an already settled message.\n */\nexport const MessageAlreadySettled = \"The message has either been deleted or already settled\";\n\n/**\n * Throws error if the ServiceBusReceivedMessage cannot be settled.\n * @internal\n */\nexport function throwErrorIfInvalidOperationOnMessage(\n  message: ServiceBusReceivedMessage,\n  receiveMode: ReceiveMode,\n  connectionId: string,\n): void {\n  let error: Error | undefined;\n\n  if (receiveMode === \"receiveAndDelete\") {\n    error = new Error(InvalidOperationInReceiveAndDeleteMode);\n  } else if (!message.lockToken) {\n    error = new Error(InvalidOperationForPeekedMessage);\n  }\n\n  if (error) {\n    receiverLogger.logError(\n      error,\n      \"[%s] An error occurred for message with id '%s'\",\n      connectionId,\n      message.messageId,\n    );\n    throw error;\n  }\n}\n\n/**\n * Error message for when the ServiceBusMessage provided by the user has different values\n * for partitionKey and sessionId.\n * @internal\n */\nexport const PartitionKeySessionIdMismatchError =\n  \"The fields 'partitionKey' and 'sessionId' cannot have different values.\";\n/**\n * Throws error if the given object is not a valid ServiceBusMessage\n * @internal\n * @param msg - The object that needs to be validated as a ServiceBusMessage\n * @param errorMessageForWrongType - The error message to use when given object is not a ServiceBusMessage\n */\nexport function throwIfNotValidServiceBusMessage(\n  msg: unknown,\n  errorMessageForWrongType: string,\n): void {\n  if (!isServiceBusMessage(msg) && !isAmqpAnnotatedMessage(msg)) {\n    throw new TypeError(errorMessageForWrongType);\n  }\n\n  if (isServiceBusMessage(msg)) {\n    if (msg.partitionKey && msg.sessionId && msg.partitionKey !== msg.sessionId) {\n      throw new TypeError(PartitionKeySessionIdMismatchError);\n    }\n  }\n}\n\n/** @internal */\nexport const errorInvalidMessageTypeSingleOrArray =\n  \"Provided value for 'messages' must be of type: ServiceBusMessage, AmqpAnnotatedMessage, ServiceBusMessageBatch or an array of type ServiceBusMessage or AmqpAnnotatedMessage.\";\n\n/** @internal */\nexport const errorInvalidMessageTypeSingle =\n  \"Provided value for 'message' must be of type: ServiceBusMessage or AmqpAnnotatedMessage.\";\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport Long from \"long\";\nimport {\n  EventContext,\n  ReceiverOptions,\n  message as RheaMessageUtil,\n  SenderOptions,\n  generate_uuid,\n  string_to_uuid,\n  types,\n  Typed,\n  ReceiverEvents,\n  Message as RheaMessage,\n} from \"rhea-promise\";\nimport {\n  ConditionErrorNameMapper,\n  Constants,\n  defaultCancellableLock,\n  MessagingError,\n  RequestResponseLink,\n  SendRequestOptions,\n  RetryOptions,\n  AmqpAnnotatedMessage,\n} from \"@azure/core-amqp\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport {\n  DispositionType,\n  ServiceBusReceivedMessage,\n  ServiceBusMessage,\n  ServiceBusMessageImpl,\n  toRheaMessage,\n  fromRheaMessage,\n  updateScheduledTime,\n  updateMessageId,\n} from \"../serviceBusMessage\";\nimport { LinkEntity, RequestResponseLinkOptions } from \"./linkEntity\";\nimport { managementClientLogger, receiverLogger, senderLogger, ServiceBusLogger } from \"../log\";\nimport { toBuffer, waitForSendable } from \"../util/utils\";\nimport {\n  InvalidMaxMessageCountError,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterIsEmptyString,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwTypeErrorIfParameterTypeMismatch,\n} from \"../util/errors\";\nimport { max32BitNumber } from \"../util/constants\";\nimport { Buffer } from \"buffer\";\nimport { OperationOptionsBase } from \"./../modelsToBeSharedWithEventHubs\";\nimport { AbortController, AbortSignalLike } from \"@azure/abort-controller\";\nimport { ReceiveMode } from \"../models\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { defaultDataTransformer, tryToJsonDecode } from \"../dataTransformer\";\nimport { delay, isDefined, isObjectWithProperties } from \"@azure/core-util\";\nimport {\n  RuleProperties,\n  SqlRuleAction,\n  SqlRuleFilter,\n} from \"../serializers/ruleResourceSerializer\";\nimport { ListRequestOptions } from \"../serviceBusAtomManagementClient\";\n\n/**\n * @internal\n */\nexport interface SendManagementRequestOptions extends SendRequestOptions {\n  /**\n   * The name of the sender or receiver link associated with the managmenet operations.\n   * This is used for service side optimization.\n   */\n  associatedLinkName?: string;\n  /**\n   * Option to disable the client from running JSON.parse() on the message body when receiving the message.\n   * Not applicable if the message was sent with AMQP body type value or sequence. Use this option when you\n   * prefer to work directly with the bytes present in the message body than have the client attempt to parse it.\n   */\n  skipParsingBodyAsJson?: boolean;\n  /**\n   * Whether to skip converting Date type on properties of message annotations\n   * or application properties into numbers when receiving the message. By\n   * default, properties of Date type is converted into UNIX epoch number for\n   * compatibility.\n   */\n  skipConvertingDate?: boolean;\n}\n\n/**\n * Represents the correlation filter expression.\n * A CorrelationRuleFilter holds a set of conditions that are matched against user and system properties\n * of incoming messages from a Subscription.\n */\nexport interface CorrelationRuleFilter {\n  /**\n   * Value to be matched with the `correlationId` property of the incoming message.\n   */\n  correlationId?: string;\n  /**\n   * Value to be matched with the `messageId` property of the incoming message.\n   */\n  messageId?: string;\n  /**\n   * Value to be matched with the `to` property of the incoming message.\n   */\n  to?: string;\n  /**\n   * Value to be matched with the `replyTo` property of the incoming message.\n   */\n  replyTo?: string;\n  /**\n   * Value to be matched with the `subject` property of the incoming message.\n   */\n  subject?: string;\n  /**\n   * Value to be matched with the `sessionId` property of the incoming message.\n   */\n  sessionId?: string;\n  /**\n   * Value to be matched with the `replyToSessionId` property of the incoming message.\n   */\n  replyToSessionId?: string;\n  /**\n   * Value to be matched with the `contentType` property of the incoming message.\n   */\n  contentType?: string;\n  /**\n   * Value to be matched with the user properties of the incoming message.\n   */\n  applicationProperties?: { [key: string]: string | number | boolean | Date };\n}\n\n/**\n * @internal\n */\nconst sqlRuleProperties = [\"sqlExpression\"];\n\nfunction isSqlRuleFilter(obj: unknown): obj is SqlRuleFilter {\n  if (obj) {\n    return sqlRuleProperties.some((validProperty) => isObjectWithProperties(obj, [validProperty]));\n  }\n\n  return false;\n}\n\n/**\n * @internal\n */\nconst correlationProperties = [\n  \"correlationId\",\n  \"messageId\",\n  \"to\",\n  \"replyTo\",\n  \"subject\",\n  \"sessionId\",\n  \"replyToSessionId\",\n  \"contentType\",\n  \"applicationProperties\",\n];\n\nfunction isCorrelationRuleFilter(obj: unknown): obj is CorrelationRuleFilter {\n  if (obj) {\n    return correlationProperties.some((validProperty) =>\n      isObjectWithProperties(obj, [validProperty]),\n    );\n  }\n\n  return false;\n}\n\n/**\n * @internal\n * Options to set when updating the disposition status\n */\nexport interface DispositionStatusOptions extends OperationOptionsBase {\n  /**\n   * A map of Service Bus brokered message properties\n   * to modify.\n   */\n  propertiesToModify?: { [key: string]: any };\n  /**\n   * The deadletter reason. May be set if disposition status\n   * is set to suspended.\n   */\n  deadLetterReason?: string;\n  /**\n   * The deadletter description. May be set if disposition status\n   * is set to suspended.\n   */\n  deadLetterDescription?: string;\n  /**\n   * This should only be provided if `session` is enabled for a Queue or Topic.\n   */\n  sessionId?: string;\n  /**\n   * Retry options.\n   */\n  retryOptions: RetryOptions | undefined;\n}\n\n/**\n * @internal\n * Options passed to the constructor of ManagementClient\n */\nexport interface ManagementClientOptions {\n  address?: string;\n  audience?: string;\n}\n\n/**\n * @internal\n * Describes the ServiceBus Management Client that talks\n * to the $management endpoint over AMQP connection.\n */\nexport class ManagementClient extends LinkEntity<RequestResponseLink> {\n  /**\n   * The reply to Guid for the management client.\n   */\n  replyTo: string = generate_uuid();\n  /**\n   * Provides the sequence number of the last peeked message.\n   */\n  private _lastPeekedSequenceNumber: Long = Long.ZERO;\n  /**\n   * lock token for init operation\n   */\n  private _initLock: string = `initMgmtLink-${generate_uuid()}`;\n  /**\n   * Instantiates the management client.\n   * @param context - The connection context\n   * @param entityPath - The name/path of the entity (queue/topic/subscription name)\n   * for which the management request needs to be made.\n   * @param options - Options to be provided for creating the\n   * \"$management\" client.\n   */\n  constructor(context: ConnectionContext, entityPath: string, options?: ManagementClientOptions) {\n    super(`${entityPath}/$management`, entityPath, context, \"mgmt\", managementClientLogger, {\n      address: options && options.address ? options.address : Constants.management,\n      audience:\n        options && options.audience\n          ? options.audience\n          : `${context.config.endpoint}${entityPath}/$management`,\n    });\n    this._context = context;\n  }\n\n  /**\n   * initialize link with unique this.replyTo address.\n   * @param options -\n   * @returns updated options bag that has adjusted `timeoutInMs` to account for init time\n   */\n  private async initWithUniqueReplyTo(\n    options: SendManagementRequestOptions = {},\n  ): Promise<SendManagementRequestOptions> {\n    const retryTimeoutInMs = options.timeoutInMs ?? Constants.defaultOperationTimeoutInMs;\n    const initOperationStartTime = Date.now();\n    return defaultCancellableLock.acquire(\n      this._initLock,\n      async () => {\n        managementClientLogger.verbose(\n          `${this.logPrefix} lock acquired for initializing replyTo address and link`,\n        );\n        if (!this.isOpen()) {\n          this.replyTo = generate_uuid();\n          managementClientLogger.verbose(\n            `${this.logPrefix} new replyTo address: ${this.replyTo} generated`,\n          );\n        }\n        const { abortSignal } = options ?? {};\n        const aborter = new AbortController();\n        const { signal } = new AbortController([\n          aborter.signal,\n          ...(abortSignal ? [abortSignal] : []),\n        ]);\n\n        if (!this.isOpen()) {\n          await Promise.race([\n            this._init(signal),\n            delay(retryTimeoutInMs, { abortSignal: aborter.signal }).then(() => {\n              throw {\n                name: \"OperationTimeoutError\",\n                message: \"The management request timed out. Please try again later.\",\n              };\n            }),\n          ]).finally(() => aborter.abort());\n        }\n\n        // time taken by the init operation\n        const timeTakenByInit = Date.now() - initOperationStartTime;\n        return {\n          ...options,\n          // Left over time\n          timeoutInMs: retryTimeoutInMs - timeTakenByInit,\n        };\n      },\n      {\n        abortSignal: options.abortSignal,\n        timeoutInMs: retryTimeoutInMs,\n      },\n    );\n  }\n\n  private async _init(abortSignal?: AbortSignalLike): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const rxopt: ReceiverOptions = {\n        source: { address: this.address },\n        name: this.replyTo,\n        target: { address: this.replyTo },\n        onSessionError: (context: EventContext) => {\n          const sbError = translateServiceBusError(context.session!.error!);\n          managementClientLogger.logError(\n            sbError,\n            `${this.logPrefix} An error occurred on the session for request/response links for $management`,\n          );\n        },\n      };\n      const sropt: SenderOptions = {\n        target: { address: this.address },\n        onError: (context: EventContext) => {\n          const ehError = translateServiceBusError(context.sender!.error!);\n          managementClientLogger.logError(\n            ehError,\n            `${this.logPrefix} An error occurred on the $management sender link`,\n          );\n        },\n      };\n\n      // Even if multiple parallel requests reach here, the initLink secures a lock\n      // to ensure there won't be multiple initializations\n      await this.initLink(\n        {\n          senderOptions: sropt,\n          receiverOptions: rxopt,\n        },\n        abortSignal,\n      );\n    } catch (err: any) {\n      const translatedError = translateServiceBusError(err);\n      managementClientLogger.logError(\n        translatedError,\n        `${this.logPrefix} An error occurred while establishing the $management links`,\n      );\n      throw translatedError;\n    }\n  }\n\n  protected async createRheaLink(\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options: RequestResponseLinkOptions,\n  ): Promise<RequestResponseLink> {\n    const rheaLink = await RequestResponseLink.create(\n      this._context.connection,\n      options.senderOptions,\n      options.receiverOptions,\n    );\n    // Attach listener for the `receiver_error` events to log the errors.\n\n    // \"message\" event listener is added in core-amqp.\n    // \"rhea\" doesn't allow setting only the \"onError\" handler in the options if it is not accompanied by an \"onMessage\" handler.\n    // Hence, not passing onError handler in the receiver options, adding a handler below.\n    rheaLink.receiver.on(ReceiverEvents.receiverError, (context: EventContext) => {\n      const ehError = translateServiceBusError(context.receiver!.error!);\n      managementClientLogger.logError(\n        ehError,\n        `${this.logPrefix} An error occurred on the $management receiver link`,\n      );\n    });\n    return rheaLink;\n  }\n\n  /**\n   * Given array of typed values, returns the element in given index\n   */\n  private _safelyGetTypedValueFromArray(data: Typed[], index: number): any {\n    return Array.isArray(data) && data.length > index && data[index]\n      ? data[index].value\n      : undefined;\n  }\n\n  private _decodeApplicationPropertiesMap(\n    obj: Typed,\n  ): Record<string, string | number | boolean | Date> {\n    if (!types.is_map(obj)) {\n      throw new Error(\"object to decode is not of Map types\");\n    }\n    const array = obj.value as Array<Typed>;\n    const result: Record<string, string | number | boolean | Date> = {};\n    for (let i = 0; i < array.length; i += 2) {\n      const key = array[i].value as string;\n      result[key] = array[i + 1].value as string | number | boolean | Date;\n    }\n\n    return result;\n  }\n\n  private async _makeManagementRequest(\n    request: RheaMessage,\n    internalLogger: ServiceBusLogger,\n    sendRequestOptions: SendManagementRequestOptions = {},\n  ): Promise<RheaMessage> {\n    if (request.message_id === undefined) {\n      request.message_id = generate_uuid();\n    }\n\n    try {\n      const { timeoutInMs } = sendRequestOptions;\n      await waitForSendable(\n        internalLogger,\n        this.logPrefix,\n        this.name,\n        timeoutInMs ?? Constants.defaultOperationTimeoutInMs,\n        this.link?.sender,\n        this.link?.session?.outgoing?.available(),\n      );\n\n      return await this.link!.sendRequest(request, sendRequestOptions);\n    } catch (err: any) {\n      const translatedError = translateServiceBusError(err);\n      internalLogger.logError(\n        translatedError,\n        \"%s An error occurred during send on management request-response link with address '%s'\",\n        this.logPrefix,\n        this.address,\n      );\n      throw translatedError;\n    }\n  }\n\n  /**\n   * Closes the AMQP management session to the ServiceBus namespace for this client,\n   * returning a promise that will be resolved when disconnection is completed.\n   */\n  async close(): Promise<void> {\n    try {\n      // Always clear the timeout, as the isOpen check may report\n      // false without ever having cleared the timeout otherwise.\n\n      // NOTE: management link currently doesn't have a separate concept of \"detaching\" like\n      // the other links do. When we add handling of this (via the onDetached call, like other links)\n      // we can change this back to closeLink(\"permanent\").\n      await this.closeLink();\n      managementClientLogger.verbose(\"Successfully closed the management session.\");\n    } catch (err: any) {\n      managementClientLogger.logError(\n        err,\n        `${this.logPrefix} An error occurred while closing the management session`,\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Fetches the next batch of active messages. The first call to `peek()` fetches the first\n   * active message for this client. Each subsequent call fetches the subsequent message in the\n   * entity.\n   *\n   * Unlike a `received` message, `peeked` message will not have lock token associated with it,\n   * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. This method will\n   * also fetch even Deferred messages (but not Deadlettered message).\n   *\n   * @param messageCount - The number of messages to retrieve. Default value `1`.\n   * @param omitMessageBody - Whether to omit message body when peeking. Default value `false`.\n   */\n  async peek(\n    messageCount: number,\n    omitMessageBody?: boolean,\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<ServiceBusReceivedMessage[]> {\n    throwErrorIfConnectionClosed(this._context);\n    return this.peekBySequenceNumber(\n      this._lastPeekedSequenceNumber.add(1),\n      messageCount,\n      undefined,\n      omitMessageBody,\n      options,\n    );\n  }\n\n  /**\n   * Fetches the next batch of active messages in the current MessageSession. The first call to\n   * `peek()` fetches the first active message for this client. Each subsequent call fetches the\n   * subsequent message in the entity.\n   *\n   * Unlike a `received` message, `peeked` message will not have lock token associated with it,\n   * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`.  This method will\n   * also fetch even Deferred messages (but not Deadlettered message).\n   *\n   * @param sessionId - The sessionId from which messages need to be peeked.\n   * @param messageCount - The number of messages to retrieve. Default value `1`.\n   * @param omitMessageBody - Whether to omit message body when peeking Default value `false`.\n   */\n  async peekMessagesBySession(\n    sessionId: string,\n    messageCount: number,\n    omitMessageBody?: boolean,\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<ServiceBusReceivedMessage[]> {\n    throwErrorIfConnectionClosed(this._context);\n    return this.peekBySequenceNumber(\n      this._lastPeekedSequenceNumber.add(1),\n      messageCount,\n      sessionId,\n      omitMessageBody,\n      options,\n    );\n  }\n\n  /**\n   * Peeks the desired number of messages from the specified sequence number.\n   *\n   * @param fromSequenceNumber - The sequence number from where to read the message.\n   * @param messageCount - The number of messages to retrieve. Default value `1`.\n   * @param sessionId - The sessionId from which messages need to be peeked.\n   * @param omitMessageBody - Whether to omit message body when peeking. Default value `false`.\n   */\n  async peekBySequenceNumber(\n    fromSequenceNumber: Long,\n    maxMessageCount: number,\n    sessionId?: string,\n    omitMessageBody?: boolean,\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<ServiceBusReceivedMessage[]> {\n    throwErrorIfConnectionClosed(this._context);\n    const connId = this._context.connectionId;\n\n    // Checks for fromSequenceNumber\n    throwTypeErrorIfParameterMissing(connId, \"fromSequenceNumber\", fromSequenceNumber);\n    throwTypeErrorIfParameterNotLong(connId, \"fromSequenceNumber\", fromSequenceNumber);\n\n    // Checks for maxMessageCount\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n    );\n    throwTypeErrorIfParameterTypeMismatch(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n      \"number\",\n    );\n\n    if (isNaN(maxMessageCount) || maxMessageCount < 1) {\n      throw new TypeError(InvalidMaxMessageCountError);\n    }\n\n    const messageList: ServiceBusReceivedMessage[] = [];\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.fromSequenceNumber] = types.wrap_long(\n        Buffer.from(fromSequenceNumber.toBytesBE()),\n      );\n      messageBody[Constants.messageCount] = types.wrap_int(maxMessageCount!);\n      if (isDefined(sessionId)) {\n        messageBody[Constants.sessionIdMapKey] = sessionId;\n      }\n      if (isDefined(omitMessageBody)) {\n        const omitMessageBodyKey = \"omit-message-body\"; // TODO: Service Bus specific. Put it somewhere\n        messageBody[omitMessageBodyKey] = types.wrap_boolean(omitMessageBody);\n      }\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.peekMessage,\n        },\n      };\n      if (updatedOptions?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] =\n          updatedOptions?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      // TODO: it'd be nice to attribute this peek request to the actual receiver that made it. So have them pass in a\n      // log prefix rather than just falling back to the management links.\n      receiverLogger.verbose(\n        \"%s Peek by sequence number request body: %O.\",\n        this.logPrefix,\n        request.body,\n      );\n\n      const result = await this._makeManagementRequest(request, receiverLogger, updatedOptions);\n      if (result.application_properties!.statusCode !== 204) {\n        const messages = result.body.messages as { message: Buffer }[];\n        for (const msg of messages) {\n          const decodedMessage = RheaMessageUtil.decode(msg.message);\n          const message = fromRheaMessage(decodedMessage as any, {\n            skipParsingBodyAsJson: updatedOptions?.skipParsingBodyAsJson ?? false,\n            skipConvertingDate: updatedOptions?.skipConvertingDate ?? false,\n          });\n          messageList.push(message);\n          this._lastPeekedSequenceNumber = message.sequenceNumber!;\n        }\n      }\n    } catch (err: any) {\n      const error = translateServiceBusError(err) as MessagingError;\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the request to peek messages to $management endpoint`,\n      );\n      // statusCode == 404 then do not throw\n      if (error.code !== ConditionErrorNameMapper[\"com.microsoft:message-not-found\"]) {\n        throw error;\n      }\n    }\n    return messageList;\n  }\n\n  /**\n   * Renews the lock on the message. The lock will be renewed based on the setting specified on\n   * the queue.\n   *\n   * When a message is received in `PeekLock` mode, the message is locked on the server for this\n   * receiver instance for a duration as specified during the Queue/Subscription creation\n   * (LockDuration). If processing of the message requires longer than this duration, the\n   * lock needs to be renewed. For each renewal, it resets the time the message is locked by the\n   * LockDuration set on the Entity.\n   *\n   * @param lockToken - Lock token of the message\n   * @param options - Options that can be set while sending the request.\n   * @returns New lock token expiry date and time in UTC format.\n   */\n  // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n  async renewLock(lockToken: string, options?: SendManagementRequestOptions): Promise<Date> {\n    throwErrorIfConnectionClosed(this._context);\n    if (!options) options = {};\n    if (options.timeoutInMs == null) options.timeoutInMs = 5000;\n\n    try {\n      const messageBody: any = {};\n\n      messageBody[Constants.lockTokens] = types.wrap_array(\n        [string_to_uuid(lockToken)],\n        0x98,\n        undefined,\n      );\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.renewLock,\n        },\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      if (updatedOptions.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] =\n          updatedOptions.associatedLinkName;\n      }\n      receiverLogger.verbose(\n        \"[%s] Renew message Lock request: %O.\",\n        this._context.connectionId,\n        request,\n      );\n      const result = await this._makeManagementRequest(request, receiverLogger, {\n        abortSignal: updatedOptions?.abortSignal,\n        requestName: \"renewLock\",\n      });\n      const lockedUntilUtc = new Date(result.body.expirations[0]);\n      return lockedUntilUtc;\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Schedules an array of messages to appear on Service Bus at a later time.\n   *\n   * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.\n   * @param messages - An array of messages that needs to be scheduled.\n   * @returns The sequence numbers of messages that were scheduled.\n   */\n  async scheduleMessages(\n    scheduledEnqueueTimeUtc: Date,\n    messages: ServiceBusMessage[] | AmqpAnnotatedMessage[],\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<Long[]> {\n    throwErrorIfConnectionClosed(this._context);\n    if (!messages.length) {\n      return [];\n    }\n    const messageBody: any[] = [];\n    for (let i = 0; i < messages.length; i++) {\n      const item = messages[i];\n\n      try {\n        const rheaMessage = toRheaMessage(item, defaultDataTransformer);\n        updateMessageId(rheaMessage, rheaMessage.message_id || generate_uuid());\n        updateScheduledTime(rheaMessage, scheduledEnqueueTimeUtc);\n\n        const entry: {\n          message: Buffer;\n          [\"message-id\"]: ServiceBusMessage[\"messageId\"];\n          [\"partition-key\"]?: ServiceBusMessage[\"partitionKey\"];\n          [Constants.sessionIdMapKey]?: string | undefined;\n        } = {\n          message: RheaMessageUtil.encode(rheaMessage),\n          \"message-id\": rheaMessage.message_id,\n        };\n\n        if (rheaMessage.group_id) {\n          entry[Constants.sessionIdMapKey] = rheaMessage.group_id;\n        }\n\n        if (rheaMessage.message_annotations?.[Constants.partitionKey]) {\n          entry[\"partition-key\"] = rheaMessage.message_annotations[Constants.partitionKey];\n        }\n\n        // Will be required later for implementing Transactions\n        // if (item.viaPartitionKey) {\n        //   entry[\"via-partition-key\"] = item.viaPartitionKey;\n        // }\n\n        const wrappedEntry = types.wrap_map(entry);\n        messageBody.push(wrappedEntry);\n      } catch (err: any) {\n        const error = translateServiceBusError(err);\n        senderLogger.logError(\n          error,\n          `${this.logPrefix} An error occurred while encoding the item at position ${i} in the messages array`,\n        );\n        throw error;\n      }\n    }\n    const updatedOptions = await this.initWithUniqueReplyTo(options);\n    try {\n      const request: RheaMessage = {\n        body: { messages: messageBody },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.scheduleMessage,\n        },\n      };\n      if (updatedOptions?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] =\n          updatedOptions?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      senderLogger.verbose(\"%s Schedule messages request body: %O.\", this.logPrefix, request.body);\n      const result = await this._makeManagementRequest(request, senderLogger, updatedOptions);\n      const sequenceNumbers = result.body[Constants.sequenceNumbers];\n      const sequenceNumbersAsLong = [];\n      for (let i = 0; i < sequenceNumbers.length; i++) {\n        if (typeof sequenceNumbers[i] === \"number\") {\n          sequenceNumbersAsLong.push(Long.fromNumber(sequenceNumbers[i]));\n        } else {\n          sequenceNumbersAsLong.push(Long.fromBytesBE(sequenceNumbers[i]));\n        }\n      }\n      return sequenceNumbersAsLong;\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      senderLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the request to schedule messages to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Cancels an array of messages that were scheduled.\n   * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.\n   */\n  async cancelScheduledMessages(\n    sequenceNumbers: Long[],\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    if (!sequenceNumbers.length) {\n      return;\n    }\n    const messageBody: any = {};\n    messageBody[Constants.sequenceNumbers] = [];\n    for (let i = 0; i < sequenceNumbers.length; i++) {\n      const sequenceNumber = sequenceNumbers[i];\n      try {\n        messageBody[Constants.sequenceNumbers].push(Buffer.from(sequenceNumber.toBytesBE()));\n      } catch (err: any) {\n        const error = translateServiceBusError(err);\n        senderLogger.logError(\n          error,\n          `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`,\n        );\n        throw error;\n      }\n    }\n\n    try {\n      messageBody[Constants.sequenceNumbers] = types.wrap_array(\n        messageBody[Constants.sequenceNumbers],\n        0x81,\n        undefined,\n      );\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.cancelScheduledMessage,\n        },\n      };\n\n      if (updatedOptions?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] =\n          updatedOptions?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      senderLogger.verbose(\n        \"%s Cancel scheduled messages request body: %O.\",\n        this.logPrefix,\n        request.body,\n      );\n\n      await this._makeManagementRequest(request, senderLogger, updatedOptions);\n      return;\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      senderLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the request to cancel the scheduled message to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Receives a list of deferred messages identified by `sequenceNumbers`.\n   *\n   * @param sequenceNumbers - A list containing the sequence numbers to receive.\n   * @param receiveMode - The mode in which the receiver was created.\n   * @returns a list of messages identified by the given sequenceNumbers or an empty list if no messages are found.\n   * - Throws an error if the messages have not been deferred.\n   */\n  async receiveDeferredMessages(\n    sequenceNumbers: Long[],\n    receiveMode: ReceiveMode,\n    sessionId?: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<ServiceBusMessageImpl[]> {\n    throwErrorIfConnectionClosed(this._context);\n\n    if (!sequenceNumbers.length) {\n      return [];\n    }\n\n    const messageList: ServiceBusMessageImpl[] = [];\n    const messageBody: any = {};\n    messageBody[Constants.sequenceNumbers] = [];\n    for (let i = 0; i < sequenceNumbers.length; i++) {\n      const sequenceNumber = sequenceNumbers[i];\n      try {\n        messageBody[Constants.sequenceNumbers].push(Buffer.from(sequenceNumber.toBytesBE()));\n      } catch (err: any) {\n        const error = translateServiceBusError(err);\n        receiverLogger.logError(\n          error,\n          `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`,\n        );\n        throw error;\n      }\n    }\n\n    try {\n      messageBody[Constants.sequenceNumbers] = types.wrap_array(\n        messageBody[Constants.sequenceNumbers],\n        0x81,\n        undefined,\n      );\n      const receiverSettleMode: number = receiveMode === \"receiveAndDelete\" ? 0 : 1;\n      messageBody[Constants.receiverSettleMode] = types.wrap_uint(receiverSettleMode);\n      if (sessionId != null) {\n        messageBody[Constants.sessionIdMapKey] = sessionId;\n      }\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.receiveBySequenceNumber,\n        },\n      };\n      if (updatedOptions?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] =\n          updatedOptions?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      receiverLogger.verbose(\n        \"%s Receive deferred messages request body: %O.\",\n        this.logPrefix,\n        request.body,\n      );\n\n      const result = await this._makeManagementRequest(request, receiverLogger, updatedOptions);\n      const messages = result.body.messages as {\n        message: Buffer;\n        \"lock-token\": Buffer;\n      }[];\n      for (const msg of messages) {\n        const decodedMessage = RheaMessageUtil.decode(msg.message);\n        const message = new ServiceBusMessageImpl(\n          decodedMessage as any,\n          { tag: msg[\"lock-token\"] } as any,\n          false,\n          receiveMode,\n          updatedOptions?.skipParsingBodyAsJson ?? false,\n          false,\n        );\n        messageList.push(message);\n      }\n      return messageList;\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the request to receive deferred messages to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Updates the disposition status of deferred messages.\n   *\n   * @param lockTokens - Message lock tokens to update disposition status.\n   * @param dispositionStatus - The disposition status to be set\n   * @param options - Optional parameters that can be provided while updating the disposition status.\n   */\n  async updateDispositionStatus(\n    lockToken: string,\n    dispositionType: DispositionType,\n    // TODO: mgmt link retry<> will come in the next PR.\n    options?: Omit<DispositionStatusOptions, \"retryOptions\"> & SendManagementRequestOptions,\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    if (!options) options = {};\n    try {\n      let dispositionStatus: \"completed\" | \"defered\" | \"suspended\" | \"abandoned\";\n\n      if (dispositionType === DispositionType.abandon) dispositionStatus = \"abandoned\";\n      else if (dispositionType === DispositionType.complete) dispositionStatus = \"completed\";\n      else if (dispositionType === DispositionType.defer) dispositionStatus = \"defered\";\n      else if (dispositionType === DispositionType.deadletter) dispositionStatus = \"suspended\";\n      else throw new Error(`Provided \"dispositionType\" - ${dispositionType} is invalid`);\n\n      const messageBody: any = {};\n      const lockTokenBuffer: Buffer[] = [];\n      lockTokenBuffer.push(string_to_uuid(lockToken));\n      messageBody[Constants.lockTokens] = types.wrap_array(lockTokenBuffer, 0x98, undefined);\n      messageBody[Constants.dispositionStatus] = dispositionStatus;\n      if (options.deadLetterDescription != null) {\n        messageBody[Constants.deadLetterDescription] = options.deadLetterDescription;\n      }\n      if (options.deadLetterReason != null) {\n        messageBody[Constants.deadLetterReason] = options.deadLetterReason;\n      }\n      if (options.propertiesToModify != null) {\n        messageBody[Constants.propertiesToModify] = options.propertiesToModify;\n      }\n      if (options.sessionId != null) {\n        messageBody[Constants.sessionIdMapKey] = options.sessionId;\n      }\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.updateDisposition,\n        },\n      };\n      if (updatedOptions.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] =\n          updatedOptions.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      receiverLogger.verbose(\n        \"%s Update disposition status request body: %O.\",\n        this.logPrefix,\n        request.body,\n      );\n      await this._makeManagementRequest(request, receiverLogger, updatedOptions);\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the request to update disposition status to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Renews the lock for the specified session.\n   *\n   * @param sessionId - Id of the session for which the lock needs to be renewed\n   * @param options - Options that can be set while sending the request.\n   * @returns New lock token expiry date and time in UTC format.\n   */\n  async renewSessionLock(\n    sessionId: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<Date> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.sessionIdMapKey] = sessionId;\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.renewSessionLock,\n        },\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      if (updatedOptions?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] =\n          updatedOptions?.associatedLinkName;\n      }\n      receiverLogger.verbose(\n        \"%s Renew Session Lock request body: %O.\",\n        this.logPrefix,\n        request.body,\n      );\n      const result = await this._makeManagementRequest(request, receiverLogger, updatedOptions);\n      const lockedUntilUtc = new Date(result.body.expiration);\n      receiverLogger.verbose(\n        \"%s Lock for session '%s' will expire at %s.\",\n        this.logPrefix,\n        sessionId,\n        lockedUntilUtc.toString(),\n      );\n      return lockedUntilUtc;\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Sets the state of the specified session.\n   *\n   * @param sessionId - The session for which the state needs to be set\n   * @param state - The state that needs to be set.\n   */\n  async setSessionState(\n    sessionId: string,\n    state: unknown,\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.sessionIdMapKey] = sessionId;\n      messageBody[\"session-state\"] = toBuffer(state);\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.setSessionState,\n        },\n      };\n      if (updatedOptions?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] =\n          updatedOptions?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      receiverLogger.verbose(\n        \"%s Set Session state request body: %O.\",\n        this.logPrefix,\n        request.body,\n      );\n      await this._makeManagementRequest(request, receiverLogger, updatedOptions);\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the state of the specified session.\n   *\n   * @param sessionId - The session for which the state needs to be retrieved.\n   * @returns The state of that session\n   */\n  async getSessionState(\n    sessionId: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<any> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const messageBody: any = {};\n      messageBody[Constants.sessionIdMapKey] = sessionId;\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.getSessionState,\n        },\n      };\n      if (updatedOptions?.associatedLinkName) {\n        request.application_properties![Constants.associatedLinkName] =\n          updatedOptions?.associatedLinkName;\n      }\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      receiverLogger.verbose(\n        \"%s Get session state request body: %O.\",\n        this.logPrefix,\n        request.body,\n      );\n      const result = await this._makeManagementRequest(request, receiverLogger, updatedOptions);\n      return result.body[\"session-state\"]\n        ? tryToJsonDecode(result.body[\"session-state\"])\n        : result.body[\"session-state\"];\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      receiverLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Lists the sessions on the ServiceBus Queue/Topic.\n   * @param lastUpdateTime - Filter to include only sessions updated after a given time.\n   * @param skip - The number of sessions to skip\n   * @param top - Maximum numer of sessions.\n   * @returns A list of session ids.\n   */\n  async listMessageSessions(\n    skip: number,\n    top: number,\n    lastUpdatedTime?: Date,\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<string[]> {\n    throwErrorIfConnectionClosed(this._context);\n    const defaultLastUpdatedTimeForListingSessions: number = 259200000; // 3 * 24 * 3600 * 1000\n    if (typeof skip !== \"number\") {\n      throw new Error(\"'skip' is a required parameter and must be of type 'number'.\");\n    }\n    if (typeof top !== \"number\") {\n      throw new Error(\"'top' is a required parameter and must be of type 'number'.\");\n    }\n    if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) {\n      throw new Error(\"'lastUpdatedTime' must be of type 'Date'.\");\n    }\n    if (!lastUpdatedTime) {\n      lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);\n    }\n    try {\n      const messageBody: any = {};\n      messageBody[\"last-updated-time\"] = lastUpdatedTime;\n      messageBody[\"skip\"] = types.wrap_int(skip);\n      messageBody[\"top\"] = types.wrap_int(top);\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: messageBody,\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.enumerateSessions,\n        },\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n      managementClientLogger.verbose(\n        \"%s List sessions request body: %O.\",\n        this.logPrefix,\n        request.body,\n      );\n      const response = await this._makeManagementRequest(\n        request,\n        managementClientLogger,\n        updatedOptions,\n      );\n\n      return (response && response.body && response.body[\"sessions-ids\"]) || [];\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      managementClientLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Get all the rules on the Subscription.\n   * @returns A list of rules.\n   */\n  async getRules(\n    options?: ListRequestOptions & OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<RuleProperties[]> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const updatedOptions = (await this.initWithUniqueReplyTo(options)) as ListRequestOptions &\n        OperationOptionsBase &\n        SendManagementRequestOptions;\n      const request: RheaMessage = {\n        body: {\n          top: updatedOptions?.maxCount\n            ? types.wrap_int(updatedOptions.maxCount)\n            : types.wrap_int(max32BitNumber),\n          skip: updatedOptions?.skip ? types.wrap_int(updatedOptions.skip) : types.wrap_int(0),\n        },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.enumerateRules,\n        },\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      managementClientLogger.verbose(\n        \"%s Get rules request body: %O.\",\n        this.logPrefix,\n        request.body,\n      );\n      const response = await this._makeManagementRequest(\n        request,\n        managementClientLogger,\n        updatedOptions,\n      );\n      if (\n        response.application_properties!.statusCode === 204 ||\n        !response.body ||\n        !Array.isArray(response.body.rules)\n      ) {\n        return [];\n      }\n\n      // Reference: https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-request-response#response-11\n      const result: { \"rule-description\": Typed }[] = response.body.rules || [];\n      const rules: RuleProperties[] = [];\n      result.forEach((x) => {\n        const ruleDescriptor = x[\"rule-description\"];\n        let filter: SqlRuleFilter | CorrelationRuleFilter;\n\n        // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name\n        if (\n          !ruleDescriptor ||\n          !ruleDescriptor.descriptor ||\n          ruleDescriptor.descriptor.value !== Constants.descriptorCodes.ruleDescriptionList ||\n          !Array.isArray(ruleDescriptor.value) ||\n          ruleDescriptor.value.length < 3\n        ) {\n          return;\n        }\n\n        const filtersRawData: Typed = ruleDescriptor.value[0];\n        const actionsRawData: Typed = ruleDescriptor.value[1];\n        let sqlRuleAction: SqlRuleAction;\n        if (\n          actionsRawData.descriptor.value === Constants.descriptorCodes.sqlRuleActionList &&\n          Array.isArray(actionsRawData.value) &&\n          actionsRawData.value.length\n        ) {\n          sqlRuleAction = {\n            sqlExpression: this._safelyGetTypedValueFromArray(actionsRawData.value, 0),\n          };\n        } else {\n          sqlRuleAction = {};\n        }\n\n        switch (filtersRawData.descriptor.value) {\n          case Constants.descriptorCodes.trueFilterList:\n            filter = {\n              sqlExpression: \"1=1\",\n            };\n            break;\n          case Constants.descriptorCodes.falseFilterList:\n            filter = {\n              sqlExpression: \"1=0\",\n            };\n            break;\n          case Constants.descriptorCodes.sqlFilterList:\n            filter = {\n              sqlExpression: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),\n            };\n            break;\n          case Constants.descriptorCodes.correlationFilterList:\n            filter = {\n              correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),\n              messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),\n              to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),\n              replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),\n              subject: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),\n              sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),\n              replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),\n              contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),\n              applicationProperties:\n                Array.isArray(filtersRawData.value) &&\n                filtersRawData.value.length > 8 &&\n                filtersRawData.value[8]\n                  ? this._decodeApplicationPropertiesMap(filtersRawData.value[8])\n                  : undefined,\n            };\n            break;\n          default:\n            throw new Error(\n              `${this.logPrefix} Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`,\n            );\n        }\n\n        const rule: RuleProperties = {\n          name: ruleDescriptor.value[2].value,\n          filter,\n          action: sqlRuleAction,\n        };\n        rules.push(rule);\n      });\n\n      return rules;\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      managementClientLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the get rules request to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Removes the rule on the Subscription identified by the given rule name.\n   */\n  async removeRule(\n    ruleName: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"ruleName\", ruleName);\n    ruleName = String(ruleName);\n    throwTypeErrorIfParameterIsEmptyString(this._context.connectionId, \"ruleName\", ruleName);\n\n    try {\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: {\n          \"rule-name\": types.wrap_string(ruleName),\n        },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.removeRule,\n        },\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      managementClientLogger.verbose(\n        \"%s Remove Rule request body: %O.\",\n        this.logPrefix,\n        request.body,\n      );\n      await this._makeManagementRequest(request, managementClientLogger, updatedOptions);\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      managementClientLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the remove rule request to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Adds a rule on the subscription as defined by the given rule name, filter and action\n   * @param ruleName - Name of the rule\n   * @param filter - A Boolean, SQL expression or a Correlation filter\n   * @param sqlRuleActionExpression - Action to perform if the message satisfies the filtering expression\n   */\n  async addRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    sqlRuleActionExpression?: string,\n    options?: OperationOptionsBase & SendManagementRequestOptions,\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"ruleName\", ruleName);\n    ruleName = String(ruleName);\n    throwTypeErrorIfParameterIsEmptyString(this._context.connectionId, \"ruleName\", ruleName);\n\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"filter\", filter);\n    if (!isSqlRuleFilter(filter) && !isCorrelationRuleFilter(filter)) {\n      throw new TypeError(\n        `The parameter \"filter\" should implement either the SqlRuleFilter or the CorrelationRuleFilter interface.`,\n      );\n    }\n\n    try {\n      const ruleDescription: any = {};\n      if (isSqlRuleFilter(filter)) {\n        ruleDescription[\"sql-filter\"] = {\n          expression: filter.sqlExpression,\n        };\n      } else {\n        ruleDescription[\"correlation-filter\"] = {\n          \"correlation-id\": filter.correlationId,\n          \"message-id\": filter.messageId,\n          to: filter.to,\n          \"reply-to\": filter.replyTo,\n          label: filter.subject,\n          \"session-id\": filter.sessionId,\n          \"reply-to-session-id\": filter.replyToSessionId,\n          \"content-type\": filter.contentType,\n          properties: filter.applicationProperties,\n        };\n      }\n\n      if (sqlRuleActionExpression !== undefined) {\n        ruleDescription[\"sql-rule-action\"] = {\n          expression: String(sqlRuleActionExpression),\n        };\n      }\n      const updatedOptions = await this.initWithUniqueReplyTo(options);\n      const request: RheaMessage = {\n        body: {\n          \"rule-name\": types.wrap_string(ruleName),\n          \"rule-description\": types.wrap_map(ruleDescription),\n        },\n        reply_to: this.replyTo,\n        application_properties: {\n          operation: Constants.operations.addRule,\n        },\n      };\n      request.application_properties![Constants.trackingId] = generate_uuid();\n\n      managementClientLogger.verbose(\"%s Add Rule request body: %O.\", this.logPrefix, request.body);\n      await this._makeManagementRequest(request, managementClientLogger, updatedOptions);\n    } catch (err: any) {\n      const error = translateServiceBusError(err);\n      managementClientLogger.logError(\n        error,\n        `${this.logPrefix} An error occurred while sending the Add rule request to $management endpoint`,\n      );\n      throw error;\n    }\n  }\n\n  protected removeLinkFromContext(): void {\n    delete this._context.managementClients[this.name];\n  }\n}\n\n/**\n * Converts an AmqpAnnotatedMessage or ServiceBusMessage into a properly formatted\n * message for sending to the mgmt link for scheduling.\n *\n * @internal\n * @hidden\n */\nexport function toScheduleableMessage(\n  item: ServiceBusMessage | AmqpAnnotatedMessage,\n  scheduledEnqueueTimeUtc: Date,\n): Record<string, unknown> {\n  const rheaMessage = toRheaMessage(item, defaultDataTransformer);\n  updateMessageId(rheaMessage, rheaMessage.message_id || generate_uuid());\n  updateScheduledTime(rheaMessage, scheduledEnqueueTimeUtc);\n\n  const entry: Record<string, unknown> = {\n    message: RheaMessageUtil.encode(rheaMessage),\n    \"message-id\": rheaMessage.message_id,\n  };\n\n  rheaMessage.message_annotations = {\n    ...rheaMessage.message_annotations,\n    [Constants.scheduledEnqueueTime]: scheduledEnqueueTimeUtc,\n  };\n\n  if (rheaMessage.group_id) {\n    entry[Constants.sessionIdMapKey] = rheaMessage.group_id;\n  }\n\n  const partitionKey =\n    rheaMessage.message_annotations && rheaMessage.message_annotations[Constants.partitionKey];\n\n  if (partitionKey) {\n    entry[\"partition-key\"] = partitionKey;\n  }\n  return entry;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as os from \"os\";\n\n/**\n * Returns information about the platform this function is being run on.\n * @hidden\n * @internal\n */\nexport function getRuntimeInfo(): string {\n  const runtimeInfo = {\n    key: \"Node\",\n    value: process.version,\n  };\n\n  const osInfo = {\n    key: \"OS\",\n    value: `(${os.arch()}-${os.type()}-${os.release()})`,\n  };\n\n  return `${runtimeInfo.key}/${runtimeInfo.value} ${osInfo.key}/${osInfo.value}`;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { connectionLogger as logger } from \"./log\";\nimport { packageJsonInfo } from \"./util/constants\";\nimport {\n  ConnectionConfig,\n  ConnectionContextBase,\n  CreateConnectionContextBaseParameters,\n  SasTokenProvider,\n} from \"@azure/core-amqp\";\nimport { TokenCredential } from \"@azure/core-auth\";\nimport { ServiceBusClientOptions } from \"./constructorHelpers\";\nimport {\n  AmqpError,\n  Connection,\n  ConnectionError,\n  ConnectionEvents,\n  EventContext,\n  OnAmqpEvent,\n} from \"rhea-promise\";\nimport { MessageSender } from \"./core/messageSender\";\nimport { MessageSession } from \"./session/messageSession\";\nimport { MessageReceiver } from \"./core/messageReceiver\";\nimport { ManagementClient } from \"./core/managementClient\";\nimport { formatUserAgentPrefix } from \"./util/utils\";\nimport { getRuntimeInfo } from \"./util/runtimeInfo\";\nimport { NonSessionReceiverType, ReceiverType } from \"./core/linkEntity\";\nimport { ServiceBusError } from \"./serviceBusError\";\n\n/**\n * @internal\n * Provides contextual information like the underlying amqp connection, cbs session, management session,\n * tokenCredential, senders, receivers, etc. about the ServiceBus client.\n */\nexport interface ConnectionContext extends ConnectionContextBase {\n  /**\n   * The credential to be used for Authentication.\n   * Default value: SasTokenProvider.\n   */\n  tokenCredential: SasTokenProvider | TokenCredential;\n  /**\n   * A map of active Service Bus Senders with sender name as key.\n   */\n  senders: { [name: string]: MessageSender };\n  /**\n   * A map of active Service Bus receivers for non session enabled queues/subscriptions\n   * with receiver name as key.\n   */\n  messageReceivers: { [name: string]: MessageReceiver };\n  /**\n   * A map of active Service Bus receivers for session enabled queues/subscriptions\n   * with receiver name as key.\n   */\n  messageSessions: { [name: string]: MessageSession };\n  /**\n   * A map of ManagementClient instances for operations over the $management link\n   * with key as the entity path.\n   */\n  managementClients: { [name: string]: ManagementClient };\n  /**\n   * Function returning a promise that resolves once the connectionContext is ready to open an AMQP link.\n   * ConnectionContext will be ready to open an AMQP link when:\n   * - The AMQP connection is already open on both sides.\n   * - The AMQP connection has been closed or disconnected. In this case, a new AMQP connection is expected\n   * to be created first.\n   * An AMQP link cannot be opened if the AMQP connection\n   * is in the process of closing or disconnecting.\n   */\n  readyToOpenLink(): Promise<void>;\n  /**\n   * Fetches the receiver from the cache in ConnectionContext based on the receiverName given.\n   * Useful for when a message needs to be settled or have its lock renewed.\n   *\n   * TODO: Track the right receiver on the message instead of the ConnectionContext to remove\n   * the need for this helper.\n   */\n  getReceiverFromCache(\n    receiverName: string,\n    sessionId?: string,\n  ): MessageReceiver | MessageSession | undefined;\n  /**\n   * Gets the management client for given entity path from the cache\n   * Creates one if none exists in the cache\n   */\n  getManagementClient(entityPath: string): ManagementClient;\n  /**\n   * Indicates whether the connection is in the process of closing.\n   * When this returns `true`, a `disconnected` event will be received\n   * after the connection is closed.\n   */\n  isConnectionClosing(): boolean;\n}\n\n/**\n * Describes the members on the ConnectionContext that are only\n * used by it internally.\n * @hidden\n * @internal\n */\nexport interface ConnectionContextInternalMembers extends ConnectionContext {\n  /**\n   * Resolves once the context's connection emits a `disconnected` event.\n   */\n  waitForDisconnectedEvent(): Promise<void>;\n  /**\n   * Resolves once the connection has finished being reset.\n   * Connections are reset as part of reacting to a `disconnected` event.\n   */\n  waitForConnectionReset(): Promise<void>;\n}\n\n/**\n * @internal\n * Helper type to get the names of all the functions on an object.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\n/**\n * @internal\n * Helper type to get the types of all the functions on an object.\n */\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n/**\n * @internal\n * Helper type to get the types of all the functions on ConnectionContext\n * and the internal methods from ConnectionContextInternalMembers.\n * Note that this excludes the functions that ConnectionContext inherits.\n * Each function also has its `this` type set as `ConnectionContext`.\n */\ntype ConnectionContextMethods = Omit<\n  FunctionProperties<ConnectionContextInternalMembers>,\n  FunctionPropertyNames<ConnectionContextBase>\n> &\n  ThisType<ConnectionContextInternalMembers>;\n\n/**\n * @internal\n * Helper method to call onDetached on the non-sessions batching and streaming receivers from the connection context upon seeing an error.\n */\nasync function callOnDetachedOnReceivers(\n  connectionContext: ConnectionContext,\n  contextOrConnectionError: Error | ConnectionError | AmqpError | undefined,\n  receiverType: NonSessionReceiverType,\n): Promise<void[]> {\n  const detachCalls: Promise<void>[] = [];\n\n  // Iterating over non-sessions batching and streaming receivers\n  for (const receiverName of Object.keys(connectionContext.messageReceivers)) {\n    const receiver = connectionContext.messageReceivers[receiverName];\n    if (receiver && receiver.receiverType === receiverType) {\n      logger.verbose(\n        \"[%s] calling detached on %s receiver '%s'.\",\n        connectionContext.connection.id,\n        receiver.receiverType,\n        receiver.name,\n      );\n      detachCalls.push(\n        receiver.onDetached(contextOrConnectionError).catch((err) => {\n          logger.logError(\n            err,\n            \"[%s] An error occurred while calling onDetached() on the %s receiver '%s'\",\n            connectionContext.connection.id,\n            receiver.receiverType,\n            receiver.name,\n          );\n        }),\n      );\n    }\n  }\n  return Promise.all(detachCalls);\n}\n\n/**\n * @internal\n * Helper method to call onDetached on the session receivers from the connection context upon seeing an error.\n */\nasync function callOnDetachedOnSessionReceivers(\n  connectionContext: ConnectionContext,\n  contextOrConnectionError: Error | ConnectionError | AmqpError | undefined,\n): Promise<void[]> {\n  const getSessionError = (sessionId: string, entityPath: string): ServiceBusError => {\n    const sessionInfo =\n      `The receiver for session \"${sessionId}\" in \"${entityPath}\" has been closed and can no longer be used. ` +\n      `Please create a new receiver using the \"acceptSession\" or \"acceptNextSession\" method on the ServiceBusClient.`;\n\n    const errorMessage =\n      contextOrConnectionError == null\n        ? `Unknown error occurred on the AMQP connection while receiving messages. ` + sessionInfo\n        : `Error occurred on the AMQP connection while receiving messages. ` +\n          sessionInfo +\n          `\\nMore info - \\n${contextOrConnectionError}`;\n\n    const error = new ServiceBusError(errorMessage, \"SessionLockLost\");\n    error.retryable = false;\n    return error;\n  };\n\n  const detachCalls: Promise<void>[] = [];\n\n  for (const receiverName of Object.keys(connectionContext.messageSessions)) {\n    const receiver = connectionContext.messageSessions[receiverName];\n    logger.verbose(\n      \"[%s] calling detached on %s receiver(sessions).\",\n      connectionContext.connection.id,\n      receiver.name,\n    );\n    detachCalls.push(\n      receiver.onDetached(getSessionError(receiver.sessionId, receiver.entityPath)).catch((err) => {\n        logger.logError(\n          err,\n          \"[%s] An error occurred while calling onDetached() on the session receiver(sessions) '%s'\",\n          connectionContext.connection.id,\n          receiver.name,\n        );\n      }),\n    );\n  }\n\n  return Promise.all(detachCalls);\n}\n\n/**\n * @internal\n * Helper method to get the number of receivers of specified type from the connectionContext.\n */\nfunction getNumberOfReceivers(\n  connectionContext: Pick<ConnectionContext, \"messageReceivers\" | \"messageSessions\">,\n  receiverType: ReceiverType,\n): number {\n  if (receiverType === \"session\") {\n    const receivers = connectionContext.messageSessions;\n    return Object.keys(receivers).length;\n  }\n  const receivers = connectionContext.messageReceivers;\n  const receiverNames = Object.keys(receivers);\n  const count = receiverNames.reduce(\n    (acc, name) => (receivers[name].receiverType === receiverType ? ++acc : acc),\n    0,\n  );\n  return count;\n}\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace ConnectionContext {\n  export function create(\n    config: ConnectionConfig,\n    tokenCredential: SasTokenProvider | TokenCredential,\n    options?: ServiceBusClientOptions,\n  ): ConnectionContext {\n    if (!options) options = {};\n    const userAgent = `${formatUserAgentPrefix(\n      options.userAgentOptions?.userAgentPrefix,\n    )} ${getRuntimeInfo()}`;\n    const parameters: CreateConnectionContextBaseParameters = {\n      config: config,\n      // re-enabling this will be a post-GA discussion similar to event-hubs.\n      // dataTransformer: options.dataTransformer,\n      isEntityPathRequired: false,\n      connectionProperties: {\n        product: \"MSJSClient\",\n        userAgent,\n        version: packageJsonInfo.version,\n      },\n    };\n    // Let us create the base context and then add ServiceBus specific ConnectionContext properties.\n    const connectionContext = ConnectionContextBase.create(parameters) as ConnectionContext;\n    connectionContext.tokenCredential = tokenCredential;\n    connectionContext.senders = {};\n    connectionContext.messageReceivers = {};\n    connectionContext.messageSessions = {};\n    connectionContext.managementClients = {};\n\n    let waitForConnectionRefreshResolve: () => void;\n    let waitForConnectionRefreshPromise: Promise<void> | undefined;\n    Object.assign<ConnectionContext, ConnectionContextMethods>(connectionContext, {\n      isConnectionClosing() {\n        // When the connection is not open, but the remote end is open,\n        // then the rhea connection is in the process of terminating.\n        return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());\n      },\n      async readyToOpenLink() {\n        logger.verbose(\n          `[${this.connectionId}] Waiting until the connection is ready to open link.`,\n        );\n        // Check that the connection isn't in the process of closing.\n        // This can happen when the idle timeout has been reached but\n        // the underlying socket is waiting to be destroyed.\n        if (this.isConnectionClosing()) {\n          logger.verbose(\n            `[${this.connectionId}] Connection is closing, waiting for disconnected event`,\n          );\n          // Wait for the disconnected event that indicates the underlying socket has closed.\n          await this.waitForDisconnectedEvent();\n        }\n\n        // Wait for the connection to be reset.\n        await this.waitForConnectionReset();\n        logger.verbose(`[${this.connectionId}] Connection is ready to open link.`);\n      },\n      waitForDisconnectedEvent() {\n        return new Promise((resolve) => {\n          logger.verbose(\n            `[${this.connectionId}] Attempting to reinitialize connection` +\n              ` but the connection is in the process of closing.` +\n              ` Waiting for the disconnect event before continuing.`,\n          );\n          this.connection.once(ConnectionEvents.disconnected, resolve);\n        });\n      },\n      waitForConnectionReset() {\n        // Check if the connection is currently in the process of disconnecting.\n        if (waitForConnectionRefreshPromise) {\n          logger.verbose(`[${this.connectionId}] Waiting for connection reset`);\n          return waitForConnectionRefreshPromise;\n        }\n\n        logger.verbose(\n          `[${this.connectionId}] Connection not waiting to be reset. Resolving immediately.`,\n        );\n        return Promise.resolve();\n      },\n      getReceiverFromCache(\n        receiverName: string,\n        sessionId?: string,\n      ): MessageReceiver | MessageSession | undefined {\n        if (sessionId != null && this.messageSessions[receiverName]) {\n          return this.messageSessions[receiverName];\n        }\n\n        if (this.messageReceivers[receiverName]) {\n          return this.messageReceivers[receiverName];\n        }\n\n        let existingReceivers = \"\";\n        if (sessionId != null) {\n          for (const messageSessionName of Object.keys(this.messageSessions)) {\n            if (this.messageSessions[messageSessionName].sessionId === sessionId) {\n              existingReceivers = this.messageSessions[messageSessionName].name;\n              break;\n            }\n          }\n        } else {\n          existingReceivers +=\n            (existingReceivers ? \", \" : \"\") + Object.keys(this.messageReceivers).join(\",\");\n        }\n\n        logger.verbose(\n          \"[%s] Failed to find receiver '%s' among existing receivers: %s\",\n          this.connectionId,\n          receiverName,\n          existingReceivers,\n        );\n        return;\n      },\n      getManagementClient(entityPath: string): ManagementClient {\n        if (!this.managementClients[entityPath]) {\n          this.managementClients[entityPath] = new ManagementClient(this, entityPath, {\n            address: `${entityPath}/$management`,\n          });\n        }\n        return this.managementClients[entityPath];\n      },\n    });\n\n    // Define listeners to be added to the connection object for\n    // \"connection_open\" and \"connection_error\" events.\n    const onConnectionOpen: OnAmqpEvent = () => {\n      connectionContext.wasConnectionCloseCalled = false;\n      logger.verbose(\n        \"[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.\",\n        connectionContext.connection.id,\n        connectionContext.wasConnectionCloseCalled,\n      );\n    };\n\n    const disconnected: OnAmqpEvent = async (context: EventContext) => {\n      if (waitForConnectionRefreshPromise) {\n        return;\n      }\n\n      waitForConnectionRefreshPromise = new Promise((resolve) => {\n        waitForConnectionRefreshResolve = resolve;\n      });\n\n      const connectionError =\n        context.connection && context.connection.error ? context.connection.error : undefined;\n      if (connectionError) {\n        logger.logError(\n          connectionError,\n          \"[%s] Error (context.connection.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n      const contextError = context.error;\n      if (contextError) {\n        logger.logError(\n          contextError,\n          \"[%s] Error (context.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n      const state: Readonly<{\n        wasConnectionCloseCalled: boolean;\n        numSenders: number;\n        numReceivers: number;\n      }> = {\n        wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,\n        numSenders: Object.keys(connectionContext.senders).length,\n        numReceivers:\n          Object.keys(connectionContext.messageReceivers).length +\n          Object.keys(connectionContext.messageSessions).length,\n      };\n\n      // Clear internal map maintained by rhea to avoid reconnecting of old links once the\n      // connection is back up.\n      connectionContext.connection.removeAllSessions();\n\n      // Close the cbs session to ensure all the event handlers are released.\n      await connectionContext.cbsSession.close();\n\n      // Close the management sessions to ensure all the event handlers are released.\n      for (const entityPath of Object.keys(connectionContext.managementClients)) {\n        await connectionContext.managementClients[entityPath].close();\n      }\n\n      if (state.wasConnectionCloseCalled) {\n        // Do Nothing\n      } else {\n        // Calling onDetached on sender\n        if (state.numSenders) {\n          // We don't do recovery for the sender:\n          //   Because we don't want to keep the sender active all the time\n          //   and the \"next\" send call would bear the burden of creating the link.\n          // Call onDetached() on sender so that it can gracefully shutdown\n          //   by cleaning up the timers and closing the links.\n          // We don't call onDetached for sender after `refreshConnection()`\n          //   because any new send calls that potentially initialize links would also get affected if called later.\n          logger.verbose(\n            `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${state.numSenders} ` +\n              `senders. We should not reconnect.`,\n          );\n          const detachCalls: Promise<void>[] = [];\n          for (const senderName of Object.keys(connectionContext.senders)) {\n            const sender = connectionContext.senders[senderName];\n            if (sender) {\n              logger.verbose(\n                \"[%s] calling detached on sender '%s'.\",\n                connectionContext.connection.id,\n                sender.name,\n              );\n              detachCalls.push(\n                sender.onDetached().catch((err) => {\n                  logger.logError(\n                    err,\n                    \"[%s] An error occurred while calling onDetached() the sender '%s'\",\n                    connectionContext.connection.id,\n                    sender.name,\n                  );\n                }),\n              );\n            }\n          }\n          await Promise.all(detachCalls);\n        }\n\n        // Calling onDetached on batching receivers for the same reasons as sender\n        const numBatchingReceivers = getNumberOfReceivers(connectionContext, \"batching\");\n        if (numBatchingReceivers) {\n          logger.verbose(\n            `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numBatchingReceivers} ` +\n              `batching receivers. We should not reconnect.`,\n          );\n\n          // Call onDetached() on receivers so that batching receivers it can gracefully close any ongoing batch operation\n          await callOnDetachedOnReceivers(\n            connectionContext,\n            connectionError || contextError,\n            \"batching\",\n          );\n        }\n\n        // Calling onDetached on session receivers\n        const numSessionReceivers = getNumberOfReceivers(connectionContext, \"session\");\n        if (numSessionReceivers) {\n          logger.verbose(\n            `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numSessionReceivers} ` +\n              `session receivers. We should close them.`,\n          );\n\n          await callOnDetachedOnSessionReceivers(\n            connectionContext,\n            connectionError || contextError,\n          );\n        }\n      }\n      await refreshConnection();\n      waitForConnectionRefreshResolve();\n      waitForConnectionRefreshPromise = undefined;\n      // The connection should always be brought back up if the sdk did not call connection.close()\n      // and there was at least one receiver link on the connection before it went down.\n      logger.verbose(\"[%s] state: %O\", connectionContext.connectionId, state);\n\n      // Calling onDetached on streaming receivers\n      const numStreamingReceivers = getNumberOfReceivers(connectionContext, \"streaming\");\n      if (!state.wasConnectionCloseCalled && numStreamingReceivers) {\n        logger.verbose(\n          `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numStreamingReceivers} ` +\n            `streaming receivers. We should reconnect.`,\n        );\n\n        // Calling `onDetached()` on streaming receivers after the refreshConnection() since `onDetached()` would\n        // recover the streaming receivers and that would only be possible after the connection is refreshed.\n        //\n        // This is different from the batching receiver since `onDetached()` for the batching receiver would\n        // return the outstanding messages and close the receive link.\n        await callOnDetachedOnReceivers(\n          connectionContext,\n          connectionError || contextError,\n          \"streaming\",\n        );\n      }\n    };\n\n    const protocolError: OnAmqpEvent = async (context: EventContext) => {\n      if (context.connection && context.connection.error) {\n        logger.logError(\n          context.connection.error,\n          \"[%s] Error (context.connection.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n      if (context.error) {\n        logger.logError(\n          context.error,\n          \"[%s] Error (context.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n    };\n\n    const error: OnAmqpEvent = async (context: EventContext) => {\n      if (context.connection && context.connection.error) {\n        logger.logError(\n          context.connection.error,\n          \"[%s] Error (context.connection.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n      if (context.error) {\n        logger.logError(\n          context.error,\n          \"[%s] Error (context.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n    };\n\n    async function refreshConnection(): Promise<void> {\n      const originalConnectionId = connectionContext.connectionId;\n      try {\n        await cleanConnectionContext();\n      } catch (err: any) {\n        logger.logError(\n          err,\n          `[${connectionContext.connectionId}] There was an error closing the connection before reconnecting`,\n        );\n      }\n      // Create a new connection, id, locks, and cbs client.\n      connectionContext.refreshConnection();\n      addConnectionListeners(connectionContext.connection);\n      logger.verbose(\n        `The connection \"${originalConnectionId}\" has been updated to \"${connectionContext.connectionId}\".`,\n      );\n    }\n\n    function addConnectionListeners(connection: Connection): void {\n      // Add listeners on the connection object.\n      connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);\n      connection.on(ConnectionEvents.disconnected, disconnected);\n      connection.on(ConnectionEvents.protocolError, protocolError);\n      connection.on(ConnectionEvents.error, error);\n    }\n\n    async function cleanConnectionContext(): Promise<void> {\n      // Remove listeners from the connection object.\n      connectionContext.connection.removeListener(\n        ConnectionEvents.connectionOpen,\n        onConnectionOpen,\n      );\n      connectionContext.connection.removeListener(ConnectionEvents.disconnected, disconnected);\n      connectionContext.connection.removeListener(ConnectionEvents.protocolError, protocolError);\n      connectionContext.connection.removeListener(ConnectionEvents.error, error);\n      // Close the connection\n      await connectionContext.connection.close();\n    }\n\n    addConnectionListeners(connectionContext.connection);\n\n    logger.verbose(\"[%s] Created connection context successfully.\", connectionContext.connectionId);\n\n    return connectionContext;\n  }\n\n  /**\n   * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for\n   * sender/receivers created by the queue/topic/subscription clients created by this\n   * ServiceBusClient.\n   * Once closed,\n   * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.\n   * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.\n   */\n  export async function close(context: ConnectionContext): Promise<void> {\n    const logPrefix = `[${context.connectionId}]`;\n\n    try {\n      logger.verbose(`${logPrefix} Permanently closing the amqp connection on the client.`);\n\n      const senderNames = Object.keys(context.senders);\n      const messageReceiverNames = Object.keys(context.messageReceivers);\n      const messageSessionNames = Object.keys(context.messageSessions);\n      const managementClientsEntityPaths = Object.keys(context.managementClients);\n      logger.verbose(\n        `${logPrefix} Permanently closing all the senders(${senderNames.length}), MessageReceivers(${messageReceiverNames.length}), MessageSessions(${messageSessionNames.length}), and ManagementClients(${managementClientsEntityPaths.length}).`,\n      );\n      await Promise.all([\n        ...senderNames.map((n) => context.senders[n].close()),\n        ...messageReceiverNames.map((n) => context.messageReceivers[n].close()),\n        ...messageSessionNames.map((n) => context.messageSessions[n].close()),\n        ...managementClientsEntityPaths.map((p) => context.managementClients[p].close()),\n      ]);\n\n      logger.verbose(`${logPrefix} Permanently closing cbsSession`);\n      await context.cbsSession.close();\n\n      logger.verbose(`${logPrefix} Permanently closing internal connection`);\n      await context.connection.close();\n      context.wasConnectionCloseCalled = true;\n      logger.verbose(`[${logPrefix} Permanently closed the amqp connection on the client.`);\n    } catch (err: any) {\n      const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));\n      logger.logError(err, `${logPrefix} An error occurred while closing the connection`);\n      throw errObj;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseConnectionString } from \"@azure/core-amqp\";\n\n/**\n * The set of properties that comprise a Service Bus connection string.\n */\nexport interface ServiceBusConnectionStringProperties {\n  /**\n   * The fully qualified Service Bus namespace extracted from the \"Endpoint\" in the\n   * connection string. This is likely to be similar to `{yournamespace}.servicebus.windows.net`.\n   * This is typically used to construct the ServiceBusClient.\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The value for \"Endpoint\" in the connection string.\n   */\n  endpoint: string;\n  /**\n   * The value for \"EntityPath\" in the connection string which would be the name of the queue or\n   * topic associated with the connection string.\n   * Connection string from a Shared Access Policy created at the namespace level\n   * will not have the EntityPath in it.\n   */\n  entityPath?: string;\n  /**\n   * The value for \"SharedAccessKey\" in the connection string. This along with the \"SharedAccessKeyName\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKey?: string;\n  /**\n   * The value for \"SharedAccessKeyName\" in the connection string. This along with the \"SharedAccessKey\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKeyName?: string;\n  /**\n   * The value for \"SharedAccessSignature\" in the connection string. This is typically not present in the\n   * connection string generated for a Shared Access Policy. It is instead generated by the\n   * user and appended to the connection string for ease of use.\n   */\n  sharedAccessSignature?: string;\n}\n\n/**\n * Parses given connection string into the different properties applicable to Azure Service Bus.\n * The properties are useful to then construct a ServiceBusClient.\n * @param connectionString - The connection string associated with the Shared Access Policy created\n * for the Service Bus namespace, queue or topic.\n */\nexport function parseServiceBusConnectionString(\n  connectionString: string,\n): ServiceBusConnectionStringProperties {\n  const parsedResult = parseConnectionString<{\n    Endpoint: string;\n    EntityPath?: string;\n    SharedAccessSignature?: string;\n    SharedAccessKey?: string;\n    SharedAccessKeyName?: string;\n  }>(connectionString);\n  if (!parsedResult.Endpoint) {\n    throw new Error(\"Connection string should have an Endpoint key.\");\n  }\n\n  if (parsedResult.SharedAccessSignature) {\n    if (parsedResult.SharedAccessKey || parsedResult.SharedAccessKeyName) {\n      throw new Error(\n        \"Connection string cannot have both SharedAccessSignature and SharedAccessKey keys.\",\n      );\n    }\n  } else if (parsedResult.SharedAccessKey && !parsedResult.SharedAccessKeyName) {\n    throw new Error(\"Connection string with SharedAccessKey should have SharedAccessKeyName.\");\n  } else if (!parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {\n    throw new Error(\n      \"Connection string with SharedAccessKeyName should have SharedAccessKey as well.\",\n    );\n  }\n\n  const output: ServiceBusConnectionStringProperties = {\n    fullyQualifiedNamespace: (parsedResult.Endpoint.match(\".*://([^/]*)\") || [])[1],\n    endpoint: parsedResult.Endpoint,\n  };\n  if (parsedResult.EntityPath) {\n    output.entityPath = parsedResult.EntityPath;\n  }\n  if (parsedResult.SharedAccessSignature) {\n    output.sharedAccessSignature = parsedResult.SharedAccessSignature;\n  }\n  if (parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {\n    output.sharedAccessKey = parsedResult.SharedAccessKey;\n    output.sharedAccessKeyName = parsedResult.SharedAccessKeyName;\n  }\n  return output;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  ConnectionConfig,\n  createSasTokenProvider,\n  RetryOptions,\n  SasTokenProvider,\n  WebSocketOptions,\n} from \"@azure/core-amqp\";\nimport {\n  isNamedKeyCredential,\n  isSASCredential,\n  NamedKeyCredential,\n  SASCredential,\n  TokenCredential,\n} from \"@azure/core-auth\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { UserAgentPolicyOptions } from \"@azure/core-rest-pipeline\";\nimport {\n  parseServiceBusConnectionString,\n  ServiceBusConnectionStringProperties,\n} from \"./util/connectionStringUtils\";\n\n/**\n * Describes the options that can be provided while creating the ServiceBusClient.\n *\n * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.\n *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`     : The retry options for all the operations on the client.\n *    - `maxRetries` : The number of times the operation can be retried in case of a retryable error.\n *    - `maxRetryDelayInMs`: The maximum delay between retries. Applicable only when performing exponential retries.\n *    - `mode`: Which retry mode to apply, specified by the `RetryMode` enum. Options are `Exponential` and `Fixed`. Defaults to `Fixed`.\n *    - `retryDelayInMs`: Amount of time to wait in milliseconds before making the next attempt. When `mode` is set to `Exponential`,\n *       this is used to compute the exponentially increasing delays between retries. Default: 30000 milliseconds.\n *    - `timeoutInMs`: Amount of time in milliseconds to wait before the operation times out. This will trigger a retry if there are any\n *       retry attempts remaining. Minimum value: 60000 milliseconds.\n */\nexport interface ServiceBusClientOptions {\n  /**\n   * ID to identify this client. This can be used to correlate logs and exceptions.\n   */\n  identifier?: string;\n  /**\n   * A custom endpoint to use when connecting to the Service Bus service.\n   * This can be useful when your network does not allow connecting to the\n   * standard Azure Service Bus endpoint address, but does allow connecting\n   * through an intermediary.\n   *\n   * Example: \"https://my.custom.endpoint:100/\"\n   */\n  customEndpointAddress?: string;\n  /**\n   * Retry policy options that determine the mode, number of retries, retry interval etc.\n   */\n  retryOptions?: RetryOptions;\n  /**\n   * Options to configure the channelling of the AMQP connection over Web Sockets.\n   */\n  webSocketOptions?: WebSocketOptions;\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentPolicyOptions;\n}\n\n// TODO: extract parseEndpoint and setCustomEndpointAddress into core-amqp\n// ConnectionConfig so that it can be shared between Event Hubs and Service Bus\n/**\n * Parses the host, hostname, and port from an endpoint.\n * @param endpoint - And endpoint to parse.\n * @internal\n */\nexport function parseEndpoint(endpoint: string): { host: string; hostname: string; port?: string } {\n  const hostMatch = endpoint.match(/.*:\\/\\/([^/]*)/);\n  if (!hostMatch) {\n    throw new TypeError(`Invalid endpoint missing host: ${endpoint}`);\n  }\n\n  const [, host] = hostMatch;\n  const [hostname, port] = host.split(\":\");\n\n  return { host, hostname, port };\n}\n/**\n * Updates the provided ConnectionConfig to use the custom endpoint address.\n * @param config - An existing connection configuration to be updated.\n * @param customEndpointAddress - The custom endpoint address to use.\n */\nfunction setCustomEndpointAddress(config: ConnectionConfig, customEndpointAddress: string): void {\n  // The amqpHostname should match the host prior to using the custom endpoint.\n  config.amqpHostname = config.host;\n  const { hostname, port } = parseEndpoint(customEndpointAddress);\n  // Since we specify the port separately, set host to the customEndpointAddress hostname.\n  config.host = hostname;\n  if (port) {\n    config.port = parseInt(port, 10);\n  }\n}\n\n/**\n * @internal\n *\n */\nexport function createConnectionContext(\n  connectionString: string,\n  credential: SasTokenProvider | TokenCredential,\n  options: ServiceBusClientOptions,\n): ConnectionContext {\n  const config = ConnectionConfig.create(connectionString);\n\n  config.webSocket = options?.webSocketOptions?.webSocket;\n  config.webSocketEndpointPath = \"$servicebus/websocket\";\n  config.webSocketConstructorOptions = options?.webSocketOptions?.webSocketConstructorOptions;\n\n  if (options?.customEndpointAddress) {\n    setCustomEndpointAddress(config, options.customEndpointAddress);\n  }\n\n  return ConnectionContext.create(config, credential, options);\n}\n\n/**\n * @internal\n */\nexport function createConnectionContextForConnectionString(\n  connectionString: string,\n  options: ServiceBusClientOptions = {},\n): ConnectionContext {\n  const parsed = parseServiceBusConnectionString(connectionString) as Required<\n    | Pick<ServiceBusConnectionStringProperties, \"sharedAccessKey\" | \"sharedAccessKeyName\">\n    | Pick<ServiceBusConnectionStringProperties, \"sharedAccessSignature\">\n  >;\n  const sasTokenProvider = createSasTokenProvider(parsed);\n  return createConnectionContext(connectionString, sasTokenProvider, options);\n}\n\n/**\n *\n * @internal\n */\nexport function createConnectionContextForCredential(\n  credential: TokenCredential | NamedKeyCredential | SASCredential,\n  host: string,\n  options: ServiceBusClientOptions = {},\n): ConnectionContext {\n  if (typeof host !== \"string\") {\n    throw new TypeError(\"`host` parameter is not a string\");\n  }\n\n  let tokenProvider: TokenCredential | SasTokenProvider;\n\n  // host, credential and options based constructor was invoked\n  if (!host.endsWith(\"/\")) {\n    host += \"/\";\n  }\n  if (isNamedKeyCredential(credential) || isSASCredential(credential)) {\n    tokenProvider = createSasTokenProvider(credential);\n  } else {\n    tokenProvider = credential;\n  }\n  const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;\n  return createConnectionContext(connectionString, tokenProvider, options);\n}\n\n/**\n * Parses a connection string and extracts the EntityPath named entity out.\n * @param connectionString - An entity specific Service Bus connection string.\n * @internal\n */\nexport function getEntityNameFromConnectionString(connectionString: string): string {\n  const entityPathMatch = connectionString.match(/^.+EntityPath=(.+?);{0,1}$/);\n\n  if (entityPathMatch != null && entityPathMatch.length === 2) {\n    return entityPathMatch[1];\n  } else {\n    throw new Error(\"No entity name present in the connection string\");\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Delivery, ReceiverOptions, Source } from \"rhea-promise\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { receiverLogger } from \"../log\";\nimport { ReceiveMode } from \"../models\";\nimport { Constants } from \"@azure/core-amqp\";\n\n/**\n * @internal\n */\nexport type ReceiverHandlers = Pick<\n  ReceiverOptions,\n  \"onMessage\" | \"onError\" | \"onClose\" | \"onSessionError\" | \"onSessionClose\" | \"onSettled\"\n>;\n\n/**\n * @internal\n */\nexport interface DeferredPromiseAndTimer {\n  resolve: (value?: any) => void;\n  reject: (reason?: any) => void;\n  timer: NodeJS.Timeout;\n}\n\n/**\n * This is the shared onSettled handler for all of the receiver implementations.\n *\n * The sequence is basically:\n * 1. User calls `await <ServiceBusMessage instance>.complete()`     (or other settlement methods)\n * 2. This creates a `Promise` that gets stored in the _deliveryDispositionMap\n * 3. When the service acknowledges the settlement this method gets called for that message.\n * 4. We resolve() the promise from the _deliveryDispositionMap.\n * 5. User's code after the settlement continues.\n *\n * @internal\n */\nexport function onMessageSettled(\n  logPrefix: string,\n  delivery: Delivery | undefined,\n  deliveryDispositionMap: Map<number, DeferredPromiseAndTimer>,\n): void {\n  if (delivery) {\n    const id = delivery.id;\n    const state = delivery.remote_state;\n    const settled = delivery.remote_settled;\n    receiverLogger.verbose(\n      \"%s Delivery with id %d, remote_settled: %s, remote_state: %o has been \" + \"received.\",\n      logPrefix,\n      id,\n      settled,\n      state && state.error ? state.error : state,\n    );\n    if (settled && deliveryDispositionMap.has(id)) {\n      const promise = deliveryDispositionMap.get(id) as DeferredPromiseAndTimer;\n      clearTimeout(promise.timer);\n      receiverLogger.verbose(\n        \"%s Found the delivery with id %d in the map and cleared the timer.\",\n        logPrefix,\n        id,\n      );\n      const deleteResult = deliveryDispositionMap.delete(id);\n      receiverLogger.verbose(\n        \"%s Successfully deleted the delivery with id %d from the map.\",\n        logPrefix,\n        id,\n        deleteResult,\n      );\n      if (state && state.error && (state.error.condition || state.error.description)) {\n        const error = translateServiceBusError(state.error);\n        return promise.reject(error);\n      }\n\n      return promise.resolve();\n    }\n  }\n}\n\n// Placed in Service Bus for now and can be promoted to core-amqp if also useful for Event Hubs in the future.\nconst timeoutName = `${Constants.vendorString}:timeout`;\n/**\n * Creates the options that need to be specified while creating an AMQP receiver link.\n *\n * @internal\n */\nexport function createReceiverOptions(\n  name: string,\n  receiveMode: ReceiveMode,\n  source: Source,\n  clientId: string,\n  handlers: ReceiverHandlers,\n  timeoutInMs?: number,\n): ReceiverOptions {\n  const properties =\n    timeoutInMs !== undefined\n      ? { [Constants.receiverIdentifierName]: clientId, [timeoutName]: timeoutInMs }\n      : { [Constants.receiverIdentifierName]: clientId };\n  const rcvrOptions: ReceiverOptions = {\n    name,\n    // \"autoaccept\" being true in the \"receiveAndDelete\" mode sets the \"settled\" flag to true on the deliveries\n    // which helps in clearing the circular buffer(size=2048) as it is needed to receive messages after 2048 of them are received.\n    autoaccept: receiveMode === \"receiveAndDelete\" ? true : false,\n    // receiveAndDelete -> first(0), peekLock -> second (1)\n    rcv_settle_mode: receiveMode === \"receiveAndDelete\" ? 0 : 1,\n    // receiveAndDelete -> settled (1), peekLock -> unsettled (0)\n    snd_settle_mode: receiveMode === \"receiveAndDelete\" ? 1 : 0,\n    source,\n    target: clientId,\n    credit_window: 0,\n    properties,\n    ...handlers,\n  };\n\n  return rcvrOptions;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Constants,\n  ErrorNameConditionMapper,\n  MessagingError,\n  RetryOptions,\n} from \"@azure/core-amqp\";\nimport { AmqpError, EventContext, OnAmqpEvent, Receiver, ReceiverOptions } from \"rhea-promise\";\nimport { receiverLogger as logger } from \"../log\";\nimport { LinkEntity, ReceiverType } from \"./linkEntity\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { DispositionType, ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { getUniqueName } from \"../util/utils\";\nimport { ProcessErrorArgs, ReceiveMode, SubscribeOptions } from \"../models\";\nimport { DispositionStatusOptions } from \"./managementClient\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  onMessageSettled,\n  DeferredPromiseAndTimer,\n  ReceiverHandlers,\n  createReceiverOptions,\n} from \"./shared\";\nimport { LockRenewer } from \"./autoLockRenewer\";\nimport { translateServiceBusError } from \"../serviceBusError\";\n\n/**\n * @internal\n */\nexport interface OnAmqpEventAsPromise extends OnAmqpEvent {\n  (context: EventContext): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport interface ReceiveOptions extends SubscribeOptions {\n  /**\n   * The mode in which messages should be received.\n   */\n  receiveMode: ReceiveMode;\n  /**\n   * Retry policy options that determine the mode, number of retries, retry interval etc.\n   */\n  retryOptions?: RetryOptions;\n\n  /**\n   * A LockAutoRenewer that will automatically renew locks based on user specified interval.\n   * This will be set if the user has chosen peekLock mode _and_ they've set a positive\n   * maxAutoRenewLockDurationInMs value when they created their receiver.\n   */\n  lockRenewer: LockRenewer | undefined;\n  /**\n   * Option to disable the client from running JSON.parse() on the message body when receiving the message.\n   * Not applicable if the message was sent with AMQP body type value or sequence. Use this option when you\n   * prefer to work directly with the bytes present in the message body than have the client attempt to parse it.\n   */\n  skipParsingBodyAsJson: boolean;\n\n  /**\n   * Whether to skip converting Date type on properties of message annotations\n   * or application properties into numbers when receiving the message. By\n   * default, properties of Date type is converted into UNIX epoch number for\n   * compatibility.\n   */\n  skipConvertingDate: boolean;\n}\n\n/**\n * Describes the signature of the message handler passed to `registerMessageHandler` method.\n * @internal\n */\nexport interface OnMessage {\n  /**\n   * Handler for processing each incoming message.\n   */\n  (message: ServiceBusMessageImpl): Promise<void>;\n}\n\n/**\n * Describes the signature of the error handler passed to `registerMessageHandler` method.\n *\n * @internal\n */\nexport interface OnError {\n  /**\n   * Handler for any error that occurs while receiving or processing messages.\n   *\n   * NOTE: if this signature changes make sure you reflect those same changes in the\n   * `OnErrorNoContext` definition below.\n   */\n  (args: ProcessErrorArgs): Promise<void>;\n}\n\n/**\n * An onError method but without the context property. Used when wrapping OnError\n * with an implicit ProcessErrorContext. Used by LockRenewer.\n *\n * @internal\n */\nexport interface OnErrorNoContext {\n  (error: MessagingError | Error): void;\n}\n\n/**\n * @internal\n * Describes the MessageReceiver that will receive messages from ServiceBus.\n */\nexport abstract class MessageReceiver extends LinkEntity<Receiver> {\n  /**\n   * The type of receiver: \"batching\" or \"streaming\".\n   */\n  receiverType: ReceiverType;\n  /**\n   * The mode in which messages should be received.\n   * Default: ReceiveMode.peekLock\n   */\n  receiveMode: ReceiveMode;\n  /**\n   * Indicates whether `Message.complete()` should be called\n   * automatically after the message processing is complete while receiving messages with handlers.\n   * Default: false.\n   */\n  autoComplete: boolean;\n  /**\n   * Maintains a map of deliveries that\n   * are being actively disposed. It acts as a store for correlating the responses received for\n   * active dispositions.\n   */\n  protected _deliveryDispositionMap: Map<number, DeferredPromiseAndTimer> = new Map<\n    number,\n    DeferredPromiseAndTimer\n  >();\n\n  /**\n   * A lock renewer that handles message lock auto-renewal. This is undefined unless the user\n   * has activated autolock renewal via ReceiveOptions. A single auto lock renewer is shared\n   * for all links for a `ServiceBusReceiver` instance.\n   */\n  protected _lockRenewer: LockRenewer | undefined;\n\n  constructor(\n    public identifier: string,\n    context: ConnectionContext,\n    entityPath: string,\n    receiverType: ReceiverType,\n    options: Omit<ReceiveOptions, \"maxConcurrentCalls\">,\n  ) {\n    super(entityPath, entityPath, context, receiverType, logger, {\n      address: entityPath,\n      audience: `${context.config.endpoint}${entityPath}`,\n    });\n\n    this.receiverType = receiverType;\n    this.receiveMode = options.receiveMode || \"peekLock\";\n\n    // If explicitly set to false then autoComplete is false else true (default).\n    this.autoComplete =\n      options.autoCompleteMessages === false ? options.autoCompleteMessages : true;\n    this._lockRenewer = options.lockRenewer;\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   */\n  protected _createReceiverOptions(\n    useNewName: boolean,\n    handlers: ReceiverHandlers,\n  ): ReceiverOptions {\n    const rcvrOptions: ReceiverOptions = createReceiverOptions(\n      useNewName ? getUniqueName(this.baseName) : this.name,\n      this.receiveMode,\n      {\n        address: this.address,\n      },\n      this.identifier,\n      {\n        onSettled: (context: EventContext) => {\n          return onMessageSettled(this.logPrefix, context.delivery, this._deliveryDispositionMap);\n        },\n        ...handlers,\n      },\n    );\n\n    return rcvrOptions;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   */\n  protected async _init(options: ReceiverOptions, abortSignal?: AbortSignalLike): Promise<void> {\n    try {\n      await this.initLink(options, abortSignal);\n\n      // It is possible for someone to close the receiver and then start it again.\n      // Thus make sure that the receiver is present in the client cache.\n      this._context.messageReceivers[this.name] = this as any;\n    } catch (err: any) {\n      const translatedError = translateServiceBusError(err);\n      logger.logError(\n        translatedError,\n        \"%s An error occured while creating the receiver\",\n        this.logPrefix,\n      );\n\n      // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.\n      if ((translatedError as MessagingError).code === \"OperationTimeoutError\") {\n        translatedError.message =\n          \"Failed to create a receiver within allocated time and retry attempts.\";\n      }\n\n      throw translatedError;\n    }\n  }\n\n  protected createRheaLink(\n    options: ReceiverOptions,\n    _abortSignal?: AbortSignalLike,\n  ): Promise<Receiver> {\n    return this._context.connection.createReceiver(options);\n  }\n\n  /**\n   * React to receiver being detached due to given error.\n   * You may want to set up retries to recover the broken link and/or report error to user.\n   * @param error - The error accompanying the receiver/session error or connection disconnected events\n   */\n  abstract onDetached(error?: AmqpError | Error): Promise<void>;\n\n  /**\n   * Clears lock renewal timers on all active messages, clears token remewal for current receiver,\n   * removes current MessageReceiver instance from cache, and closes the underlying AMQP receiver.\n   * @returns Promise<void>.\n   */\n  async close(): Promise<void> {\n    this._lockRenewer?.stopAll(this);\n    await super.close();\n  }\n\n  /**\n   * Settles the message with the specified disposition.\n   * @param message - The ServiceBus Message that needs to be settled.\n   * @param operation - The disposition type.\n   * @param options - Optional parameters that can be provided while disposing the message.\n   */\n  async settleMessage(\n    message: ServiceBusMessageImpl,\n    operation: DispositionType,\n    options: DispositionStatusOptions,\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {\n        return reject(new Error(`operation: '${operation}' is not a valid operation.`));\n      }\n      this._lockRenewer?.stop(this, message);\n      const delivery = message.delivery;\n      const timer = setTimeout(() => {\n        this._deliveryDispositionMap.delete(delivery.id);\n\n        logger.verbose(\n          \"%s Disposition for delivery id: %d, did not complete in %d milliseconds. \" +\n            \"Hence rejecting the promise with timeout error.\",\n          this.logPrefix,\n          delivery.id,\n          Constants.defaultOperationTimeoutInMs,\n        );\n\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description:\n            \"Operation to settle the message has timed out. The disposition of the \" +\n            \"message may or may not be successful\",\n        };\n        return reject(translateServiceBusError(e));\n      }, options.retryOptions?.timeoutInMs ?? Constants.defaultOperationTimeoutInMs);\n      this._deliveryDispositionMap.set(delivery.id, {\n        resolve: resolve,\n        reject: reject,\n        timer: timer,\n      });\n      if (operation === DispositionType.complete) {\n        delivery.accept();\n      } else if (operation === DispositionType.abandon) {\n        const params: any = {\n          undeliverable_here: false,\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.defer) {\n        const params: any = {\n          undeliverable_here: true,\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.deadletter) {\n        const error: AmqpError = {\n          condition: Constants.deadLetterName,\n          info: {\n            ...options.propertiesToModify,\n            DeadLetterReason: options.deadLetterReason,\n            DeadLetterErrorDescription: options.deadLetterDescription,\n          },\n        };\n        delivery.reject(error);\n      }\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport { Receiver, ReceiverEvents } from \"rhea-promise\";\nimport { receiverLogger as logger } from \"../log\";\nimport { ServiceBusError } from \"../serviceBusError\";\nimport { receiveDrainTimeoutInMs } from \"../util/constants\";\n\n/**\n * Wraps the receiver with some higher level operations for managing state\n * like credits, draining, etc...\n *\n * @internal\n */\nexport class ReceiverHelper {\n  private _isSuspended: boolean = true;\n\n  constructor(\n    private _getCurrentReceiver: () => { receiver: Receiver | undefined; logPrefix: string },\n  ) {}\n\n  private _getCurrentReceiverOrError():\n    | \"is undefined\"\n    | \"is not open\"\n    | \"is suspended\"\n    | { receiver: Receiver | undefined; logPrefix: string } {\n    const currentReceiverData = this._getCurrentReceiver();\n\n    if (currentReceiverData.receiver == null) {\n      return \"is undefined\";\n    }\n\n    if (!currentReceiverData.receiver.isOpen()) {\n      return \"is not open\";\n    }\n\n    if (this._isSuspended) {\n      return \"is suspended\";\n    }\n\n    return currentReceiverData;\n  }\n\n  /**\n   * Adds credits to the receiver, respecting any state that\n   * indicates the receiver is closed or should not continue\n   * to receive more messages.\n   *\n   * @param credits - Number of credits to add.\n   * or `stopReceivingMessages` has been called.\n   */\n  addCredit(credits: number): void {\n    const currentReceiverOrError = this._getCurrentReceiverOrError();\n\n    if (typeof currentReceiverOrError === \"string\") {\n      const errorMessage = `Cannot request messages on the receiver since it ${currentReceiverOrError}.`;\n\n      if (currentReceiverOrError === \"is suspended\") {\n        // if a user has suspended the receiver we should consider this a non-retryable\n        // error since it absolutely requires user intervention.\n        throw new AbortError(errorMessage);\n      }\n\n      throw new ServiceBusError(errorMessage, \"GeneralError\");\n    }\n\n    if (currentReceiverOrError.receiver != null) {\n      logger.verbose(`${currentReceiverOrError.logPrefix} Adding ${credits} credits`);\n      currentReceiverOrError.receiver.addCredit(credits);\n    }\n  }\n\n  /**\n   * Drains the credits for the receiver and prevents the `receiverHelper.addCredit()` method from adding credits.\n   * Call `resume()` to enable the `addCredit()` method.\n   */\n  async suspend(): Promise<void> {\n    const { receiver, logPrefix } = this._getCurrentReceiver();\n\n    this._isSuspended = true;\n\n    if (!this._isValidReceiver(receiver)) {\n      return;\n    }\n\n    logger.verbose(\n      `${logPrefix} User has requested to stop receiving new messages, attempting to drain.`,\n    );\n\n    return this.drain();\n  }\n\n  /**\n   * Resets tracking so `addCredit` works again by toggling the `_isSuspended` flag.\n   */\n  resume(): void {\n    this._isSuspended = false;\n  }\n\n  isSuspended(): boolean {\n    return this._isSuspended;\n  }\n\n  /**\n   * Initiates a drain for the current receiver and resolves when\n   * the drain has completed.\n   *\n   * NOTE: This method returns immediately if the receiver is not valid or if there\n   * are no pending credits on the receiver (ie: `receiver.credit === 0`).\n   */\n  async drain(): Promise<void> {\n    const { receiver, logPrefix } = this._getCurrentReceiver();\n\n    if (!this._isValidReceiver(receiver)) {\n      // TODO: should we throw?\n      return;\n    }\n\n    if (receiver.credit === 0) {\n      // nothing to drain\n      return;\n    }\n\n    logger.verbose(\n      `${logPrefix} Receiver is starting drain. Remaining credits; ${receiver.credit}`,\n    );\n\n    const drainPromise = new Promise<void>((resolve) => {\n      const timer = setTimeout(async () => {\n        logger.warning(`${logPrefix} Time out when draining credits in suspend().`);\n        // Close the receiver link since we have not received the receiver_drained event\n        // to prevent out-of-sync link state between local and remote\n        await receiver?.close();\n        resolve();\n      }, receiveDrainTimeoutInMs);\n      receiver.once(ReceiverEvents.receiverDrained, () => {\n        logger.verbose(`${logPrefix} Receiver has been drained.`);\n        receiver.drain = false;\n        clearTimeout(timer);\n        resolve();\n      });\n      receiver.drainCredit();\n    });\n\n    return drainPromise;\n  }\n\n  private _isValidReceiver(receiver: Receiver | undefined): receiver is Receiver {\n    return receiver != null && receiver.isOpen();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TracingContext, TracingSpanLink, TracingSpanOptions } from \"@azure/core-tracing\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { ServiceBusReceiver } from \"../receivers/receiver\";\nimport { ServiceBusMessage, ServiceBusReceivedMessage } from \"../serviceBusMessage\";\nimport { MessagingOperationNames, toSpanOptions, tracingClient } from \"./tracing\";\n\n/**\n * @internal\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * @hidden\n */\nexport interface InstrumentableMessage {\n  /**\n   * The application specific properties which can be\n   * used for custom message metadata.\n   */\n  applicationProperties?: { [key: string]: number | boolean | string | Date | null };\n}\n\n/**\n * Instruments an AMQP message with a proper `Diagnostic-Id` for tracing.\n *\n * @hidden\n */\nexport function instrumentMessage<T extends InstrumentableMessage>(\n  message: T,\n  options: OperationOptionsBase,\n  entityPath: string,\n  host: string,\n  operation: MessagingOperationNames,\n): {\n  /**\n   * If instrumentation was done, a copy of the message with\n   * message.applicationProperties['Diagnostic-Id'] filled\n   * out appropriately.\n   */\n  message: T;\n\n  /**\n   * A valid SpanContext if this message should be linked to a parent span, or undefined otherwise.\n   */\n  spanContext: TracingContext | undefined;\n} {\n  // check if the event has already been instrumented\n  const previouslyInstrumented = Boolean(message.applicationProperties?.[TRACEPARENT_PROPERTY]);\n\n  if (previouslyInstrumented) {\n    return {\n      message,\n      spanContext: undefined,\n    };\n  }\n\n  const { span: messageSpan, updatedOptions } = tracingClient.startSpan(\n    \"message\",\n    options,\n    toSpanOptions({ entityPath, host }, operation, \"producer\"),\n  );\n\n  try {\n    if (!messageSpan.isRecording()) {\n      return {\n        message,\n        spanContext: undefined,\n      };\n    }\n\n    const traceParent = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions?.tracingContext,\n    )[\"traceparent\"];\n\n    if (traceParent) {\n      // create a copy so the original isn't modified\n      message = {\n        ...message,\n        applicationProperties: {\n          ...message.applicationProperties,\n          [TRACEPARENT_PROPERTY]: traceParent,\n        },\n      };\n    }\n\n    return {\n      message,\n      spanContext: updatedOptions.tracingOptions?.tracingContext,\n    };\n  } finally {\n    messageSpan.end();\n  }\n}\n\n/**\n * Extracts the `SpanContext` from an `ServiceBusMessage` if the context exists.\n * @param message - An individual `ServiceBusMessage` object.\n * @internal\n */\nexport function extractSpanContextFromServiceBusMessage(\n  message: ServiceBusMessage,\n): TracingContext | undefined {\n  if (!message.applicationProperties || !message.applicationProperties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = message.applicationProperties[TRACEPARENT_PROPERTY] as string;\n  return tracingClient.parseTraceparentHeader(diagnosticId);\n}\n\n/**\n * Provides an iterable over messages, whether it is a single message or multiple\n * messages.\n *\n * @param receivedMessages - A single message or a set of messages\n * @internal\n */\nfunction* getReceivedMessages(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[],\n): Iterable<ServiceBusReceivedMessage> {\n  if (!Array.isArray(receivedMessages)) {\n    yield receivedMessages;\n  } else {\n    for (const message of receivedMessages) {\n      yield message;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function toProcessingSpanOptions(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[],\n  receiver: Pick<ServiceBusReceiver, \"entityPath\">,\n  connectionConfig: Pick<ConnectionContext[\"config\"], \"host\">,\n  operation: MessagingOperationNames,\n): TracingSpanOptions {\n  const spanLinks: TracingSpanLink[] = [];\n  for (const receivedMessage of getReceivedMessages(receivedMessages)) {\n    const tracingContext = extractSpanContextFromServiceBusMessage(receivedMessage);\n    if (tracingContext) {\n      spanLinks.push({\n        tracingContext,\n        attributes: {\n          enqueuedTime: receivedMessage.enqueuedTimeUtc?.getTime(),\n        },\n      });\n    }\n  }\n  return {\n    spanLinks,\n    spanKind: \"consumer\",\n    ...toSpanOptions({ host: connectionConfig.host, entityPath: receiver.entityPath }, operation),\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { MessageHandlers, ProcessErrorArgs } from \"../models\";\nimport { ServiceBusReceiver } from \"./receiver\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { createServiceBusLogger, logger, receiverLogger, ServiceBusLogger } from \"../log\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport {\n  DeadLetterOptions,\n  DispositionType,\n  ServiceBusMessageImpl,\n  ServiceBusReceivedMessage,\n} from \"../serviceBusMessage\";\nimport { DispositionStatusOptions } from \"../core/managementClient\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport {\n  Constants,\n  ErrorNameConditionMapper,\n  retry,\n  RetryConfig,\n  RetryMode,\n  RetryOperationType,\n  RetryOptions,\n} from \"@azure/core-amqp\";\nimport { MessageAlreadySettled } from \"../util/errors\";\nimport { delay, isDefined } from \"@azure/core-util\";\nimport { TracingSpanLink } from \"@azure/core-tracing\";\nimport { toSpanOptions, tracingClient } from \"../diagnostics/tracing\";\nimport { extractSpanContextFromServiceBusMessage } from \"../diagnostics/instrumentServiceBusMessage\";\n\n/**\n * @internal\n */\nexport function assertValidMessageHandlers(handlers: {\n  processMessage?: unknown;\n  processError?: unknown;\n}): void {\n  if (\n    handlers &&\n    handlers.processMessage instanceof Function &&\n    handlers.processError instanceof Function\n  ) {\n    return;\n  }\n\n  throw new TypeError('Invalid \"MessageHandlers\" provided.');\n}\n\n/**\n * @internal\n */\nexport async function* getMessageIterator(\n  receiver: Pick<ServiceBusReceiver, \"receiveMessages\">,\n  options?: OperationOptionsBase,\n): AsyncIterableIterator<ServiceBusReceivedMessage> {\n  while (true) {\n    const messages = await receiver.receiveMessages(1, options);\n\n    if (messages.length === 0) {\n      continue;\n    }\n\n    yield messages[0];\n  }\n}\n\n/**\n * @internal\n */\nexport function wrapProcessErrorHandler(\n  handlers: Pick<MessageHandlers, \"processError\">,\n  loggerParam: ServiceBusLogger = receiverLogger,\n): MessageHandlers[\"processError\"] {\n  return async (args: ProcessErrorArgs) => {\n    try {\n      args.error = translateServiceBusError(args.error);\n      await handlers.processError(args);\n    } catch (err: any) {\n      loggerParam.logError(err, `An error was thrown from the user's processError handler`);\n    }\n  };\n}\n\n/**\n * @internal\n *\n */\nexport function completeMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string,\n  retryOptions: RetryOptions | undefined,\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Completing the message with id '%s'.\",\n    context.connectionId,\n    message.messageId,\n  );\n  const tracingContext = extractSpanContextFromServiceBusMessage(message);\n  const spanLinks: TracingSpanLink[] = tracingContext ? [{ tracingContext }] : [];\n  return tracingClient.withSpan(\n    \"ServicebusReceiver.complete\",\n    {},\n    () =>\n      settleMessage(message, DispositionType.complete, context, entityPath, {\n        retryOptions,\n      }),\n    {\n      spanLinks,\n      ...toSpanOptions({ entityPath, host: context.config.host }, \"settle\", \"client\"),\n    },\n  );\n}\n\n/**\n * @internal\n *\n */\nexport function abandonMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string,\n  propertiesToModify: { [key: string]: number | boolean | string | Date | null } | undefined,\n  retryOptions: RetryOptions | undefined,\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Abandoning the message with id '%s'.\",\n    context.connectionId,\n    message.messageId,\n  );\n  const tracingContext = extractSpanContextFromServiceBusMessage(message);\n  const spanLinks: TracingSpanLink[] = tracingContext ? [{ tracingContext }] : [];\n  return tracingClient.withSpan(\n    \"ServicebusReceiver.abandon\",\n    {},\n    () =>\n      settleMessage(message, DispositionType.abandon, context, entityPath, {\n        propertiesToModify,\n        retryOptions,\n      }),\n    {\n      spanLinks,\n      ...toSpanOptions({ entityPath, host: context.config.host }, \"settle\", \"client\"),\n    },\n  );\n}\n\n/**\n * @internal\n *\n */\nexport function deferMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string,\n  propertiesToModify: { [key: string]: number | boolean | string | Date | null } | undefined,\n  retryOptions: RetryOptions | undefined,\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Deferring the message with id '%s'.\",\n    context.connectionId,\n    message.messageId,\n  );\n  const tracingContext = extractSpanContextFromServiceBusMessage(message);\n  const spanLinks: TracingSpanLink[] = tracingContext ? [{ tracingContext }] : [];\n  return tracingClient.withSpan(\n    \"ServiceBusReceiver.defer\",\n    {},\n    () =>\n      settleMessage(message, DispositionType.defer, context, entityPath, {\n        retryOptions,\n        propertiesToModify,\n      }),\n    {\n      spanLinks,\n      ...toSpanOptions({ entityPath, host: context.config.host }, \"settle\", \"client\"),\n    },\n  );\n}\n\n/**\n * @internal\n *\n */\nexport function deadLetterMessage(\n  message: ServiceBusMessageImpl,\n  context: ConnectionContext,\n  entityPath: string,\n  propertiesToModify:\n    | (DeadLetterOptions & { [key: string]: number | boolean | string | Date | null })\n    | undefined,\n  retryOptions: RetryOptions | undefined,\n): Promise<void> {\n  receiverLogger.verbose(\n    \"[%s] Deadlettering the message with id '%s'.\",\n    context.connectionId,\n    message.messageId,\n  );\n\n  const actualPropertiesToModify: Partial<DeadLetterOptions> = {\n    ...propertiesToModify,\n  };\n\n  // these two fields are handled specially and don't need to be in here.\n  delete actualPropertiesToModify.deadLetterErrorDescription;\n  delete actualPropertiesToModify.deadLetterReason;\n\n  const dispositionStatusOptions: DispositionStatusOptions = {\n    propertiesToModify: actualPropertiesToModify,\n    deadLetterReason: propertiesToModify?.deadLetterReason,\n    deadLetterDescription: propertiesToModify?.deadLetterErrorDescription,\n    retryOptions,\n  };\n\n  const tracingContext = extractSpanContextFromServiceBusMessage(message);\n  const spanLinks: TracingSpanLink[] = tracingContext ? [{ tracingContext }] : [];\n\n  return tracingClient.withSpan(\n    \"ServiceBusReceiver.deadLetter\",\n    {},\n    () =>\n      settleMessage(\n        message,\n        DispositionType.deadletter,\n        context,\n        entityPath,\n        dispositionStatusOptions,\n      ),\n    {\n      spanLinks,\n      ...toSpanOptions({ entityPath, host: context.config.host }, \"settle\", \"client\"),\n    },\n  );\n}\n\n/**\n * @internal\n */\nexport function settleMessage(\n  message: ServiceBusMessageImpl,\n  operation: DispositionType,\n  context: ConnectionContext,\n  entityPath: string,\n  options: DispositionStatusOptions,\n  _settleMessageOperation: typeof settleMessageOperation = settleMessageOperation,\n): Promise<void> {\n  return retry({\n    connectionId: context.connectionId,\n    operation: () => {\n      return _settleMessageOperation(message, operation, context, entityPath, options);\n    },\n    operationType: RetryOperationType.messageSettlement,\n    abortSignal: options?.abortSignal,\n    retryOptions: options?.retryOptions,\n  });\n}\n\n/**\n * @internal\n *\n * NOTE: it's tempting to make this method non-async. However, doing so makes it too easy\n * to throw exceptions that will not be \"catchable\" by people chaining to the returned Promise\n * since we can throw exceptions outside of the Promise's scope.\n */\nexport async function settleMessageOperation(\n  message: ServiceBusMessageImpl,\n  operation: DispositionType,\n  context: ConnectionContext,\n  entityPath: string,\n  options: DispositionStatusOptions,\n): Promise<void> {\n  const isDeferredMessage = !message.delivery.link;\n  const receiver = isDeferredMessage\n    ? undefined\n    : context.getReceiverFromCache(message.delivery.link.name, message.sessionId);\n  const associatedLinkName = receiver?.name;\n\n  let error: Error | undefined;\n  if (message.delivery.remote_settled) {\n    error = new Error(MessageAlreadySettled);\n  } else if (\n    !isDeferredMessage &&\n    (!receiver || !receiver.isOpen()) &&\n    isDefined(message.sessionId)\n  ) {\n    error = translateServiceBusError({\n      description:\n        `Failed to ${operation} the message as the AMQP link with which the message was ` +\n        `received is no longer alive.`,\n      condition: ErrorNameConditionMapper.SessionLockLostError,\n    });\n  }\n\n  if (error) {\n    receiverLogger.logError(\n      error,\n      \"[%s] An error occurred when settling a message with id '%s'\",\n      context.connectionId,\n      message.messageId,\n    );\n    throw error;\n  }\n\n  // Message Settlement with managementLink\n  // 1. If the received message is deferred as such messages can only be settled using managementLink\n  // 2. If the associated receiver link is not available. This does not apply to messages from sessions as we need a lock on the session to do so.\n  if (isDeferredMessage || ((!receiver || !receiver.isOpen()) && !isDefined(message.sessionId))) {\n    return context\n      .getManagementClient(entityPath)\n      .updateDispositionStatus(message.lockToken!, operation, {\n        ...options,\n        associatedLinkName,\n        sessionId: message.sessionId,\n      })\n      .catch((err) => {\n        throw translateServiceBusError(err);\n      });\n  }\n\n  return receiver!.settleMessage(message, operation, options).catch((err) => {\n    throw translateServiceBusError(err);\n  });\n}\n\n/** @internal */\nexport interface RetryForeverArgs<T> {\n  retryConfig: RetryConfig<T>;\n  onError: (err: Error) => void;\n  logger: ReturnType<typeof createServiceBusLogger>;\n  logPrefix: string;\n}\n\n/**\n * Calculates delay between retries, in milliseconds.\n */\nfunction calculateDelay(\n  attemptCount: number,\n  retryDelayInMs: number,\n  maxRetryDelayInMs: number,\n  mode: RetryMode,\n): number {\n  if (mode === RetryMode.Exponential) {\n    const boundedRandDelta =\n      retryDelayInMs * 0.8 +\n      Math.floor(Math.random() * (retryDelayInMs * 1.2 - retryDelayInMs * 0.8));\n\n    const incrementDelta = boundedRandDelta * (Math.pow(2, attemptCount) - 1);\n    return Math.min(incrementDelta, maxRetryDelayInMs);\n  }\n\n  return retryDelayInMs;\n}\n\n/**\n * Retry infinitely until success, reporting in between retry attempts.\n *\n * This function will only stop retrying if:\n * - args.retryConfig.operation resolves successfully\n * - args.retryConfig.operation rejects with an `AbortError`\n *\n * @internal\n */\nexport async function retryForever<T>(\n  args: RetryForeverArgs<T>,\n  retryFn: typeof retry = retry,\n): Promise<T> {\n  let numRetryCycles = 0;\n  const config = args.retryConfig;\n  if (!config.retryOptions) {\n    config.retryOptions = {};\n  }\n  // eslint-disable-next-line eqeqeq\n  if (config.retryOptions.retryDelayInMs == undefined || config.retryOptions.retryDelayInMs < 0) {\n    config.retryOptions.retryDelayInMs = Constants.defaultDelayBetweenOperationRetriesInMs;\n  }\n  if (\n    // eslint-disable-next-line eqeqeq\n    config.retryOptions.maxRetryDelayInMs == undefined ||\n    config.retryOptions.maxRetryDelayInMs < 0\n  ) {\n    config.retryOptions.maxRetryDelayInMs = Constants.defaultMaxDelayForExponentialRetryInMs;\n  }\n  if (!config.retryOptions.mode) {\n    config.retryOptions.mode = RetryMode.Fixed;\n  }\n\n  // The retries are broken up into cycles, giving the user some control over how often\n  // we actually attempt to retry.\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    ++numRetryCycles;\n\n    try {\n      return await retryFn(args.retryConfig);\n    } catch (err: any) {\n      // if the user aborts the operation we're immediately done.\n      // AbortError is also thrown by linkEntity.init() if the connection has been\n      // permanently closed.\n      if (err.name === \"AbortError\") {\n        logger.warning(`${args.logPrefix} AbortError caught, ending retries.`);\n        throw err;\n      }\n\n      // we only report the error here - this avoids spamming the user with too many\n      // redundant reports of errors while still providing them incremental status on failures.\n      try {\n        args.onError(err);\n      } catch (error: any) {\n        logger.error(\"args.onerror has thrown\", error);\n      }\n\n      args.logger.logError(\n        err,\n        `${args.logPrefix} Error thrown in retry cycle ${numRetryCycles}, restarting retry cycle with retry options`,\n        args.retryConfig,\n      );\n\n      const delayInMs = calculateDelay(\n        numRetryCycles,\n        config.retryOptions.retryDelayInMs,\n        config.retryOptions.maxRetryDelayInMs,\n        config.retryOptions.mode,\n      );\n      logger.verbose(\n        \"[%s] Sleeping for %d milliseconds for '%s'.\",\n        config.connectionId,\n        delayInMs,\n        config.operationType,\n      );\n      await delay(delayInMs, {\n        abortSignal: config.abortSignal,\n        abortErrorMsg: \"Retry cycle has been cancelled by the user.\",\n      });\n\n      continue;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { MessageReceiver, OnAmqpEventAsPromise, ReceiveOptions } from \"./messageReceiver\";\nimport { ConnectionContext } from \"../connectionContext\";\n\nimport { ReceiverHelper } from \"./receiverHelper\";\n\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport {\n  RetryOperationType,\n  MessagingError,\n  RetryOptions,\n  ConditionErrorNameMapper,\n} from \"@azure/core-amqp\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { receiverLogger as logger } from \"../log\";\nimport { AmqpError, EventContext, OnAmqpEvent } from \"rhea-promise\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { abandonMessage, completeMessage, retryForever } from \"../receivers/receiverCommon\";\nimport { ReceiverHandlers } from \"./shared\";\nimport {\n  InternalMessageHandlers,\n  InternalProcessErrorArgs,\n  MessageHandlers,\n  ProcessErrorArgs,\n  SubscribeOptions,\n} from \"../models\";\nimport { toProcessingSpanOptions } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { tracingClient } from \"../diagnostics/tracing\";\n\n/**\n * @internal\n */\nexport interface StreamingReceiverInitArgs\n  extends ReceiveOptions,\n    Pick<OperationOptionsBase, \"abortSignal\"> {\n  messageHandlers: MessageHandlers;\n}\n\n/**\n * @internal\n * Describes the streaming receiver where the user can receive the message\n * by providing handler functions.\n */\nexport class StreamingReceiver extends MessageReceiver {\n  /**\n   * The maximum number of messages that should be\n   * processed concurrently while in streaming mode. Once this limit has been reached, more\n   * messages will not be received until the user's message handler has completed processing current message.\n   * Default: 1\n   */\n  maxConcurrentCalls: number = 1;\n\n  /**\n   * Indicates whether the receiver is already actively\n   * running `onDetached`.\n   * This is expected to be true while the receiver attempts\n   * to bring its link back up due to a retryable issue.\n   */\n  private _isDetaching: boolean = false;\n  /**\n   *Retry policy options that determine the mode, number of retries, retry interval etc.\n   */\n  private _retryOptions: RetryOptions;\n\n  private _receiverHelper: ReceiverHelper;\n\n  /**\n   * The user's message handlers, wrapped so any thrown exceptions are properly logged\n   * or forwarded to the user's processError handler.\n   */\n  private _messageHandlers: () => Required<InternalMessageHandlers> = () => {\n    throw new Error(\"messageHandlers are not set.\");\n  };\n\n  /**\n   * The subscribe(options) passed when the subscribe call originally happened. Stored\n   * so _subscribeImpl() can re-use them later if we have to restart our subscription\n   * when detach/reattaching.\n   */\n  private _subscribeOptions: SubscribeOptions | undefined;\n\n  /**\n   * Used so we can stub out retry in tests.\n   */\n  private _retryForeverFn: typeof retryForever = retryForever;\n\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_close\" event.\n   */\n  private _onAmqpClose: OnAmqpEventAsPromise;\n\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEventAsPromise;\n\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_error\" event.\n   */\n  private _onAmqpError: OnAmqpEvent;\n\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"message\" event.\n   */\n  protected _onAmqpMessage: OnAmqpEventAsPromise;\n\n  /**\n   * Whether we are currently subscribed (or subscribing) for receiving messages.\n   * (this is irrespective of receiver state, etc... - it's just a simple flag to prevent\n   * multiple subscribe() calls from happening on this instance)\n   */\n  public get isSubscribeActive(): boolean {\n    return !this._receiverHelper.isSuspended();\n  }\n\n  /**\n   * Instantiate a new Streaming receiver for receiving messages with handlers.\n   *\n   * @param identifier - the name used to identifier the receiver\n   * @param connectionContext - The client entity context.\n   * @param options - Options for how you'd like to connect.\n   */\n  constructor(\n    identifier: string,\n    connectionContext: ConnectionContext,\n    entityPath: string,\n    options: ReceiveOptions,\n  ) {\n    super(identifier, connectionContext, entityPath, \"streaming\", options);\n\n    if (typeof options?.maxConcurrentCalls === \"number\" && options?.maxConcurrentCalls > 0) {\n      this.maxConcurrentCalls = options.maxConcurrentCalls;\n    }\n\n    this._retryOptions = options?.retryOptions || {};\n\n    this._receiverHelper = new ReceiverHelper(() => ({\n      receiver: this.link,\n      logPrefix: this.logPrefix,\n    }));\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      const receiver = this.link || context.receiver!;\n\n      logger.logError(\n        receiverError,\n        `${this.logPrefix} 'receiver_close' event occurred. The associated error is`,\n      );\n\n      this._lockRenewer?.stopAll(this);\n\n      if (receiver && !receiver.isItselfClosed()) {\n        await this.onDetached(receiverError);\n      } else {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver '%s' with address '%s' \" +\n            \"because the sdk initiated it. Hence not calling detached from the _onAmqpClose\" +\n            \"() handler.\",\n          this.logPrefix,\n          this.name,\n          this.address,\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const receiver = this.link || context.receiver!;\n      const sessionError = context.session && context.session.error;\n\n      logger.logError(\n        sessionError,\n        `${this.logPrefix} 'session_close' event occurred. The associated error is`,\n      );\n\n      this._lockRenewer?.stopAll(this);\n\n      if (receiver && !receiver.isSessionItselfClosed()) {\n        await this.onDetached(sessionError);\n      } else {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the session of receiver '%s' with address \" +\n            \"'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose\" +\n            \"() handler.\",\n          this.logPrefix,\n          this.name,\n          this.address,\n        );\n      }\n    };\n\n    this._onAmqpError = (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        logger.logError(\n          sbError,\n          `${this.logPrefix} 'receiver_error' event occurred. The associated error is`,\n        );\n        this._messageHandlers().processError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n          identifier,\n        });\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError) as MessagingError;\n        logger.logError(\n          sbError,\n          `${this.logPrefix} 'session_error' event occurred. The associated error is`,\n        );\n        this._messageHandlers().processError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n          identifier,\n        });\n      }\n    };\n\n    this._onAmqpMessage = async (context: EventContext) => {\n      // If the receiver got closed in PeekLock mode, avoid processing the message as we\n      // cannot settle the message.\n      if (this.receiveMode === \"peekLock\" && (!this.link || !this.link.isOpen())) {\n        logger.verbose(\n          \"%s Not calling the user's message handler for the current message \" +\n            \"as the receiver is closed\",\n          this.logPrefix,\n        );\n        return;\n      }\n\n      const bMessage: ServiceBusMessageImpl = new ServiceBusMessageImpl(\n        context.message!,\n        context.delivery!,\n        true,\n        this.receiveMode,\n        options.skipParsingBodyAsJson ?? false,\n        options.skipConvertingDate ?? false,\n      );\n\n      this._lockRenewer?.start(this, bMessage, (err) => {\n        this._messageHandlers().processError({\n          error: err,\n          errorSource: \"renewLock\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n          identifier,\n        });\n      });\n\n      try {\n        await this._messageHandlers().processMessage(bMessage);\n      } catch (err: any) {\n        logger.logError(\n          err,\n          \"%s An error occurred while running user's message handler for the message \" +\n            \"with id '%s' on the receiver '%s'\",\n          this.logPrefix,\n          bMessage.messageId,\n          this.name,\n        );\n\n        // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,\n        // doing this here. Otherwise, this should be done in finally.\n        this._lockRenewer?.stop(this, bMessage);\n        const error = translateServiceBusError(err) as MessagingError;\n        // Nothing much to do if user's message handler throws. Let us try abandoning the message.\n        if (\n          !bMessage.delivery.remote_settled &&\n          error.code !== ConditionErrorNameMapper[\"com.microsoft:message-lock-lost\"] &&\n          this.receiveMode === \"peekLock\" &&\n          this.isOpen() // only try to abandon the messages if the connection is still open\n        ) {\n          try {\n            logger.logError(\n              error,\n              \"%s Abandoning the message with id '%s' on the receiver '%s' since \" +\n                \"an error occured: %O.\",\n              this.logPrefix,\n              bMessage.messageId,\n              this.name,\n              error,\n            );\n            await abandonMessage(\n              bMessage,\n              this._context,\n              entityPath,\n              undefined,\n              this._retryOptions,\n            );\n          } catch (abandonError: any) {\n            const translatedError = translateServiceBusError(abandonError);\n            logger.logError(\n              translatedError,\n              \"%s An error occurred while abandoning the message with id '%s' on the \" +\n                \"receiver '%s'\",\n              this.logPrefix,\n              bMessage.messageId,\n              this.name,\n            );\n            this._messageHandlers().processError({\n              error: translatedError,\n              errorSource: \"abandon\",\n              entityPath: this.entityPath,\n              fullyQualifiedNamespace: this._context.config.host,\n              identifier,\n            });\n          }\n        }\n        return;\n      } finally {\n        try {\n          this._receiverHelper.addCredit(1);\n        } catch (err: any) {\n          // if we're aborting out of the receive operation we don't need to report it (the user already\n          // knows the link is being torn down or stopped)\n          if (err.name !== \"AbortError\") {\n            logger.logError(\n              err,\n              `[${this.logPrefix}] Failed to add credit after receiving message`,\n            );\n            await this._reportInternalError(err);\n          }\n        }\n      }\n\n      // If we've made it this far, then user's message handler completed fine. Let us try\n      // completing the message.\n      if (\n        this.autoComplete &&\n        this.receiveMode === \"peekLock\" &&\n        !bMessage.delivery.remote_settled\n      ) {\n        try {\n          logger.verbose(\n            \"%s Auto completing the message with id '%s' on \" + \"the receiver.\",\n            this.logPrefix,\n            bMessage.messageId,\n          );\n          await completeMessage(bMessage, this._context, entityPath, this._retryOptions);\n        } catch (completeError: any) {\n          const translatedError = translateServiceBusError(completeError);\n          logger.logError(\n            translatedError,\n            \"%s An error occurred while completing the message with id '%s' on the \" +\n              \"receiver '%s'\",\n            this.logPrefix,\n            bMessage.messageId,\n            this.name,\n          );\n          this._messageHandlers().processError({\n            error: translatedError,\n            errorSource: \"complete\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n            identifier,\n          });\n        }\n      }\n    };\n  }\n\n  private _reportInternalError(error: Error): Promise<void> {\n    const messageHandlers = this._messageHandlers();\n\n    if (messageHandlers.forwardInternalErrors) {\n      const errorArgs: InternalProcessErrorArgs = {\n        error,\n        entityPath: this.entityPath,\n        errorSource: \"internal\",\n        fullyQualifiedNamespace: this._context.config.host,\n        identifier: this.identifier,\n      };\n\n      return messageHandlers.processError(errorArgs as ProcessErrorArgs);\n    }\n\n    return Promise.resolve();\n  }\n\n  private _getHandlers(): ReceiverHandlers {\n    return {\n      onMessage: (context: EventContext) =>\n        this._onAmqpMessage(context).catch((err) => this._reportInternalError(err)),\n      onClose: (context: EventContext) =>\n        this._onAmqpClose(context).catch((err) => this._reportInternalError(err)),\n      onSessionClose: (context: EventContext) =>\n        this._onSessionClose(context).catch((err) => this._reportInternalError(err)),\n      onError: this._onAmqpError,\n      onSessionError: this._onSessionError,\n    };\n  }\n\n  async stopReceivingMessages(): Promise<void> {\n    await this._receiverHelper.suspend();\n\n    if (this._subscribeCallPromise) {\n      await this._subscribeCallPromise;\n    }\n  }\n\n  async close(): Promise<void> {\n    await this._receiverHelper.suspend();\n    return super.close();\n  }\n\n  private _subscribeCallPromise: Promise<void> | undefined;\n\n  /**\n   * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.\n   *\n   * Any errors thrown by this function will also be sent to the messageHandlers.processError function\n   * _and_ thrown, ultimately from this method.\n   *\n   * NOTE: This function retries _infinitely_ until success! It is completely up to the user to break\n   * out of this retry cycle otherwise by:\n   * 1. closing the receiver\n   * 2. Calling `close` on the subscription instance they received when they initially called subscribe().\n   * 3. aborting the abortSignal they passed in when calling subscribe (this also applies to initialization calls in onDetach)\n   *\n   * @param onMessage - The message handler to receive servicebus messages.\n   * @param onError - The error handler to receive an error that occurs while receivin messages.\n   */\n  async subscribe(\n    messageHandlers: InternalMessageHandlers,\n    subscribeOptions: SubscribeOptions | undefined,\n  ): Promise<void> {\n    // these options and message handlers will be re-used if/when onDetach is called.\n    this._subscribeOptions = subscribeOptions;\n    this._setMessageHandlers(messageHandlers, subscribeOptions);\n\n    let promiseResolve: (() => void) | undefined;\n    this._subscribeCallPromise = new Promise((resolve) => {\n      promiseResolve = resolve;\n    });\n\n    try {\n      this._receiverHelper.resume();\n      return await this._subscribeImpl(\"subscribe\");\n    } catch (err: any) {\n      // callers aren't going to be in a good position to forward this error properly\n      // so we do it here.\n      await this._messageHandlers().processError({\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host,\n        errorSource: \"receive\",\n        error: err,\n        identifier: this.identifier,\n      });\n\n      throw err;\n    } finally {\n      promiseResolve?.();\n      this._subscribeCallPromise = undefined;\n    }\n  }\n\n  /**\n   * Wraps the individual message handlers with tracing and proper error handling\n   * and assigns them to `this._messageHandlers`\n   *\n   * @param userHandlers - The user's message handlers\n   * @param operationOptions - The subscribe(options)\n   */\n  private _setMessageHandlers(\n    userHandlers: InternalMessageHandlers,\n    operationOptions: OperationOptionsBase | undefined,\n  ): void {\n    const messageHandlers = {\n      processError: async (args: ProcessErrorArgs) => {\n        try {\n          args.error = translateServiceBusError(args.error);\n          await userHandlers.processError(args);\n        } catch (err: any) {\n          await this._reportInternalError(err);\n          logger.logError(err, `An error was thrown from the user's processError handler`);\n        }\n      },\n      processMessage: async (message: ServiceBusMessageImpl) => {\n        try {\n          await tracingClient.withSpan(\n            \"StreamReceiver.process\",\n            operationOptions ?? {},\n            () => userHandlers.processMessage(message),\n            toProcessingSpanOptions(message, this, this._context.config, \"process\"),\n          );\n        } catch (err: any) {\n          this._messageHandlers().processError({\n            error: err,\n            errorSource: \"processMessageCallback\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n            identifier: this.identifier,\n          });\n          throw err;\n        }\n      },\n      postInitialize: async () => {\n        if (!userHandlers.postInitialize) {\n          return;\n        }\n\n        return userHandlers.postInitialize().catch((err) =>\n          this._messageHandlers().processError({\n            error: err,\n            errorSource: \"processMessageCallback\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n            identifier: this.identifier,\n          }),\n        );\n      },\n      preInitialize: async () => {\n        if (!userHandlers.preInitialize) {\n          return;\n        }\n\n        return userHandlers.preInitialize().catch((err) =>\n          this._messageHandlers().processError({\n            error: err,\n            errorSource: \"processMessageCallback\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n            identifier: this.identifier,\n          }),\n        );\n      },\n      forwardInternalErrors: userHandlers.forwardInternalErrors ?? false,\n    };\n\n    this._messageHandlers = () => messageHandlers;\n  }\n\n  /**\n   * Subscribes using the already assigned `this._messageHandlers` and `this._subscribeOptions`\n   *\n   * @returns A promise that will resolve when a link is created and we successfully add credits to it.\n   */\n  private async _subscribeImpl(caller: \"detach\" | \"subscribe\"): Promise<void> {\n    try {\n      // we don't expect to ever get an error from retryForever but bugs\n      // do happen.\n      return await this._retryForeverFn({\n        retryConfig: {\n          connectionId: this._context.connection.id,\n          operationType: RetryOperationType.receiverLink,\n          abortSignal: this._subscribeOptions?.abortSignal,\n          retryOptions: this._retryOptions,\n          operation: () => this._initAndAddCreditOperation(caller),\n        },\n        onError: (err) =>\n          this._messageHandlers().processError({\n            error: err,\n            errorSource: \"receive\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n            identifier: this.identifier,\n          }),\n        logPrefix: this.logPrefix,\n        logger,\n      });\n    } catch (err: any) {\n      try {\n        await this._receiverHelper.suspend();\n      } catch (error: any) {\n        logger.logError(error, `${this.logPrefix} receiver.suspend threw an error`);\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Initializes the link and adds credits. If any of these operations fail any created link will\n   * be closed.\n   *\n   * @param caller - The caller which dictates whether or not we create a new name for our created link.\n   * @param catchAndReportError - A function and reports an error but does not throw it.\n   */\n  private async _initAndAddCreditOperation(caller: \"detach\" | \"subscribe\"): Promise<void> {\n    if (this._receiverHelper.isSuspended()) {\n      // user has suspended us while we were initializing\n      // the connection. Abort this attempt - if they attempt\n      // resubscribe we'll just reinitialize.\n      // This checks should happen before throwErrorIfConnectionClosed(); otherwise\n      // we won't be able to break out of the retry-for-ever loops when user suspend us.\n      throw new AbortError(\"Receiver was suspended during initialization.\");\n    }\n\n    throwErrorIfConnectionClosed(this._context);\n\n    await this._messageHandlers().preInitialize();\n\n    if (this._receiverHelper.isSuspended()) {\n      // Need to check again as user can suspend us in preInitialize()\n      throw new AbortError(\"Receiver was suspended during initialization.\");\n    }\n    await this._init(\n      this._createReceiverOptions(caller === \"detach\", this._getHandlers()),\n      this._subscribeOptions?.abortSignal,\n    );\n\n    try {\n      await this._messageHandlers().postInitialize();\n      this._receiverHelper.addCredit(this.maxConcurrentCalls);\n    } catch (err: any) {\n      try {\n        await this.closeLink();\n      } catch (error: any) {\n        await this._messageHandlers().processError({\n          error,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n          identifier: this.identifier,\n        });\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Will reconnect the receiver link if necessary.\n   * @param receiverError - The receiver error or connection error, if any.\n   */\n  async onDetached(receiverError?: AmqpError | Error): Promise<void> {\n    try {\n      logger.verbose(`${this.logPrefix} onDetached: reinitializing link.`);\n\n      // User explicitly called `close` on the receiver, so link is already closed\n      // and we can exit early.\n      if (this.wasClosedPermanently) {\n        logger.verbose(\n          `${this.logPrefix} onDetached: link has been closed permanently, not reinitializing. `,\n        );\n        return;\n      }\n\n      // Prevent multiple onDetached invocations from running concurrently.\n      if (this._isDetaching) {\n        // This can happen when the network connection goes down for some amount of time.\n        // The first connection `disconnect` will trigger `onDetached` and attempt to retry\n        // creating the connection/receiver link.\n        // While those retry attempts fail (until the network connection comes back up),\n        // we'll continue to see connection `disconnect` errors.\n        // These should be ignored until the already running `onDetached` completes\n        // its retry attempts or errors.\n        logger.verbose(\n          `${this.logPrefix} onDetached: Call to detached on streaming receiver '${this.name}' is already in progress.`,\n        );\n        return;\n      }\n\n      this._isDetaching = true;\n\n      const translatedError = receiverError\n        ? translateServiceBusError(receiverError)\n        : receiverError;\n      logger.logError(\n        translatedError,\n        `${this.logPrefix} onDetached: Reinitializing receiver because of error`,\n      );\n\n      // Clears the token renewal timer. Closes the link and its session if they are open.\n      // Removes the link and its session if they are present in rhea's cache.\n      await this.closeLink();\n    } catch (err: any) {\n      logger.verbose(\n        `${this.logPrefix} onDetached: Encountered an error when closing the previous link: `,\n        err,\n      );\n    }\n\n    try {\n      await this._subscribeImpl(\"detach\");\n    } finally {\n      this._isDetaching = false;\n    }\n  }\n\n  protected removeLinkFromContext(): void {\n    delete this._context.messageReceivers[this.name];\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { receiverLogger as logger } from \"../log\";\nimport {\n  AmqpError,\n  EventContext,\n  OnAmqpEvent,\n  ReceiverEvents,\n  SessionEvents,\n  Receiver as RheaPromiseReceiver,\n  Session,\n} from \"rhea-promise\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { MessageReceiver, OnAmqpEventAsPromise, ReceiveOptions } from \"./messageReceiver\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { checkAndRegisterWithAbortSignal } from \"../util/utils\";\nimport { receiveDrainTimeoutInMs } from \"../util/constants\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { toProcessingSpanOptions } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { ReceiveMode } from \"../models\";\nimport { ServiceBusError, translateServiceBusError } from \"../serviceBusError\";\nimport { tracingClient } from \"../diagnostics/tracing\";\n\n/**\n * Describes the batching receiver where the user can receive a specified number of messages for\n * a predefined time.\n * @internal\n */\nexport class BatchingReceiver extends MessageReceiver {\n  /**\n   * Instantiate a new BatchingReceiver.\n   *\n   * @param identifier - name to identify this receiver.\n   * @param connectionContext - The client entity context.\n   * @param options - Options for how you'd like to connect.\n   */\n  constructor(\n    identifier: string,\n    connectionContext: ConnectionContext,\n    entityPath: string,\n    options: ReceiveOptions,\n  ) {\n    super(identifier, connectionContext, entityPath, \"batching\", options);\n\n    this._batchingReceiverLite = new BatchingReceiverLite(\n      connectionContext,\n      entityPath,\n      async (abortSignal?: AbortSignalLike): Promise<MinimalReceiver | undefined> => {\n        let lastError: Error | AmqpError | undefined;\n\n        const rcvrOptions = this._createReceiverOptions(false, {\n          onError: (context) => {\n            lastError = context?.receiver?.error;\n          },\n          onSessionError: (context) => {\n            lastError = context?.session?.error;\n          },\n          onClose: async () => {\n            /** Nothing to do here - the next call will just fail so they'll get an appropriate error from somewhere else. */\n          },\n          onSessionClose: async () => {\n            /** Nothing to do here - the next call will just fail so they'll get an appropriate error from somewhere else. */\n          },\n          onMessage: async () => {\n            /** Nothing to do here -  we don't add credits initially so we don't need to worry about handling any messages.*/\n          },\n        });\n\n        await this._init(rcvrOptions, abortSignal);\n\n        if (lastError != null) {\n          throw lastError;\n        }\n\n        return this.link;\n      },\n      this.receiveMode,\n      options.skipParsingBodyAsJson ?? false,\n      options.skipConvertingDate ?? false,\n    );\n  }\n\n  private _batchingReceiverLite: BatchingReceiverLite;\n\n  get isReceivingMessages(): boolean {\n    return this._batchingReceiverLite.isReceivingMessages;\n  }\n\n  /**\n   * To be called when connection is disconnected to gracefully close ongoing receive request.\n   * @param connectionError - The connection error if any.\n   */\n  async onDetached(connectionError?: AmqpError | Error): Promise<void> {\n    await this.closeLink();\n\n    if (connectionError == null) {\n      connectionError = new Error(\n        \"Unknown error occurred on the AMQP connection while receiving messages.\",\n      );\n    }\n\n    this._batchingReceiverLite.terminate(connectionError);\n  }\n\n  /**\n   * Receives a batch of messages from a ServiceBus Queue/Topic.\n   * @param maxMessageCount - The maximum number of messages to receive.\n   * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.\n   * @param maxWaitTimeInMs - The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.\n   * @param maxTimeAfterFirstMessageInMs - The total amount of time to wait after the first message\n   * has been received. Defaults to 1 second.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * @returns A promise that resolves with an array of Message objects.\n   */\n  async receive(\n    maxMessageCount: number,\n    maxWaitTimeInMs: number,\n    maxTimeAfterFirstMessageInMs: number,\n    options: OperationOptionsBase,\n  ): Promise<ServiceBusMessageImpl[]> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const messages = await this._batchingReceiverLite.receiveMessages({\n        maxMessageCount,\n        maxWaitTimeInMs,\n        maxTimeAfterFirstMessageInMs,\n        ...options,\n      });\n\n      if (this._lockRenewer) {\n        for (const message of messages) {\n          this._lockRenewer.start(this, message, (_error) => {\n            // the auto lock renewer already logs this in a detailed way. So this hook is mainly here\n            // to potentially forward the error to the user (which we're not doing yet)\n          });\n        }\n      }\n\n      return messages;\n    } catch (error: any) {\n      logger.logError(error, \"[%s] Rejecting receiveMessages()\", this.logPrefix);\n      throw error;\n    }\n  }\n\n  static create(\n    clientId: string,\n    context: ConnectionContext,\n    entityPath: string,\n    options: ReceiveOptions,\n  ): BatchingReceiver {\n    throwErrorIfConnectionClosed(context);\n    const bReceiver = new BatchingReceiver(clientId, context, entityPath, options);\n    context.messageReceivers[bReceiver.name] = bReceiver;\n    return bReceiver;\n  }\n\n  protected removeLinkFromContext(): void {\n    delete this._context.messageReceivers[this.name];\n  }\n}\n\n/**\n * Gets a function that returns the smaller of the two timeouts,\n * taking into account elapsed time from when getRemainingWaitTimeInMsFn\n * was called.\n *\n * @param maxWaitTimeInMs - Maximum time to wait for the first message\n * @param maxTimeAfterFirstMessageInMs - Maximum time to wait after the first message before completing the receive.\n *\n * @internal\n */\nexport function getRemainingWaitTimeInMsFn(\n  maxWaitTimeInMs: number,\n  maxTimeAfterFirstMessageInMs: number,\n): () => number {\n  const startTimeMs = Date.now();\n\n  return () => {\n    const remainingTimeMs = maxWaitTimeInMs - (Date.now() - startTimeMs);\n\n    if (remainingTimeMs < 0) {\n      return 0;\n    }\n\n    return Math.min(remainingTimeMs, maxTimeAfterFirstMessageInMs);\n  };\n}\n\n/**\n * Useful interface that mimics EventEmitter without requiring us to actually\n * import the events definition (which is annoying with browsers).\n *\n * @internal\n */\ntype EventEmitterLike<T extends RheaPromiseReceiver | Session> = Pick<\n  T,\n  \"once\" | \"removeListener\" | \"on\"\n>;\n\n/**\n * The bare minimum needed to receive messages for batched\n * message receiving.\n *\n * @internal\n */\nexport type MinimalReceiver = Pick<\n  RheaPromiseReceiver,\n  \"name\" | \"isOpen\" | \"credit\" | \"addCredit\" | \"drain\" | \"drainCredit\" | \"close\"\n> &\n  EventEmitterLike<RheaPromiseReceiver> & {\n    session: EventEmitterLike<Session>;\n  } & {\n    connection: {\n      id: string;\n    };\n  };\n\n/**\n * @internal\n */\ntype MessageAndDelivery = Pick<EventContext, \"message\" | \"delivery\">;\n\n/**\n * @internal\n */\ninterface ReceiveMessageArgs extends OperationOptionsBase {\n  maxMessageCount: number;\n  maxWaitTimeInMs: number;\n  maxTimeAfterFirstMessageInMs: number;\n}\n\n/**\n * The internals of a batching receiver minus anything that would require us to hold onto a client entity context\n * or a receiver on a permanent basis.\n *\n * Usable with both session and non-session receivers.\n *\n * @internal\n */\nexport class BatchingReceiverLite {\n  // testing hook\n  private _drainTimeoutInMs: number = receiveDrainTimeoutInMs;\n  constructor(\n    private _connectionContext: ConnectionContext,\n    public entityPath: string,\n    private _getCurrentReceiver: (\n      abortSignal?: AbortSignalLike,\n    ) => Promise<MinimalReceiver | undefined>,\n    private _receiveMode: ReceiveMode,\n    _skipParsingBodyAsJson: boolean,\n    _skipConvertingDate: boolean,\n  ) {\n    this._createServiceBusMessage = (context: MessageAndDelivery) => {\n      return new ServiceBusMessageImpl(\n        context.message!,\n        context.delivery!,\n        true,\n        this._receiveMode,\n        _skipParsingBodyAsJson,\n        _skipConvertingDate,\n      );\n    };\n\n    this._getRemainingWaitTimeInMsFn = (\n      maxWaitTimeInMs: number,\n      maxTimeAfterFirstMessageInMs: number,\n    ) => getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs);\n\n    this.isReceivingMessages = false;\n  }\n\n  private _createServiceBusMessage: (\n    context: Pick<EventContext, \"message\" | \"delivery\">,\n  ) => ServiceBusMessageImpl;\n\n  private _getRemainingWaitTimeInMsFn: typeof getRemainingWaitTimeInMsFn;\n  private _closeHandler: ((connectionError?: AmqpError | Error) => void) | undefined;\n  private _finalAction: (() => void) | undefined;\n\n  isReceivingMessages: boolean;\n\n  /**\n   * Receives a set of messages,\n   *\n   * @internal\n   * @hidden\n   */\n  public async receiveMessages(args: ReceiveMessageArgs): Promise<ServiceBusMessageImpl[]> {\n    try {\n      this.isReceivingMessages = true;\n      const receiver = await this._getCurrentReceiver(args.abortSignal);\n\n      if (receiver == null) {\n        // (was somehow closed in between the init() and the return)\n        throw new ServiceBusError(\"Link closed before receiving messages.\", \"GeneralError\");\n      }\n\n      const messages = await new Promise<ServiceBusMessageImpl[]>((resolve, reject) =>\n        this._receiveMessagesImpl(receiver, args, resolve, reject),\n      );\n      return tracingClient.withSpan(\n        \"BatchingReceiverLite.process\",\n        args,\n        () => messages,\n        toProcessingSpanOptions(messages, this, this._connectionContext.config, \"process\"),\n      );\n    } finally {\n      this._closeHandler = undefined;\n      this.isReceivingMessages = false;\n    }\n  }\n\n  /**\n   * Closes the receiver (optionally with an error), cancelling any current operations.\n   *\n   * @param connectionError - An optional error (rhea doesn't always deliver one for certain disconnection events)\n   */\n  terminate(connectionError?: Error | AmqpError): void {\n    if (this._closeHandler) {\n      this._closeHandler(connectionError);\n      this._closeHandler = undefined;\n    }\n  }\n\n  private async tryDrainReceiver(\n    receiver: MinimalReceiver,\n    loggingPrefix: string,\n    remainingWaitTimeInMs: number,\n    abortSignal?: AbortSignalLike,\n  ): Promise<void> {\n    if (!receiver.isOpen() || receiver.credit <= 0) {\n      return;\n    }\n    let drainTimedout: boolean = false;\n    let drainTimer: ReturnType<typeof setTimeout>;\n    const timeToWaitInMs = Math.max(this._drainTimeoutInMs, remainingWaitTimeInMs);\n    const drainPromise = new Promise<void>((resolve) => {\n      function drainListener() {\n        logger.verbose(`${loggingPrefix} Receiver has been drained.`);\n        clearTimeout(drainTimer);\n        resolve();\n      }\n      function removeListeners() {\n        abortSignal?.removeEventListener(\"abort\", onAbort);\n        receiver.removeListener(ReceiverEvents.receiverDrained, drainListener);\n      }\n      function onAbort() {\n        removeListeners();\n        clearTimeout(drainTimer);\n        resolve();\n      }\n\n      drainTimer = setTimeout(() => {\n        drainTimedout = true;\n        removeListeners();\n        resolve();\n      }, timeToWaitInMs);\n      receiver.once(ReceiverEvents.receiverDrained, drainListener);\n      abortSignal?.addEventListener(\"abort\", onAbort);\n    });\n\n    receiver.drainCredit();\n    logger.verbose(\n      `${loggingPrefix} Draining leftover credits(${receiver.credit}), waiting for event_drained event, or timing out after ${timeToWaitInMs} milliseconds...`,\n    );\n    await drainPromise;\n    if (drainTimedout) {\n      logger.warning(\n        `${loggingPrefix} Time out after ${timeToWaitInMs} milliseconds when draining credits. Closing receiver...`,\n      );\n      // Close the receiver link since we have not received the receiver drain event\n      // to prevent out-of-sync state between local and remote\n      await receiver.close();\n    }\n\n    // Turn off draining.\n    receiver.drain = false;\n  }\n\n  private _receiveMessagesImpl(\n    receiver: MinimalReceiver,\n    args: ReceiveMessageArgs,\n    origResolve: (messages: ServiceBusMessageImpl[]) => void,\n    origReject: (err: Error | AmqpError) => void,\n  ): void {\n    const getRemainingWaitTimeInMs = this._getRemainingWaitTimeInMsFn(\n      args.maxWaitTimeInMs,\n      args.maxTimeAfterFirstMessageInMs,\n    );\n\n    const brokeredMessages: ServiceBusMessageImpl[] = [];\n    const loggingPrefix = `[${receiver.connection.id}|r:${receiver.name}]`;\n\n    let totalWaitTimer: NodeJS.Timeout | undefined;\n    // eslint-disable-next-line prefer-const\n    let cleanupBeforeResolveOrReject: () => void;\n\n    const rejectAfterCleanup = (err: Error | AmqpError): void => {\n      cleanupBeforeResolveOrReject();\n      origReject(err);\n    };\n\n    const resolveImmediately = (result: ServiceBusMessageImpl[]): void => {\n      cleanupBeforeResolveOrReject();\n      origResolve(result);\n    };\n\n    const resolveAfterPendingMessageCallbacks = (result: ServiceBusMessageImpl[]): void => {\n      // NOTE: through rhea-promise, most of our event handlers are made asynchronous by calling setTimeout(emit).\n      // However, a small set (*error and drain) execute immediately. This can lead to a situation where the logical\n      // ordering of events is correct but the execution order is incorrect because the events are not all getting\n      // put into the task queue the same way.\n      // setTimeout() ensures that we resolve _after_ any already-queued onMessage handlers that may\n      // be waiting in the task queue.\n      setTimeout(() => {\n        cleanupBeforeResolveOrReject();\n        origResolve(result);\n      });\n    };\n\n    const onError: OnAmqpEvent = (context: EventContext) => {\n      const eventType = context.session?.error != null ? \"session_error\" : \"receiver_error\";\n      let error = context.session?.error || context.receiver?.error;\n\n      if (error) {\n        error = translateServiceBusError(error);\n        logger.logError(error, `${loggingPrefix} '${eventType}' event occurred. Received an error`);\n      } else {\n        error = new ServiceBusError(\"An error occurred while receiving messages.\", \"GeneralError\");\n      }\n      rejectAfterCleanup(error);\n    };\n\n    this._closeHandler = (error?: AmqpError | Error): void => {\n      if (\n        // no error, just closing. Go ahead and return what we have.\n        error == null ||\n        // Return the collected messages if in ReceiveAndDelete mode because otherwise they are lost forever\n        (this._receiveMode === \"receiveAndDelete\" && brokeredMessages.length)\n      ) {\n        logger.verbose(\n          `${loggingPrefix} Closing. Resolving with ${brokeredMessages.length} messages.`,\n        );\n        return resolveAfterPendingMessageCallbacks(brokeredMessages);\n      }\n\n      rejectAfterCleanup(translateServiceBusError(error));\n    };\n\n    let abortSignalCleanupFunction: (() => void) | undefined = undefined;\n\n    // Final action to be performed after\n    // - maxMessageCount is reached or\n    // - maxWaitTime is passed or\n    // - newMessageWaitTimeoutInSeconds is passed since the last message was received\n    this._finalAction = async (): Promise<void> => {\n      if (receiver.drain) {\n        // If a drain is already in process then we should let it complete. Some messages might still be in flight, but they will\n        // arrive before the drain completes.\n        logger.verbose(`${loggingPrefix} Already draining.`);\n        return;\n      }\n\n      const remainingWaitTimeInMs = getRemainingWaitTimeInMs();\n      await this.tryDrainReceiver(receiver, loggingPrefix, remainingWaitTimeInMs, args.abortSignal);\n      logger.verbose(\n        `${loggingPrefix} Resolving receiveMessages() with ${brokeredMessages.length} messages.`,\n      );\n      resolveImmediately(brokeredMessages);\n    };\n\n    // Action to be performed on the \"message\" event.\n    const onReceiveMessage: OnAmqpEventAsPromise = async (context: EventContext) => {\n      // TODO: this appears to be aggravating a bug that we need to look into more deeply.\n      // The same timeout+drain sequence should work fine for receiveAndDelete but it appears\n      // to cause problems.\n      if (this._receiveMode === \"peekLock\") {\n        if (brokeredMessages.length === 0) {\n          // We'll now remove the old timer (which was the overall `maxWaitTimeMs` timer)\n          // and replace it with another timer that is a (probably) much shorter interval.\n          //\n          // This allows the user to get access to received messages earlier and also gives us\n          // a chance to have fewer messages internally that could get lost if the user's\n          // app crashes.\n          if (totalWaitTimer) clearTimeout(totalWaitTimer);\n          const remainingWaitTimeInMs = getRemainingWaitTimeInMs();\n          totalWaitTimer = setTimeout(() => {\n            logger.verbose(\n              `${loggingPrefix} Batching, waited for ${remainingWaitTimeInMs} milliseconds after receiving the first message.`,\n            );\n            this._finalAction!();\n          }, remainingWaitTimeInMs);\n        }\n      }\n\n      try {\n        const data: ServiceBusMessageImpl = this._createServiceBusMessage(context);\n        brokeredMessages.push(data);\n\n        // NOTE: we used to actually \"lose\" any extra messages. At this point I've fixed the areas that were causing us to receive\n        // extra messages but if this bug arises in some other way it's better to return the message than it would be to let it be\n        // silently dropped on the floor.\n        if (brokeredMessages.length > args.maxMessageCount) {\n          logger.warning(\n            `More messages arrived than expected: ${args.maxMessageCount} vs ${brokeredMessages.length}`,\n          );\n        }\n      } catch (err: any) {\n        const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));\n        logger.logError(\n          err,\n          `${loggingPrefix} Received an error while converting AmqpMessage to ServiceBusMessage`,\n        );\n        rejectAfterCleanup(errObj);\n      }\n      if (brokeredMessages.length >= args.maxMessageCount) {\n        this._finalAction!();\n      }\n    };\n\n    const onClose: OnAmqpEventAsPromise = async (context: EventContext) => {\n      const type = context.session?.error != null ? \"session_closed\" : \"receiver_closed\";\n      const error = context.session?.error || context.receiver?.error;\n\n      if (error) {\n        logger.logError(error, `${loggingPrefix} '${type}' event occurred. The associated error`);\n      }\n    };\n\n    cleanupBeforeResolveOrReject = (): void => {\n      if (receiver != null) {\n        receiver.removeListener(ReceiverEvents.receiverError, onError);\n        receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n        receiver.session.removeListener(SessionEvents.sessionError, onError);\n        receiver.removeListener(ReceiverEvents.receiverClose, onClose);\n        receiver.session.removeListener(SessionEvents.sessionClose, onClose);\n      }\n\n      if (totalWaitTimer) {\n        clearTimeout(totalWaitTimer);\n      }\n\n      if (abortSignalCleanupFunction) {\n        abortSignalCleanupFunction();\n      }\n      abortSignalCleanupFunction = undefined;\n    };\n\n    abortSignalCleanupFunction = checkAndRegisterWithAbortSignal((err) => {\n      if (receiver.drain) {\n        // If a drain is already in process and we cancel, the link state may be out of sync\n        // with remote. Reset the link so that we will have fresh start.\n        receiver.close();\n      }\n      rejectAfterCleanup(err);\n    }, args.abortSignal);\n\n    // By adding credit here, we let the service know that at max we can handle `maxMessageCount`\n    // number of messages concurrently. We will return the user an array of messages that can\n    // be of size upto maxMessageCount. Then the user needs to accordingly dispose\n    // (complete/abandon/defer/deadletter) the messages from the array.\n    const creditToAdd = args.maxMessageCount - receiver.credit;\n    logger.verbose(\n      `${loggingPrefix} Ensure enough credit for receiving ${args.maxMessageCount} messages. Current: ${receiver.credit}.  To add: ${creditToAdd}.`,\n    );\n\n    if (creditToAdd > 0) {\n      receiver.addCredit(creditToAdd);\n    }\n\n    logger.verbose(\n      `${loggingPrefix} Setting the wait timer for ${args.maxWaitTimeInMs} milliseconds.`,\n    );\n\n    totalWaitTimer = setTimeout(() => {\n      logger.verbose(\n        `${loggingPrefix} Batching, waited for max wait time ${args.maxWaitTimeInMs} milliseconds.`,\n      );\n      this._finalAction!();\n    }, args.maxWaitTimeInMs);\n\n    receiver.on(ReceiverEvents.message, onReceiveMessage);\n    receiver.on(ReceiverEvents.receiverError, onError);\n    receiver.on(ReceiverEvents.receiverClose, onClose);\n\n    receiver.session.on(SessionEvents.sessionError, onError);\n    receiver.session.on(SessionEvents.sessionClose, onClose);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionContext } from \"../connectionContext\";\nimport { receiverLogger as logger } from \"../log\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { calculateRenewAfterDuration } from \"../util/utils\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { OnErrorNoContext } from \"./messageReceiver\";\n\n/**\n * @internal\n */\nexport type RenewableMessageProperties = Readonly<\n  Pick<ServiceBusMessageImpl, \"lockToken\" | \"messageId\">\n> &\n  // updated when we renew the lock\n  Pick<ServiceBusMessageImpl, \"lockedUntilUtc\">;\n\n/**\n * @internal\n */\ntype MinimalLink = Pick<LinkEntity<any>, \"name\" | \"logPrefix\" | \"entityPath\">;\n\n/**\n * Tracks locks for messages, renewing until a configurable duration.\n *\n * @internal\n */\nexport class LockRenewer {\n  /**\n   * A map of link names to individual maps for each\n   * link that map a message ID to its auto-renewal timer.\n   */\n  private _messageRenewLockTimers = new Map<string, Map<string, NodeJS.Timeout | undefined>>();\n\n  // just here for make unit testing a bit easier.\n  private _calculateRenewAfterDuration: typeof calculateRenewAfterDuration;\n\n  constructor(\n    private _context: Pick<ConnectionContext, \"getManagementClient\">,\n    private _maxAutoRenewDurationInMs: number,\n  ) {\n    this._calculateRenewAfterDuration = calculateRenewAfterDuration;\n  }\n\n  /**\n   * Creates an AutoLockRenewer.\n   *\n   * @param linkEntity - Your link entity instance (probably 'this')\n   * @param context - The connection context for your link entity (probably 'this._context')\n   * @param options - The ReceiveOptions passed through to your message receiver.\n   * @returns if the lock mode is peek lock (or if is unspecified, thus defaulting to peekLock)\n   * and the options.maxAutoLockRenewalDurationInMs is greater than 0..Otherwise, returns undefined.\n   */\n  static create(\n    context: Pick<ConnectionContext, \"getManagementClient\">,\n    maxAutoRenewLockDurationInMs: number,\n    receiveMode: \"peekLock\" | \"receiveAndDelete\",\n  ): LockRenewer | undefined {\n    if (receiveMode !== \"peekLock\") {\n      return undefined;\n    }\n\n    if (maxAutoRenewLockDurationInMs <= 0) {\n      return undefined;\n    }\n\n    return new LockRenewer(context, maxAutoRenewLockDurationInMs);\n  }\n\n  /**\n   * Cancels all pending lock renewals for messages on given link and removes all entries from our internal cache.\n   */\n  stopAll(linkEntity: MinimalLink): void {\n    logger.verbose(\n      `${linkEntity.logPrefix} Clearing message renew lock timers for all the active messages.`,\n    );\n\n    const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);\n\n    if (messagesForLink == null) {\n      return;\n    }\n\n    for (const messageId of messagesForLink.keys()) {\n      this._stopAndRemoveById(linkEntity, messagesForLink, messageId);\n    }\n\n    this._messageRenewLockTimers.delete(linkEntity.name);\n  }\n\n  /**\n   * Stops lock renewal for a single message.\n   *\n   * @param bMessage - The message whose lock renewal we will stop.\n   */\n  stop(linkEntity: MinimalLink, bMessage: RenewableMessageProperties): void {\n    const messageId = bMessage.messageId as string;\n\n    const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);\n\n    if (messagesForLink == null) {\n      return;\n    }\n\n    this._stopAndRemoveById(linkEntity, messagesForLink, messageId);\n  }\n\n  /**\n   * Starts lock renewal for a single message.\n   *\n   * @param bMessage - The message whose lock renewal we will start.\n   */\n  start(\n    linkEntity: MinimalLink,\n    bMessage: RenewableMessageProperties,\n    onError: OnErrorNoContext,\n  ): void {\n    try {\n      const logPrefix = linkEntity.logPrefix;\n\n      if (bMessage.lockToken == null) {\n        throw new Error(\n          `Can't start auto lock renewal for message with message id '${bMessage.messageId}' since it does not have a lock token.`,\n        );\n      }\n\n      const lockToken = bMessage.lockToken;\n      const linkMessageMap = this._getOrCreateMapForLink(linkEntity);\n      // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.\n      // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInMs\n      // - We should be able to clear the renewal timer when the user's message handler\n      // is done (whether it succeeds or fails).\n      // Setting the messageId with undefined value in the linkMessageMap because we\n      // track state by checking the presence of messageId in the map. It is removed from the map\n      // when an attempt is made to settle the message (either by the user or by the sdk) OR\n      // when the execution of user's message handler completes.\n      linkMessageMap.set(bMessage.messageId as string, undefined);\n\n      logger.verbose(\n        `${logPrefix} message with id '${\n          bMessage.messageId\n        }' is locked until ${bMessage.lockedUntilUtc!.toString()}.`,\n      );\n      const totalAutoLockRenewDuration = Date.now() + this._maxAutoRenewDurationInMs;\n      const totalAutoLockRenewDurationDate = new Date(totalAutoLockRenewDuration);\n      logger.verbose(\n        `${logPrefix} Total autolockrenew duration for message with id '${\n          bMessage.messageId\n        }' is: ${totalAutoLockRenewDurationDate.toString()}`,\n      );\n\n      const autoRenewLockTask = (): void => {\n        const renewalNeededToMaintainLock =\n          // if the lock expires _after_ our max auto-renew duration there's no reason to\n          // spin up an auto-renewer - it's already held for the duration.\n          totalAutoLockRenewDurationDate > bMessage.lockedUntilUtc!;\n\n        if (!renewalNeededToMaintainLock) {\n          logger.verbose(\n            `${logPrefix} Autolockrenew not needed as message's lockedUntilUtc ${bMessage.lockedUntilUtc} is after the total autolockrenew duration ${totalAutoLockRenewDurationDate} for message with messageId '${bMessage.messageId}'. Hence we will stop the autoLockRenewTask.`,\n          );\n          this.stop(linkEntity, bMessage);\n        } else if (Date.now() >= totalAutoLockRenewDuration) {\n          // once we've exceeded the max amount of time we'll renew we can stop.\n          logger.verbose(\n            `${logPrefix} Current time ${new Date()} exceeds the total autolockrenew duration ${totalAutoLockRenewDurationDate} for message with messageId '${\n              bMessage.messageId\n            }'. Hence we will stop the autoLockRenewTask.`,\n          );\n          this.stop(linkEntity, bMessage);\n        } else {\n          if (linkMessageMap.has(bMessage.messageId as string)) {\n            // TODO: We can run into problems with clock skew between the client and the server.\n            // It would be better to calculate the duration based on the \"lockDuration\" property\n            // of the queue. However, we do not have the management plane of the client ready for\n            // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.\n            const amount = this._calculateRenewAfterDuration(bMessage.lockedUntilUtc!);\n\n            logger.verbose(\n              `${logPrefix} Sleeping for ${amount} milliseconds while renewing the lock for message with id '${bMessage.messageId}'`,\n            );\n            // Setting the value of the messageId to the actual timer. This will be cleared when\n            // an attempt is made to settle the message (either by the user or by the sdk) OR\n            // when the execution of user's message handler completes.\n            const autoRenewTimer = setTimeout(async () => {\n              try {\n                logger.verbose(\n                  `${logPrefix} Attempting to renew the lock for message with id '${bMessage.messageId}'.`,\n                );\n\n                bMessage.lockedUntilUtc = await this._context\n                  .getManagementClient(linkEntity.entityPath)\n                  .renewLock(lockToken, {\n                    associatedLinkName: linkEntity.name,\n                  });\n                logger.verbose(\n                  `${logPrefix} Successfully renewed the lock for message with id '${bMessage.messageId}'. Starting next auto-lock-renew cycle for message.`,\n                );\n\n                autoRenewLockTask();\n              } catch (err: any) {\n                logger.logError(\n                  err,\n                  `${logPrefix} An error occurred while auto renewing the message lock '${bMessage.lockToken}' for message with id '${bMessage.messageId}'`,\n                );\n                onError(err);\n              }\n            }, amount);\n\n            // Prevent the active Timer from keeping the Node.js event loop active.\n            if (typeof autoRenewTimer.unref === \"function\") {\n              autoRenewTimer.unref();\n            }\n\n            linkMessageMap.set(bMessage.messageId as string, autoRenewTimer);\n          } else {\n            logger.verbose(\n              `${logPrefix} Looks like the message lock renew timer has already been cleared for message with id '${bMessage.messageId}'.`,\n            );\n          }\n        }\n      };\n\n      // start\n      autoRenewLockTask();\n    } catch (err: any) {\n      onError(err);\n    }\n  }\n\n  private _getOrCreateMapForLink(linkEntity: MinimalLink): Map<string, NodeJS.Timeout | undefined> {\n    if (!this._messageRenewLockTimers.has(linkEntity.name)) {\n      this._messageRenewLockTimers.set(\n        linkEntity.name,\n        new Map<string, NodeJS.Timeout | undefined>(),\n      );\n    }\n\n    return this._messageRenewLockTimers.get(linkEntity.name)!;\n  }\n\n  private _stopAndRemoveById(\n    linkEntity: MinimalLink,\n    linkMessageMap: Map<string, NodeJS.Timeout | undefined>,\n    messageId: string | undefined,\n  ): void {\n    if (messageId == null) {\n      throw new Error(\"Failed to stop auto lock renewal - no message ID\");\n    }\n\n    // TODO: messageId doesn't actually need to be unique. Perhaps we should use lockToken\n    // instead?\n    if (linkMessageMap.has(messageId)) {\n      clearTimeout(linkMessageMap.get(messageId) as NodeJS.Timeout);\n      logger.verbose(\n        `${linkEntity.logPrefix} Cleared the message renew lock timer for message with id '${messageId}'.`,\n      );\n      linkMessageMap.delete(messageId);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  PeekMessagesOptions,\n  GetMessageIteratorOptions,\n  MessageHandlers,\n  ReceiveMessagesOptions,\n  SubscribeOptions,\n} from \"../models\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { ServiceBusReceivedMessage } from \"../serviceBusMessage\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport {\n  getAlreadyReceivingErrorMsg,\n  getReceiverClosedErrorMsg,\n  InvalidMaxMessageCountError,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwErrorIfInvalidOperationOnMessage,\n  throwTypeErrorIfParameterTypeMismatch,\n} from \"../util/errors\";\nimport { ReceiveOptions } from \"../core/messageReceiver\";\nimport { StreamingReceiver } from \"../core/streamingReceiver\";\nimport { BatchingReceiver } from \"../core/batchingReceiver\";\nimport {\n  abandonMessage,\n  assertValidMessageHandlers,\n  completeMessage,\n  deadLetterMessage,\n  deferMessage,\n  getMessageIterator,\n} from \"./receiverCommon\";\nimport Long from \"long\";\nimport { ServiceBusMessageImpl, DeadLetterOptions } from \"../serviceBusMessage\";\nimport { Constants, RetryConfig, RetryOperationType, RetryOptions, retry } from \"@azure/core-amqp\";\nimport { LockRenewer } from \"../core/autoLockRenewer\";\nimport { receiverLogger as logger } from \"../log\";\nimport { translateServiceBusError } from \"../serviceBusError\";\nimport { ensureValidIdentifier } from \"../util/utils\";\nimport { toSpanOptions, tracingClient } from \"../diagnostics/tracing\";\nimport { extractSpanContextFromServiceBusMessage } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { TracingSpanLink } from \"@azure/core-tracing\";\n\n/**\n * The default time to wait for messages _after_ the first message\n * has been received.\n *\n * This timeout only applies to receiveMessages()\n *\n * @internal\n */\nexport const defaultMaxTimeAfterFirstMessageForBatchingMs = 1000;\n\n/**\n * A receiver that does not handle sessions.\n */\nexport interface ServiceBusReceiver {\n  /**\n   * A name used to identify the receiver. This can be used to correlate logs and exceptions.\n   * If not specified or empty, a random unique one will be generated.\n   */\n  identifier: string;\n\n  /**\n   * Streams messages to message handlers.\n   * @param handlers - A handler that gets called for messages and errors.\n   * @param options - Options for subscribe.\n   * @returns An object that can be closed, sending any remaining messages to `handlers` and\n   * stopping new messages from arriving.\n   */\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions,\n  ): {\n    /**\n     * Causes the subscriber to stop receiving new messages.\n     */\n    close(): Promise<void>;\n  };\n\n  /**\n   * Returns an iterator that can be used to receive messages from Service Bus.\n   *\n   * @param options - A set of options to control the receive operation.\n   * - `abortSignal`: The signal to use to abort the ongoing operation.\n   *\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws Error if current receiver is already in state of receiving messages.\n   * @throws `ServiceBusError` if the service returns an error while receiving messages.\n   */\n  getMessageIterator(\n    options?: GetMessageIteratorOptions,\n  ): AsyncIterableIterator<ServiceBusReceivedMessage>;\n\n  /**\n   * Returns a promise that resolves to an array of messages received from Service Bus.\n   *\n   * @param maxMessageCount - The maximum number of messages to receive.\n   * @param options - A set of options to control the receive operation.\n   * - `maxWaitTimeInMs`: The maximum time to wait for the first message before returning an empty array if no messages are available.\n   * - `abortSignal`: The signal to use to abort the ongoing operation.\n   * @returns A promise that resolves with an array of messages.\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws Error if current receiver is already in state of receiving messages.\n   * @throws `ServiceBusError` if the service returns an error while receiving messages.\n   */\n  receiveMessages(\n    maxMessageCount: number,\n    options?: ReceiveMessagesOptions,\n  ): Promise<ServiceBusReceivedMessage[]>;\n\n  /**\n   * Returns a promise that resolves to an array of deferred messages identified by given `sequenceNumbers`.\n   * @param sequenceNumbers - The sequence number or an array of sequence numbers for the messages that need to be received.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns A list of messages identified by the given sequenceNumbers or an empty list if no messages are found.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while receiving deferred messages.\n   */\n  receiveDeferredMessages(\n    sequenceNumbers: Long | Long[],\n    options?: OperationOptionsBase,\n  ): Promise<ServiceBusReceivedMessage[]>;\n\n  /**\n   * Peek the next batch of active messages (including deferred but not deadlettered messages) on the\n   * queue or subscription without modifying them.\n   * - The first call to `peekMessages()` fetches the first active message. Each subsequent call fetches the\n   * subsequent message.\n   * - Unlike a \"received\" message, \"peeked\" message is a read-only version of the message.\n   * It cannot be `Completed/Abandoned/Deferred/Deadlettered`.\n   * @param maxMessageCount - The maximum number of messages to peek.\n   * @param options - Options that allow to specify the maximum number of messages to peek,\n   * the sequenceNumber to start peeking from or an abortSignal to abort the operation.\n   */\n  peekMessages(\n    maxMessageCount: number,\n    options?: PeekMessagesOptions,\n  ): Promise<ServiceBusReceivedMessage[]>;\n  /**\n   * Path of the entity for which the receiver has been created.\n   */\n  entityPath: string;\n  /**\n   * The receive mode used to create the receiver.\n   */\n  receiveMode: \"peekLock\" | \"receiveAndDelete\";\n  /**\n   * Returns `true` if either the receiver or the client that created it has been closed.\n   * @readonly\n   */\n  isClosed: boolean;\n  /**\n   * Closes the receiver.\n   * Once closed, the receiver cannot be used for any further operations.\n   * Use the `createReceiver()` method on the ServiceBusClient to create a new Receiver.\n   */\n  close(): Promise<void>;\n  /**\n   * Removes the message from Service Bus.\n   *\n   * @throws Error with name `SessionLockLostError` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link is closed by the library due to network loss or service error.\n   * @throws Error with name `MessageLockLostError` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled.\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws Error with name `ServiceUnavailableError` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   */\n  completeMessage(message: ServiceBusReceivedMessage): Promise<void>;\n  /**\n   * The lock held on the message by the receiver is let go, making the message available again in\n   * Service Bus for another receive operation.\n   *\n   * @throws `ServiceBusError` with the code `SessionLockLost` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link is closed by the library due to network loss or service error.\n   * @throws `ServiceBusError` with the code `MessageLockLost` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled.\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws `ServiceBusError` with the code `ServiceTimeout` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @param propertiesToModify - The properties of the message to modify while abandoning the message.\n   */\n  abandonMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void>;\n  /**\n   * Defers the processing of the message. Save the `sequenceNumber` of the message, in order to\n   * receive it message again in the future using the `receiveDeferredMessage` method.\n   *\n   * @throws `ServiceBusError` with the code `SessionLockLost` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link is closed by the library due to network loss or service error.\n   * @throws `ServiceBusError` with the code `MessageLockLost` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled.\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws `ServiceBusError` with the code `ServiceTimeout` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @param propertiesToModify - The properties of the message to modify while deferring the message\n   */\n  deferMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void>;\n  /**\n   * Moves the message to the deadletter sub-queue. To receive a deadletted message, create a new\n   * QueueClient/SubscriptionClient using the path for the deadletter sub-queue.\n   *\n   * @throws `ServiceBusError` with the code `SessionLockLost` (for messages from a Queue/Subscription with sessions enabled)\n   * if the AMQP link with which the message was received is no longer alive. This can\n   * happen either because the lock on the session expired or the receiver was explicitly closed by\n   * the user or the AMQP link is closed by the library due to network loss or service error.\n   * @throws `ServiceBusError` with the code `MessageLockLost` (for messages from a Queue/Subscription with sessions not enabled)\n   * if the lock on the message has expired or the AMQP link with which the message was received is\n   * no longer alive. The latter can happen if the receiver was explicitly closed by the user or the\n   * AMQP link got closed by the library due to network loss or service error.\n   * @throws Error if the message is already settled.\n   * property on the message if you are not sure whether the message is settled.\n   * @throws Error if used in `receiveAndDelete` mode because all messages received in this mode\n   * are pre-settled. To avoid this error, update your code to not settle a message which is received\n   * in this mode.\n   * @throws `ServiceBusError` with the code `ServiceTimeout` if Service Bus does not acknowledge the request to settle\n   * the message in time. The message may or may not have been settled successfully.\n   *\n   * @param options - The DeadLetter options that can be provided while\n   * rejecting the message.\n   */\n  deadLetterMessage(\n    message: ServiceBusReceivedMessage,\n    options?: DeadLetterOptions & { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void>;\n  /**\n   * Renews the lock on the message for the duration as specified during the Queue/Subscription\n   * creation.\n   * - Check the `lockedUntilUtc` property on the message for the time when the lock expires.\n   * - If a message is not settled (using either `complete()`, `defer()` or `deadletter()`,\n   * before its lock expires, then the message lands back in the Queue/Subscription for the next\n   * receive operation.\n   *\n   * @returns New lock token expiry date and time in UTC format.\n   * @throws Error if the underlying connection, client or receiver is closed.\n   * @throws ServiceBusError if the service returns an error while renewing message lock.\n   */\n  renewMessageLock(message: ServiceBusReceivedMessage): Promise<Date>;\n}\n\n/**\n * @internal\n */\nexport class ServiceBusReceiverImpl implements ServiceBusReceiver {\n  public identifier: string;\n  private _retryOptions: RetryOptions;\n  /**\n   * Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n\n  /**\n   * Instance of the BatchingReceiver class to use to receive messages in pull mode.\n   */\n  private _batchingReceiver?: BatchingReceiver;\n\n  /**\n   * Instance of the StreamingReceiver class to use to receive messages in push mode.\n   */\n  private _streamingReceiver?: StreamingReceiver;\n  private _lockRenewer: LockRenewer | undefined;\n\n  private get logPrefix(): string {\n    return `[${this._context.connectionId}|receiver:${this.entityPath}]`;\n  }\n\n  /**\n   * @throws Error if the underlying connection is closed.\n   */\n  constructor(\n    private _context: ConnectionContext,\n    public entityPath: string,\n    public receiveMode: \"peekLock\" | \"receiveAndDelete\",\n    maxAutoRenewLockDurationInMs: number,\n    private skipParsingBodyAsJson: boolean,\n    private skipConvertingDate: boolean = false,\n    retryOptions: RetryOptions = {},\n    identifier?: string,\n  ) {\n    throwErrorIfConnectionClosed(_context);\n    this._retryOptions = retryOptions;\n    this._lockRenewer = LockRenewer.create(\n      this._context,\n      maxAutoRenewLockDurationInMs,\n      receiveMode,\n    );\n    this.identifier = ensureValidIdentifier(this.entityPath, identifier);\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this._isReceivingMessages()) {\n      const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath);\n      const error = new Error(errorMessage);\n      logger.logError(error, `${this.logPrefix} is already receiving`);\n      throw error;\n    }\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (this.isClosed) {\n      const errorMessage = getReceiverClosedErrorMsg(this.entityPath);\n      const error = new Error(errorMessage);\n      logger.logError(error, `${this.logPrefix} is closed`);\n      throw error;\n    }\n  }\n\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  async receiveMessages(\n    maxMessageCount: number,\n    options?: ReceiveMessagesOptions,\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n    );\n    throwTypeErrorIfParameterTypeMismatch(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n      \"number\",\n    );\n\n    if (isNaN(maxMessageCount) || maxMessageCount < 1) {\n      throw new TypeError(InvalidMaxMessageCountError);\n    }\n\n    const receiveMessages = async (): Promise<ServiceBusReceivedMessage[]> => {\n      if (!this._batchingReceiver || !this._context.messageReceivers[this._batchingReceiver.name]) {\n        const receiveOptions: ReceiveOptions = {\n          maxConcurrentCalls: 0,\n          receiveMode: this.receiveMode,\n          lockRenewer: this._lockRenewer,\n          skipParsingBodyAsJson: this.skipParsingBodyAsJson,\n          skipConvertingDate: this.skipConvertingDate,\n        };\n        this._batchingReceiver = this._createBatchingReceiver(\n          this._context,\n          this.entityPath,\n          receiveOptions,\n        );\n      }\n\n      const receivedMessages = await this._batchingReceiver.receive(\n        maxMessageCount,\n        options?.maxWaitTimeInMs ?? Constants.defaultOperationTimeoutInMs,\n        defaultMaxTimeAfterFirstMessageForBatchingMs,\n        options ?? {},\n      );\n\n      return receivedMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      connectionHost: this._context.config.host,\n      connectionId: this._context.connectionId,\n      operation: receiveMessages,\n      operationType: RetryOperationType.receiveMessage,\n      abortSignal: options?.abortSignal,\n      retryOptions: this._retryOptions,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config).catch((err) => {\n      throw translateServiceBusError(err);\n    });\n  }\n\n  getMessageIterator(\n    options?: GetMessageIteratorOptions,\n  ): AsyncIterableIterator<ServiceBusReceivedMessage> {\n    return getMessageIterator(this, options);\n  }\n\n  async receiveDeferredMessages(\n    sequenceNumbers: Long | Long[],\n    options: OperationOptionsBase = {},\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers,\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers,\n    );\n\n    const deferredSequenceNumbers = Array.isArray(sequenceNumbers)\n      ? sequenceNumbers\n      : [sequenceNumbers];\n    const receiveDeferredMessagesOperationPromise = async (): Promise<\n      ServiceBusReceivedMessage[]\n    > => {\n      const deferredMessages = await this._context\n        .getManagementClient(this.entityPath)\n        .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, undefined, {\n          ...options,\n          associatedLinkName: this._getAssociatedReceiverName(),\n          requestName: \"receiveDeferredMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs,\n          skipParsingBodyAsJson: this.skipParsingBodyAsJson,\n          skipConvertingDate: this.skipConvertingDate,\n        });\n      return deferredMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: receiveDeferredMessagesOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  // ManagementClient methods # Begin\n\n  async peekMessages(\n    maxMessageCount: number,\n    options: PeekMessagesOptions = {},\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    const managementRequestOptions = {\n      ...options,\n      associatedLinkName: this._getAssociatedReceiverName(),\n      requestName: \"peekMessages\",\n      timeoutInMs: this._retryOptions?.timeoutInMs,\n      skipParsingBodyAsJson: this.skipParsingBodyAsJson,\n      skipConvertingDate: this.skipConvertingDate,\n    };\n    const peekOperationPromise = async (): Promise<ServiceBusReceivedMessage[]> => {\n      if (options.fromSequenceNumber !== undefined) {\n        return this._context\n          .getManagementClient(this.entityPath)\n          .peekBySequenceNumber(\n            options.fromSequenceNumber,\n            maxMessageCount,\n            undefined,\n            options.omitMessageBody,\n            managementRequestOptions,\n          );\n      } else {\n        return this._context\n          .getManagementClient(this.entityPath)\n          .peek(maxMessageCount, options.omitMessageBody, managementRequestOptions);\n      }\n    };\n\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: peekOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions,\n  ): {\n    close(): Promise<void>;\n  } {\n    assertValidMessageHandlers(handlers);\n    throwErrorIfConnectionClosed(this._context);\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n\n    options = {\n      ...(options ?? {}),\n      autoCompleteMessages: options?.autoCompleteMessages ?? true,\n    };\n\n    // When the user \"stops\" a streaming receiver (via the returned instance from 'subscribe' we just suspend\n    // it, leaving the link open). This allows users to stop the flow of messages but still be able to settle messages\n    // since the link itself hasn't been shut down.\n    //\n    // Users can, if they want, restart their subscription (since we've got a link already established).\n    // So you'll have an instance here if the user has done:\n    // 1. const subscription = receiver.subscribe()\n    // 2. subscription.stop()\n    // 3. receiver.subscribe()\n\n    this._streamingReceiver =\n      this._streamingReceiver ??\n      new StreamingReceiver(this.identifier, this._context, this.entityPath, {\n        ...options,\n        receiveMode: this.receiveMode,\n        retryOptions: this._retryOptions,\n        lockRenewer: this._lockRenewer,\n        skipParsingBodyAsJson: this.skipParsingBodyAsJson,\n        skipConvertingDate: this.skipConvertingDate,\n      });\n\n    // this ensures that if the outer service bus client is closed that  this receiver is cleaned up.\n    // this mostly affects us if we're in the middle of init() - the connection (and receiver) are not yet\n    // open but we do need to close the receiver to exit the init() loop.\n    this._context.messageReceivers[this._streamingReceiver.name] = this._streamingReceiver;\n\n    this._streamingReceiver.subscribe(handlers, options).catch((_) => {\n      // (the error will already have been reported to the user)\n      if (this._streamingReceiver) {\n        delete this._context.messageReceivers[this._streamingReceiver.name];\n      }\n    });\n\n    return {\n      close: async (): Promise<void> => {\n        return this._streamingReceiver?.stopReceivingMessages();\n      },\n    };\n  }\n\n  async completeMessage(message: ServiceBusReceivedMessage): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return completeMessage(msgImpl, this._context, this.entityPath, this._retryOptions);\n  }\n\n  async abandonMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return abandonMessage(\n      msgImpl,\n      this._context,\n      this.entityPath,\n      propertiesToModify,\n      this._retryOptions,\n    );\n  }\n\n  async deferMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deferMessage(\n      msgImpl,\n      this._context,\n      this.entityPath,\n      propertiesToModify,\n      this._retryOptions,\n    );\n  }\n\n  async deadLetterMessage(\n    message: ServiceBusReceivedMessage,\n    options?: DeadLetterOptions & { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deadLetterMessage(msgImpl, this._context, this.entityPath, options, this._retryOptions);\n  }\n\n  async renewMessageLock(message: ServiceBusReceivedMessage): Promise<Date> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n\n    const tracingContext = extractSpanContextFromServiceBusMessage(message);\n    const spanLinks: TracingSpanLink[] = tracingContext ? [{ tracingContext }] : [];\n\n    return tracingClient.withSpan(\n      \"ServiceBusReceiver.renewMessageLock\",\n      {},\n      () => {\n        const msgImpl = message as ServiceBusMessageImpl;\n\n        let associatedLinkName: string | undefined;\n        if (msgImpl.delivery.link) {\n          const associatedReceiver = this._context.getReceiverFromCache(msgImpl.delivery.link.name);\n          associatedLinkName = associatedReceiver?.name;\n        }\n        return this._context\n          .getManagementClient(this.entityPath)\n          .renewLock(message.lockToken!, { associatedLinkName })\n          .then((lockedUntil) => {\n            message.lockedUntilUtc = lockedUntil;\n            return lockedUntil;\n          });\n      },\n      {\n        spanLinks,\n        ...toSpanOptions(\n          { entityPath: this.entityPath, host: this._context.config.host },\n          \"receive\",\n          \"client\",\n        ),\n      },\n    );\n  }\n\n  async close(): Promise<void> {\n    try {\n      this._isClosed = true;\n      if (this._context.connection && this._context.connection.isOpen()) {\n        // Close the streaming receiver.\n        if (this._streamingReceiver) {\n          await this._streamingReceiver.close();\n        }\n\n        // Close the batching receiver.\n        if (this._batchingReceiver) {\n          await this._batchingReceiver.close();\n        }\n      }\n    } catch (err: any) {\n      logger.logError(err, `${this.logPrefix} An error occurred while closing the Receiver`);\n      throw err;\n    }\n  }\n\n  /**\n   * Indicates whether the receiver is currently receiving messages or not.\n   * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.\n   */\n  private _isReceivingMessages(): boolean {\n    if (\n      this._streamingReceiver &&\n      this._streamingReceiver.isOpen() &&\n      this._streamingReceiver.isSubscribeActive\n    ) {\n      return true;\n    }\n    if (\n      this._batchingReceiver &&\n      this._batchingReceiver.isOpen() &&\n      this._batchingReceiver.isReceivingMessages\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private _createBatchingReceiver(\n    context: ConnectionContext,\n    entityPath: string,\n    options: ReceiveOptions,\n  ): BatchingReceiver {\n    const receiver = BatchingReceiver.create(this.identifier, context, entityPath, options);\n    logger.verbose(\n      `[${this.logPrefix}] receiver '${receiver.name}' created, with maxConcurrentCalls set to ${options.maxConcurrentCalls}.`,\n    );\n\n    return receiver;\n  }\n\n  /**\n   * Helper function to retrieve any active receiver name, regardless of streaming or\n   * batching if it exists. This is used for optimization on the service side\n   */\n  private _getAssociatedReceiverName(): string | undefined {\n    if (this._streamingReceiver && this._streamingReceiver.isOpen()) {\n      return this._streamingReceiver.name;\n    }\n    if (\n      this._batchingReceiver &&\n      this._batchingReceiver.isOpen() &&\n      this._batchingReceiver.isReceivingMessages\n    ) {\n      return this._batchingReceiver.name;\n    }\n    return;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionContext } from \"../connectionContext\";\nimport { MessageHandlers, ReceiveMessagesOptions, ServiceBusReceivedMessage } from \"..\";\nimport { PeekMessagesOptions, GetMessageIteratorOptions, SubscribeOptions } from \"../models\";\nimport { MessageSession } from \"../session/messageSession\";\nimport {\n  getAlreadyReceivingErrorMsg,\n  getReceiverClosedErrorMsg,\n  InvalidMaxMessageCountError,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwErrorIfInvalidOperationOnMessage,\n  throwTypeErrorIfParameterTypeMismatch,\n} from \"../util/errors\";\nimport { OnError, OnMessage } from \"../core/messageReceiver\";\nimport {\n  abandonMessage,\n  assertValidMessageHandlers,\n  completeMessage,\n  deadLetterMessage,\n  deferMessage,\n  getMessageIterator,\n  wrapProcessErrorHandler,\n} from \"./receiverCommon\";\nimport { defaultMaxTimeAfterFirstMessageForBatchingMs, ServiceBusReceiver } from \"./receiver\";\nimport Long from \"long\";\nimport { ServiceBusMessageImpl, DeadLetterOptions } from \"../serviceBusMessage\";\nimport {\n  Constants,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  retry,\n  ErrorNameConditionMapper,\n} from \"@azure/core-amqp\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { AmqpError } from \"rhea-promise\";\nimport { toProcessingSpanOptions } from \"../diagnostics/instrumentServiceBusMessage\";\nimport { tracingClient } from \"../diagnostics/tracing\";\nimport { receiverLogger as logger } from \"../log\";\nimport { translateServiceBusError } from \"../serviceBusError\";\n\n/**\n *A receiver that handles sessions, including renewing the session lock.\n */\nexport interface ServiceBusSessionReceiver extends ServiceBusReceiver {\n  /**\n   * The session ID.\n   */\n  readonly sessionId: string;\n\n  /**\n   * The time in UTC until which the session is locked.\n   * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock\n   * duration as specified during the Queue/Subscription creation.\n   *\n   * Will return undefined until a AMQP receiver link has been successfully set up for the session.\n   *\n   * @readonly\n   */\n  readonly sessionLockedUntilUtc: Date;\n\n  /**\n   * Streams messages to message handlers.\n   * @param handlers - A handler that gets called for messages and errors.\n   * @param options - Options for subscribe.\n   * @returns An object that can be closed, sending any remaining messages to `handlers` and\n   * stopping new messages from arriving.\n   */\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions,\n  ): {\n    /**\n     * Causes the subscriber to stop receiving new messages.\n     */\n    close(): Promise<void>;\n  };\n\n  /**\n   * Renews the lock on the session.\n   */\n  renewSessionLock(options?: OperationOptionsBase): Promise<Date>;\n\n  /**\n   * Gets the state of the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns The state of that session\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while retrieving session state.\n   */\n  getSessionState(options?: OperationOptionsBase): Promise<any>;\n\n  /**\n   * Sets the state on the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param state - The state that needs to be set.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while setting the session state.\n   *\n   */\n  setSessionState(state: any, options?: OperationOptionsBase): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport class ServiceBusSessionReceiverImpl implements ServiceBusSessionReceiver {\n  public sessionId: string;\n  public identifier: string;\n\n  /**\n   * Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n\n  private get logPrefix(): string {\n    return `[${this._context.connectionId}|session:${this.entityPath}]`;\n  }\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   * @throws Error if an open receiver is already existing for given sessionId.\n   */\n  constructor(\n    private _messageSession: MessageSession,\n    private _context: ConnectionContext,\n    public entityPath: string,\n    public receiveMode: \"peekLock\" | \"receiveAndDelete\",\n    private _skipParsingBodyAsJson: boolean,\n    private _skipConvertingDate: boolean,\n    private _retryOptions: RetryOptions = {},\n  ) {\n    throwErrorIfConnectionClosed(_context);\n    this.sessionId = _messageSession.sessionId;\n    this.identifier = _messageSession.identifier;\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (this.isClosed) {\n      if (this._isClosed) {\n        const errorMessage = getReceiverClosedErrorMsg(this.entityPath, this.sessionId);\n        const error = new Error(errorMessage);\n        logger.logError(error, `${this.logPrefix} already closed`);\n        throw error;\n      }\n      const amqpError: AmqpError = {\n        condition: ErrorNameConditionMapper.SessionLockLostError,\n        description: `The session lock has expired on the session with id ${this.sessionId}`,\n      };\n      throw translateServiceBusError(amqpError);\n    }\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this._isReceivingMessages()) {\n      const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath, this.sessionId);\n      const error = new Error(errorMessage);\n      logger.logError(error, `${this.logPrefix} is already receiving.`);\n      throw error;\n    }\n  }\n\n  public get isClosed(): boolean {\n    return (\n      this._isClosed ||\n      !this._context.messageSessions[this._messageSession.name] ||\n      !this._messageSession.isOpen()\n    );\n  }\n\n  /**\n   * The time in UTC until which the session is locked.\n   * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock\n   * duration as specified during the Queue/Subscription creation.\n   *\n   * When the lock on the session expires\n   * - The current receiver can no longer be used to receive more messages.\n   * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.\n   * - Messages that were received in `peekLock` mode with this receiver but not yet settled\n   * will land back in the Queue/Subscription with their delivery count incremented.\n   *\n   * @readonly\n   */\n  public get sessionLockedUntilUtc(): Date {\n    return this._messageSession.sessionLockedUntilUtc;\n  }\n\n  /**\n   * Renews the lock on the session for the duration as specified during the Queue/Subscription\n   * creation. You can check the `sessionLockedUntilUtc` property for the time when the lock expires.\n   *\n   * When the lock on the session expires\n   * - The current receiver can no longer be used to receive mode messages.\n   * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.\n   * - Messages that were received in `peekLock` mode with this receiver but not yet settled\n   * will land back in the Queue/Subscription with their delivery count incremented.\n   *\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns New lock token expiry date and time in UTC format.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while renewing session lock.\n   */\n  async renewSessionLock(options?: OperationOptionsBase): Promise<Date> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    return tracingClient.withSpan(\n      \"ServiceBusSessionReceiver.renewSessionLock\",\n      options ?? {},\n      (updatedOptions) => {\n        const renewSessionLockOperationPromise = async (): Promise<Date> => {\n          this._messageSession!.sessionLockedUntilUtc = await this._context\n            .getManagementClient(this.entityPath)\n            .renewSessionLock(this.sessionId, {\n              ...updatedOptions,\n              associatedLinkName: this._messageSession.name,\n              requestName: \"renewSessionLock\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n          return this._messageSession!.sessionLockedUntilUtc!;\n        };\n        const config: RetryConfig<Date> = {\n          operation: renewSessionLockOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: options?.abortSignal,\n        };\n        return retry<Date>(config);\n      },\n    );\n  }\n\n  /**\n   * Sets the state on the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param state - The state that needs to be set.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while setting the session state.\n   */\n  async setSessionState(state: unknown, options: OperationOptionsBase = {}): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    return tracingClient.withSpan(\n      \"ServiceBusSessionReceiver.setSessionState\",\n      options ?? {},\n      (updatedOptions) => {\n        const setSessionStateOperationPromise = async (): Promise<void> => {\n          await this._context\n            .getManagementClient(this.entityPath)\n            .setSessionState(this.sessionId!, state, {\n              ...updatedOptions,\n              associatedLinkName: this._messageSession.name,\n              requestName: \"setState\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n          return;\n        };\n        const config: RetryConfig<void> = {\n          operation: setSessionStateOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: options?.abortSignal,\n        };\n        return retry<void>(config);\n      },\n    );\n  }\n\n  /**\n   * Gets the state of the Session. For more on session states, see\n   * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns The state of that session\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while retrieving session state.\n   */\n  async getSessionState(options: OperationOptionsBase = {}): Promise<any> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    return tracingClient.withSpan(\n      \"ServiceBusSessionReceiver.getSessionState\",\n      options ?? {},\n      (updatedOptions) => {\n        const getSessionStateOperationPromise = async (): Promise<any> => {\n          return this._context\n            .getManagementClient(this.entityPath)\n            .getSessionState(this.sessionId, {\n              ...updatedOptions,\n              associatedLinkName: this._messageSession.name,\n              requestName: \"getState\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n        };\n        const config: RetryConfig<any> = {\n          operation: getSessionStateOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: options?.abortSignal,\n        };\n        return retry<any>(config);\n      },\n    );\n  }\n\n  async peekMessages(\n    maxMessageCount: number,\n    options: PeekMessagesOptions = {},\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    const managementRequestOptions = {\n      ...options,\n      associatedLinkName: this._messageSession.name,\n      requestName: \"peekMessages\",\n      timeoutInMs: this._retryOptions?.timeoutInMs,\n      skipParsingBodyAsJson: this._skipParsingBodyAsJson,\n      skipConvertingDate: this._skipConvertingDate,\n    };\n    const peekOperationPromise = async (): Promise<ServiceBusReceivedMessage[]> => {\n      if (options.fromSequenceNumber !== undefined) {\n        return this._context\n          .getManagementClient(this.entityPath)\n          .peekBySequenceNumber(\n            options.fromSequenceNumber,\n            maxMessageCount,\n            this.sessionId,\n            options.omitMessageBody,\n            managementRequestOptions,\n          );\n      } else {\n        return this._context\n          .getManagementClient(this.entityPath)\n          .peekMessagesBySession(\n            this.sessionId,\n            maxMessageCount,\n            options.omitMessageBody,\n            managementRequestOptions,\n          );\n      }\n    };\n\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: peekOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  async receiveDeferredMessages(\n    sequenceNumbers: Long | Long[],\n    options: OperationOptionsBase = {},\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers,\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers,\n    );\n\n    const deferredSequenceNumbers = Array.isArray(sequenceNumbers)\n      ? sequenceNumbers\n      : [sequenceNumbers];\n    const receiveDeferredMessagesOperationPromise = async (): Promise<\n      ServiceBusReceivedMessage[]\n    > => {\n      const deferredMessages = await this._context\n        .getManagementClient(this.entityPath)\n        .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, this.sessionId, {\n          ...options,\n          associatedLinkName: this._messageSession.name,\n          requestName: \"receiveDeferredMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs,\n          skipParsingBodyAsJson: this._skipParsingBodyAsJson,\n          skipConvertingDate: this._skipConvertingDate,\n        });\n      return deferredMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: receiveDeferredMessagesOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  async receiveMessages(\n    maxMessageCount: number,\n    options?: ReceiveMessagesOptions,\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n    );\n    throwTypeErrorIfParameterTypeMismatch(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n      \"number\",\n    );\n\n    if (isNaN(maxMessageCount) || maxMessageCount < 1) {\n      throw new TypeError(InvalidMaxMessageCountError);\n    }\n\n    const receiveBatchOperationPromise = async (): Promise<ServiceBusReceivedMessage[]> => {\n      const receivedMessages = await this._messageSession!.receiveMessages(\n        maxMessageCount,\n        options?.maxWaitTimeInMs ?? Constants.defaultOperationTimeoutInMs,\n        defaultMaxTimeAfterFirstMessageForBatchingMs,\n        options ?? {},\n      );\n\n      return receivedMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: receiveBatchOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.receiveMessage,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config).catch((err) => {\n      throw translateServiceBusError(err);\n    });\n  }\n\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions,\n  ): {\n    close(): Promise<void>;\n  } {\n    // TODO - receiverOptions for subscribe??\n    assertValidMessageHandlers(handlers);\n\n    options = options ?? {};\n\n    const processError = wrapProcessErrorHandler(handlers);\n\n    this._registerMessageHandler(\n      async (message: ServiceBusMessageImpl) => {\n        return tracingClient.withSpan(\n          \"SessionReceiver.process\",\n          options ?? {},\n          () => handlers.processMessage(message),\n          toProcessingSpanOptions(message, this, this._context.config, \"process\"),\n        );\n      },\n      processError,\n      options,\n    );\n\n    return {\n      close: async (): Promise<void> => {\n        return this._messageSession?.receiverHelper.suspend();\n      },\n    };\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the SessionReceiver.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control whether messages should be automatically completed\n   * or if the lock on the session should be automatically renewed. You can control the\n   * maximum number of messages that should be concurrently processed. You can\n   * also provide a timeout in milliseconds to denote the amount of time to wait for a new message\n   * before closing the receiver.\n   *\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws Error if the receiver is already in state of receiving messages.\n   * @throws `ServiceBusError` if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.\n   */\n  private _registerMessageHandler(\n    onMessage: OnMessage,\n    onError: OnError,\n    options: SubscribeOptions,\n  ): void {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    const connId = this._context.connectionId;\n    throwTypeErrorIfParameterMissing(connId, \"onMessage\", onMessage);\n    throwTypeErrorIfParameterMissing(connId, \"onError\", onError);\n    if (typeof onMessage !== \"function\") {\n      throw new TypeError(\"The parameter 'onMessage' must be of type 'function'.\");\n    }\n    if (typeof onError !== \"function\") {\n      throw new TypeError(\"The parameter 'onError' must be of type 'function'.\");\n    }\n\n    try {\n      this._messageSession.subscribe(onMessage, onError, options);\n    } catch (err: any) {\n      onError({\n        error: err,\n        errorSource: \"receive\",\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host,\n        identifier: this.identifier,\n      });\n    }\n  }\n\n  getMessageIterator(\n    options?: GetMessageIteratorOptions,\n  ): AsyncIterableIterator<ServiceBusReceivedMessage> {\n    return getMessageIterator(this, options);\n  }\n\n  async completeMessage(message: ServiceBusReceivedMessage): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return completeMessage(msgImpl, this._context, this.entityPath, this._retryOptions);\n  }\n\n  async abandonMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return abandonMessage(\n      msgImpl,\n      this._context,\n      this.entityPath,\n      propertiesToModify,\n      this._retryOptions,\n    );\n  }\n\n  async deferMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deferMessage(\n      msgImpl,\n      this._context,\n      this.entityPath,\n      propertiesToModify,\n      this._retryOptions,\n    );\n  }\n\n  async deadLetterMessage(\n    message: ServiceBusReceivedMessage,\n    options?: DeadLetterOptions & { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deadLetterMessage(msgImpl, this._context, this.entityPath, options, this._retryOptions);\n  }\n\n  async renewMessageLock(): Promise<Date> {\n    throw new Error(\"Renewing message lock is an invalid operation when working with sessions.\");\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this._messageSession.close();\n    } catch (err: any) {\n      logger.logError(\n        err,\n        \"%s An error occurred while closing the SessionReceiver for session %s\",\n        this.logPrefix,\n        this.sessionId,\n      );\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  /**\n   * Indicates whether the receiver is currently receiving messages or not.\n   * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.\n   */\n  private _isReceivingMessages(): boolean {\n    return this._messageSession ? this._messageSession.isReceivingMessages : false;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptionsBase } from \"./modelsToBeSharedWithEventHubs\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { RetryConfig, RetryOperationType, RetryOptions, retry } from \"@azure/core-amqp\";\nimport { CorrelationRuleFilter } from \"./core/managementClient\";\nimport { ruleManagerLogger as logger } from \"./log\";\nimport {\n  isSqlRuleAction,\n  RuleProperties,\n  SqlRuleAction,\n} from \"./serializers/ruleResourceSerializer\";\nimport { getUniqueName } from \"./util/utils\";\nimport { throwErrorIfConnectionClosed } from \"./util/errors\";\nimport { SqlRuleFilter } from \"./serializers/ruleResourceSerializer\";\nimport { tracingClient } from \"./diagnostics/tracing\";\nimport { getPagedAsyncIterator, PagedAsyncIterableIterator, PagedResult } from \"@azure/core-paging\";\nimport { OperationOptions } from \"@azure/core-client\";\nimport { ListRequestOptions } from \"./serviceBusAtomManagementClient\";\n\n/**\n * Allows rules for a subscription to be managed. This rule manager requires only Listen claims, whereas the\n * {@link ServiceBusAdministrationClient} requires Manage claims.\n */\nexport interface ServiceBusRuleManager {\n  /**\n   * Adds a rule to the current subscription to filter the messages reaching from topic to the subscription.\n   *\n   * @param ruleName - the name of the rule\n   * @param filter - the filter expression that the rule evaluates.\n   * @param options - The options that can be used to abort, trace and control other configurations on the request.\n   */\n  createRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    options?: OperationOptionsBase,\n  ): Promise<void>;\n  /**\n   * Adds a rule to the current subscription to filter the messages reaching from topic to the subscription.\n   *\n   * @param ruleName - the name of the rule\n   * @param filter - the filter expression that the rule evaluates.\n   * @param ruleAction - The SQL like expression that can be executed on the message should the associated filter apply.\n   * @param options - The options that can be used to abort, trace and control other configurations on the request.\n   */\n  createRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleAction?: SqlRuleAction,\n    options?: OperationOptionsBase,\n  ): Promise<void>;\n  /**\n   * Deletes a rule.\n   *\n   * @param ruleName - the name of the rule\n   */\n  deleteRule(ruleName: string, options?: OperationOptionsBase): Promise<void>;\n  /**\n   * Returns an async iterable iterator to list all the rules\n   * under the specified subscription.\n   *\n   * .byPage() returns an async iterable iterator to list the rules in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  listRules(\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<RuleProperties>;\n}\n\n/**\n * @internal\n */\nexport class ServiceBusRuleManagerImpl implements ServiceBusRuleManager {\n  /**\n   * Denotes if close() was called on this sender\n   */\n  private _isClosed: boolean = false;\n  private name: string;\n  public entityPath: string;\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   */\n  constructor(\n    private _context: ConnectionContext,\n    private _entityPath: string,\n    private _retryOptions: RetryOptions = {},\n  ) {\n    throwErrorIfConnectionClosed(_context);\n    this.entityPath = _entityPath;\n    this.name = getUniqueName(\"ruleManager\");\n  }\n\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  /**\n   * Adds a rule to the current subscription to filter the messages reaching from topic to the subscription.\n   *\n   * @param ruleName - the name of the rule\n   * @param filter - the filter expression that the rule evaluates.\n   * @param options - The options that can be used to abort, trace and control other configurations on the request.\n   */\n  createRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    options?: OperationOptions,\n  ): Promise<void>;\n  /**\n   * Adds a rule to the current subscription to filter the messages reaching from topic to the subscription.\n   *\n   * @param ruleName - the name of the rule\n   * @param filter - the filter expression that the rule evaluates.\n   * @param ruleAction - The SQL like expression that can be executed on the message should the associated filter apply.\n   * @param options - The options that can be used to abort, trace and control other configurations on the request.\n   */\n  createRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleAction?: SqlRuleAction,\n    options?: OperationOptions,\n  ): Promise<void>;\n  async createRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleActionOrOperationOptions?: SqlRuleAction | OperationOptionsBase,\n    options: OperationOptions = {},\n  ): Promise<void> {\n    let sqlRuleAction: SqlRuleAction | undefined = undefined;\n    let operOptions: OperationOptions | undefined;\n    if (ruleActionOrOperationOptions) {\n      if (isSqlRuleAction(ruleActionOrOperationOptions)) {\n        // Overload#2 - where the sqlExpression in the ruleAction is defined\n        sqlRuleAction = ruleActionOrOperationOptions;\n        operOptions = options;\n      } else {\n        // Overload#1 - where the sqlExpression in the ruleAction is undefined\n        operOptions = { ...ruleActionOrOperationOptions, ...options };\n      }\n    }\n\n    return tracingClient.withSpan(\n      \"ServiceBusRuleManager.createRule\",\n      operOptions ?? {},\n      async (updatedOptions) => {\n        const addRuleOperationPromise = async (): Promise<void> => {\n          return this._context\n            .getManagementClient(this._entityPath)\n            .addRule(ruleName, filter, sqlRuleAction?.sqlExpression, {\n              ...updatedOptions,\n              associatedLinkName: this.name,\n              requestName: \"addRule\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n        };\n        const config: RetryConfig<void> = {\n          operation: addRuleOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: updatedOptions?.abortSignal,\n        };\n        return retry<void>(config);\n      },\n    );\n  }\n\n  /**\n   * Get all rules associated with the subscription.\n   */\n  private async getRules(\n    options?: ListRequestOptions & OperationOptions,\n  ): Promise<RuleProperties[]> {\n    return tracingClient.withSpan(\n      \"ServiceBusRuleManager.getRules\",\n      options ?? {},\n      async (updatedOptions) => {\n        const getRulesOperationPromise = async (): Promise<RuleProperties[]> => {\n          return this._context.getManagementClient(this._entityPath).getRules({\n            ...updatedOptions,\n            associatedLinkName: this.name,\n            requestName: \"getRules\",\n            timeoutInMs: this._retryOptions.timeoutInMs,\n          });\n        };\n        const config: RetryConfig<RuleProperties[]> = {\n          operation: getRulesOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: updatedOptions?.abortSignal,\n        };\n        return retry<RuleProperties[]>(config);\n      },\n    );\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the rules\n   * under the specified subscription.\n   *\n   * .byPage() returns an async iterable iterator to list the rules in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listRules(\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<RuleProperties, RuleProperties[], { maxPageSize?: number }> {\n    logger.verbose(`Performing operation - listRules() with options: %j`, options);\n    const pagedResult: PagedResult<RuleProperties[], { maxPageSize?: number }, number> = {\n      firstPageLink: 0,\n      getPage: async (pageLink, maxPageSize) => {\n        const top = maxPageSize ?? 100;\n        const rules = await this.getRules({\n          skip: pageLink,\n          maxCount: top,\n          ...options,\n        });\n        return rules.length\n          ? {\n              page: rules,\n              nextPageLink: rules.length > 0 ? pageLink + rules.length : undefined,\n            }\n          : undefined;\n      },\n    };\n\n    return getPagedAsyncIterator(pagedResult);\n  }\n\n  /**\n   * Deletes a rule.\n   */\n  async deleteRule(ruleName: string, options: OperationOptions = {}): Promise<void> {\n    return tracingClient.withSpan(\n      \"ServiceBusRuleManager.deleteRule\",\n      options,\n      async (updatedOptions) => {\n        const removeRuleOperationPromise = async (): Promise<void> => {\n          return this._context.getManagementClient(this._entityPath).removeRule(ruleName, {\n            ...updatedOptions,\n            associatedLinkName: this.name,\n            requestName: \"removeRule\",\n            timeoutInMs: this._retryOptions.timeoutInMs,\n          });\n        };\n        const config: RetryConfig<void> = {\n          operation: removeRuleOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: updatedOptions?.abortSignal,\n        };\n        return retry<void>(config);\n      },\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ServiceBusMessage, toRheaMessage } from \"./serviceBusMessage\";\nimport {\n  errorInvalidMessageTypeSingle,\n  throwIfNotValidServiceBusMessage,\n  throwTypeErrorIfParameterMissing,\n} from \"./util/errors\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport {\n  MessageAnnotations,\n  messageProperties as RheaMessagePropertiesList,\n  message as RheaMessageUtil,\n  Message as RheaMessage,\n} from \"rhea-promise\";\nimport { TracingContext } from \"@azure/core-tracing\";\nimport { TryAddOptions } from \"./modelsToBeSharedWithEventHubs\";\nimport { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { defaultDataTransformer } from \"./dataTransformer\";\nimport { instrumentMessage } from \"./diagnostics/instrumentServiceBusMessage\";\n\n/**\n * @internal\n * The amount of bytes to reserve as overhead for a small message.\n */\nconst smallMessageOverhead = 5;\n/**\n * @internal\n * The amount of bytes to reserve as overhead for a large message.\n */\nconst largeMessageOverhead = 8;\n/**\n * @internal\n * The maximum number of bytes that a message may be to be considered small.\n */\nconst smallMessageMaxBytes = 255;\n\n/**\n * A batch of messages that you can create using the {@link createBatch} method.\n *\n */\nexport interface ServiceBusMessageBatch {\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of messages added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAddMessage` function on the batch will return `false`\n   * if the message being added causes the size of the batch to exceed this limit. Use the `createMessageBatch()` method on\n   * the `Sender` to set the maxSizeInBytes.\n   * @readonly\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds a message to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param message - The message to add to the batch.\n   * @returns A boolean value indicating if the message has been added to the batch or not.\n   */\n  tryAddMessage(\n    message: ServiceBusMessage | AmqpAnnotatedMessage,\n    options?: TryAddOptions,\n  ): boolean;\n\n  /**\n   * The AMQP message containing encoded events that were added to the batch.\n   * Used internally by the `sendBatch()` method on the `Sender`.\n   * This is not meant for the user to use directly.\n   *\n   * @readonly\n   * @internal\n   * @hidden\n   */\n  _generateMessage(): Buffer;\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * Used internally by the `sendBatch()` method to set up the right spans in traces if tracing is enabled.\n   * @internal\n   * @hidden\n   */\n  readonly _messageSpanContexts: TracingContext[];\n}\n\n/**\n * An internal class representing a batch of messages which can be used to send messages to Service Bus.\n *\n * @internal\n */\nexport class ServiceBusMessageBatchImpl implements ServiceBusMessageBatch {\n  /**\n   * Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: TracingContext[] = [];\n  /**\n   * ServiceBusMessageBatch should not be constructed using `new ServiceBusMessageBatch()`\n   * Use the `createBatch()` method on your `Sender` instead.\n   * @internal\n   * @hidden\n   */\n  constructor(\n    private _context: ConnectionContext,\n    private _maxSizeInBytes: number,\n  ) {\n    this._sizeInBytes = 0;\n    this._batchMessageProperties = {};\n  }\n\n  /**\n   * The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * Size of the `ServiceBusMessageBatch` instance after the messages added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * Number of messages in the `ServiceBusMessageBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._encodedMessages.length;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding messages to the batch.\n   * @internal\n   * @hidden\n   */\n  get _messageSpanContexts(): TracingContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Generates an AMQP message that contains the provided encoded messages and annotations.\n   *\n   * @param encodedMessages - The already encoded messages to include in the AMQP batch.\n   * @param annotations - The message annotations to set on the batch.\n   * @param applicationProperties - The application properties to set on the batch.\n   * @param messageProperties - The message properties to set on the batch.\n   */\n  private _generateBatch(\n    encodedMessages: Buffer[],\n    annotations?: MessageAnnotations,\n    applicationProperties?: { [key: string]: any },\n    messageProperties?: { [key: string]: string },\n  ): Buffer {\n    const batchEnvelope: RheaMessage = {\n      body: RheaMessageUtil.data_sections(encodedMessages),\n      message_annotations: annotations,\n      application_properties: applicationProperties,\n    };\n    if (messageProperties) {\n      for (const prop of RheaMessagePropertiesList) {\n        if ((messageProperties as any)[prop]) {\n          (batchEnvelope as any)[prop] = (messageProperties as any)[prop];\n        }\n      }\n    }\n    return RheaMessageUtil.encode(batchEnvelope);\n  }\n\n  /**\n   * Represents the single AMQP message which is the result of encoding all the events\n   * added into the `ServiceBusMessageBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `ServiceBusMessageBatch` instance is passed to the `sendBatch()` method on the `Sender`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  _generateMessage(): Buffer {\n    return this._generateBatch(\n      this._encodedMessages,\n      this._batchAnnotations,\n      this._batchApplicationProperties,\n      this._batchMessageProperties,\n    );\n  }\n\n  /**\n   * The message annotations to apply on the batch envelope.\n   * This will reflect the message annotations on the first message\n   * that was added to the batch.\n   */\n  private _batchAnnotations?: MessageAnnotations;\n  /**\n   * The message properties to apply on the batch envelope.\n   * This will reflect the message properties on the first message\n   * that was added to the batch.\n   */\n  private _batchMessageProperties?: { [key: string]: string };\n  /**\n   * The application properties to apply on the batch envelope.\n   * This will reflect the application properties on the first message\n   * that was added to the batch.\n   */\n  private _batchApplicationProperties?: { [key: string]: any };\n\n  /**\n   * Tries to add a message to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next message.\n   *\n   * @param originalMessage - An individual service bus message.\n   * @returns A boolean value indicating if the message has been added to the batch or not.\n   */\n  public tryAddMessage(\n    originalMessage: ServiceBusMessage | AmqpAnnotatedMessage,\n    options: TryAddOptions = {},\n  ): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"message\", originalMessage);\n    throwIfNotValidServiceBusMessage(originalMessage, errorInvalidMessageTypeSingle);\n\n    const { message, spanContext } = instrumentMessage(\n      originalMessage,\n      options,\n      this._context.config.entityPath!,\n      this._context.config.host,\n      \"publish\",\n    );\n\n    // Convert ServiceBusMessage to AmqpMessage.\n    const amqpMessage = toRheaMessage(message, defaultDataTransformer);\n\n    const encodedMessage = RheaMessageUtil.encode(amqpMessage);\n    let currentSize = this._sizeInBytes;\n\n    // The first time an event is added, we need to calculate\n    // the overhead of creating an AMQP batch, including the\n    // message_annotations, application_properties and message_properties\n    // that are taken from the 1st message.\n    if (this.count === 0) {\n      if (amqpMessage.message_annotations) {\n        this._batchAnnotations = amqpMessage.message_annotations;\n      }\n      if (amqpMessage.application_properties) {\n        this._batchApplicationProperties = amqpMessage.application_properties;\n      }\n      for (const prop of RheaMessagePropertiesList) {\n        if ((amqpMessage as any)[prop]) {\n          (this._batchMessageProperties as any)[prop] = (amqpMessage as any)[prop];\n        }\n      }\n      // Figure out the overhead of creating a batch by generating an empty batch\n      // with the expected batch annotations.\n      currentSize += this._generateBatch(\n        [],\n        this._batchAnnotations,\n        this._batchApplicationProperties,\n        this._batchMessageProperties,\n      ).length;\n    }\n\n    const messageSize = encodedMessage.length;\n    const messageOverhead =\n      messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;\n    currentSize += messageSize + messageOverhead;\n    // Check if the size of the batch exceeds the maximum allowed size\n    // once we add the new event to it.\n    if (currentSize > this._maxSizeInBytes) {\n      return false;\n    }\n\n    // The message will fit in the batch, so it is now safe to store it.\n    this._encodedMessages.push(encodedMessage);\n    if (spanContext) {\n      this._spanContexts.push(spanContext);\n    }\n\n    this._sizeInBytes = currentSize;\n    return true;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { senderLogger as logger } from \"../log\";\nimport {\n  AmqpError,\n  AwaitableSender,\n  AwaitableSenderOptions,\n  EventContext,\n  OnAmqpEvent,\n  message as RheaMessageUtil,\n} from \"rhea-promise\";\nimport {\n  Constants,\n  ErrorNameConditionMapper,\n  MessagingError,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  retry,\n  AmqpAnnotatedMessage,\n} from \"@azure/core-amqp\";\nimport { ServiceBusMessage, toRheaMessage } from \"../serviceBusMessage\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { LinkEntity } from \"./linkEntity\";\nimport { getUniqueName, waitForSendable, waitForTimeoutOrAbortOrResolve } from \"../util/utils\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport { ServiceBusMessageBatch, ServiceBusMessageBatchImpl } from \"../serviceBusMessageBatch\";\nimport { CreateMessageBatchOptions } from \"../models\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { ServiceBusError, translateServiceBusError } from \"../serviceBusError\";\nimport { isDefined } from \"@azure/core-util\";\nimport { defaultDataTransformer } from \"../dataTransformer\";\n\n/**\n * @internal\n * Describes the MessageSender that will send messages to ServiceBus.\n */\nexport class MessageSender extends LinkEntity<AwaitableSender> {\n  /**\n   * The handler function to handle errors that happen on the\n   * underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpError: OnAmqpEvent;\n  /**\n   * The handler function to handle \"sender_close\" event\n   * that happens on the underlying sender.\n   * @readonly\n   */\n  private readonly _onAmqpClose: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEvent;\n  private _retryOptions: RetryOptions;\n\n  constructor(\n    private identifier: string,\n    connectionContext: ConnectionContext,\n    entityPath: string,\n    retryOptions: RetryOptions,\n  ) {\n    super(entityPath, entityPath, connectionContext, \"sender\", logger, {\n      address: entityPath,\n      audience: `${connectionContext.config.endpoint}${entityPath}`,\n    });\n    this._retryOptions = retryOptions;\n    this._onAmqpError = (context: EventContext) => {\n      const senderError = context.sender && context.sender.error;\n      logger.logError(\n        senderError,\n        \"%s 'sender_error' event occurred on the sender '%s' with address '%s'. \" +\n          \"The associated error\",\n        this.logPrefix,\n        this.name,\n        this.address,\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n      logger.logError(\n        sessionError,\n        \"%s 'session_error' event occurred on the session of sender '%s' with address '%s'. \" +\n          \"The associated error\",\n        this.logPrefix,\n        this.name,\n        this.address,\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const senderError = context.sender && context.sender.error;\n\n      logger.logError(\n        senderError,\n        `${this.logPrefix} 'sender_close' event occurred. The associated error is`,\n      );\n\n      await this.onDetached().catch((err) => {\n        logger.logError(\n          err,\n          `${this.logPrefix} error when closing sender after 'sender_close' event`,\n        );\n      });\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const sessionError = context.session && context.session.error;\n\n      logger.logError(\n        sessionError,\n        `${this.logPrefix} 'session_close' event occurred. The associated error is`,\n      );\n\n      await this.onDetached().catch((err) => {\n        logger.logError(\n          err,\n          `${this.logPrefix} error when closing sender after 'session_close' event`,\n        );\n      });\n    };\n  }\n\n  private _createSenderOptions(newName?: boolean): AwaitableSenderOptions {\n    if (newName) this.name = getUniqueName(this.baseName);\n    const srOptions: AwaitableSenderOptions = {\n      name: this.name,\n      target: {\n        address: this.address,\n      },\n      source: this.identifier,\n      onError: this._onAmqpError,\n      onClose: this._onAmqpClose,\n      onSessionError: this._onSessionError,\n      onSessionClose: this._onSessionClose,\n    };\n    logger.verbose(`${this.logPrefix} Creating sender with options: %O`, srOptions);\n    return srOptions;\n  }\n\n  /**\n   * Tries to send the message to ServiceBus if there is enough credit to send them\n   * and the circular buffer has available space to settle the message after sending them.\n   *\n   * We have implemented a synchronous send over here in the sense that we shall be waiting\n   * for the message to be accepted or rejected and accordingly resolve or reject the promise.\n   *\n   * @param encodedMessage - The encoded message to be sent to ServiceBus.\n   * @param sendBatch - Boolean indicating whether the encoded message represents a batch of messages or not\n   */\n  private _trySend(\n    encodedMessage: Buffer,\n    sendBatch: boolean,\n    options: OperationOptionsBase | undefined,\n  ): Promise<void> {\n    const abortSignal = options?.abortSignal;\n    const timeoutInMs = !isDefined(this._retryOptions.timeoutInMs)\n      ? Constants.defaultOperationTimeoutInMs\n      : this._retryOptions.timeoutInMs;\n\n    const sendEventPromise = async (): Promise<void> => {\n      const initStartTime = Date.now();\n      if (!this.isOpen()) {\n        try {\n          await waitForTimeoutOrAbortOrResolve({\n            actionFn: () => this.open(undefined, options?.abortSignal),\n            abortSignal: options?.abortSignal,\n            timeoutMs: timeoutInMs,\n            timeoutMessage:\n              `[${this._context.connectionId}] Sender \"${this.name}\" ` +\n              `with address \"${this.address}\", was not able to send the message right now, due ` +\n              `to operation timeout.`,\n          });\n        } catch (err: any) {\n          const translatedError = translateServiceBusError(err);\n          logger.logError(\n            translatedError,\n            \"%s An error occurred while creating the sender\",\n            this.logPrefix,\n            this.name,\n          );\n          throw translatedError;\n        }\n      }\n\n      const timeTakenByInit = Date.now() - initStartTime;\n\n      logger.verbose(\n        \"%s Sender '%s', credit: %d available: %d\",\n        this.logPrefix,\n        this.name,\n        this.link?.credit,\n        this.link?.session?.outgoing?.available(),\n      );\n\n      const waitingTime = await waitForSendable(\n        logger,\n        this.logPrefix,\n        this.name,\n        timeoutInMs - timeTakenByInit,\n        this.link,\n        this.link?.session?.outgoing?.available(),\n      );\n\n      if (timeoutInMs <= timeTakenByInit + waitingTime) {\n        const desc: string =\n          `${this.logPrefix} Sender \"${this.name}\" ` +\n          `with address \"${this.address}\", was not able to send the message right now, due ` +\n          `to operation timeout.`;\n        logger.warning(desc);\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description: desc,\n        };\n        throw translateServiceBusError(e);\n      }\n\n      if (!this.link) {\n        const msg = `[${this.logPrefix}] Cannot send the message. Link is not ready.`;\n        logger.warning(msg);\n        const amqpError: AmqpError = {\n          condition: ErrorNameConditionMapper.SenderNotReadyError,\n          description: msg,\n        };\n        throw translateServiceBusError(amqpError);\n      }\n      try {\n        const delivery = await this.link.send(encodedMessage, {\n          format: sendBatch ? 0x80013700 : 0,\n          timeoutInSeconds: (timeoutInMs - timeTakenByInit - waitingTime) / 1000,\n          abortSignal,\n        });\n        logger.verbose(\n          \"%s Sender '%s', sent message with delivery id: %d\",\n          this.logPrefix,\n          this.name,\n          delivery.id,\n        );\n      } catch (error: any) {\n        const translatedError = translateServiceBusError(error.innerError || error);\n        logger.logError(\n          translatedError,\n          `${this.logPrefix} An error occurred while sending the message`,\n        );\n        throw translatedError;\n      }\n    };\n    const config: RetryConfig<void> = {\n      operation: sendEventPromise,\n      connectionId: this._context.connectionId!,\n      operationType: RetryOperationType.sendMessage,\n      retryOptions: this._retryOptions,\n      abortSignal: abortSignal,\n    };\n\n    return retry<void>(config);\n  }\n\n  protected createRheaLink(options: AwaitableSenderOptions): Promise<AwaitableSender> {\n    return this._context.connection.createAwaitableSender(options);\n  }\n\n  /**\n   * Initializes the sender session on the connection.\n   */\n  public async open(\n    options?: AwaitableSenderOptions,\n    abortSignal?: AbortSignalLike,\n  ): Promise<void> {\n    try {\n      if (!options) {\n        options = this._createSenderOptions();\n      }\n      await this.initLink(options, abortSignal);\n    } catch (err: any) {\n      const translatedError = translateServiceBusError(err);\n      logger.logError(\n        translatedError,\n        `${this.logPrefix} An error occurred while creating the sender`,\n      );\n      // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.\n      if ((translatedError as MessagingError).code === \"OperationTimeoutError\") {\n        translatedError.message =\n          \"Failed to create a sender within allocated time and retry attempts.\";\n      }\n      throw translatedError;\n    }\n  }\n\n  /**\n   * Closes the rhea link.\n   * To be called when connection is disconnected, onAmqpClose and onSessionClose events.\n   */\n  async onDetached(): Promise<void> {\n    // Clears the token renewal timer. Closes the link and its session if they are open.\n    // Removes the link and its session if they are present in rhea's cache.\n    await this.closeLink();\n  }\n\n  /**\n   * Determines whether the AMQP sender link is open. If open then returns true else returns false.\n   */\n  isOpen(): boolean {\n    const result: boolean = this.link == null ? false : this.link.isOpen();\n    logger.verbose(\n      \"%s Sender '%s' with address '%s' is open? -> %s\",\n      this.logPrefix,\n      this.name,\n      this.address,\n      result,\n    );\n    return result;\n  }\n\n  /**\n   * Sends the given message, with the given options on this link\n   *\n   * @param data - Message to send. Will be sent as UTF8-encoded JSON string.\n   */\n  async send(\n    data: ServiceBusMessage | AmqpAnnotatedMessage,\n    options?: OperationOptionsBase,\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const amqpMessage = toRheaMessage(data, defaultDataTransformer);\n\n      // TODO: this body of logic is really similar to what's in sendMessages. Unify what we can.\n      const encodedMessage = RheaMessageUtil.encode(amqpMessage);\n      logger.verbose(\"%s Sender '%s', trying to send message: %O\", this.logPrefix, this.name, data);\n      return await this._trySend(encodedMessage, false, options);\n    } catch (err: any) {\n      logger.logError(\n        err,\n        \"%s An error occurred while sending the message: %O\\nError\",\n        this.logPrefix,\n        data,\n      );\n      throw err;\n    }\n  }\n\n  /**\n   * Returns maximum message size on the AMQP sender link.\n   *\n   * Options to configure the `createBatch` method on the `Sender`.\n   * - `maxSizeInBytes`: The upper limit for the size of batch.\n   *\n   * Example usage:\n   * ```js\n   * {\n   *     retryOptions: { maxRetries: 5; timeoutInMs: 10 }\n   * }\n   * ```\n   */\n  async getMaxMessageSize(\n    options: {\n      retryOptions?: RetryOptions;\n    } & Pick<OperationOptionsBase, \"abortSignal\"> = {},\n  ): Promise<number> {\n    const retryOptions = options.retryOptions || {};\n    if (this.isOpen()) {\n      return this.link!.maxMessageSize;\n    }\n\n    const config: RetryConfig<number> = {\n      operation: async () => {\n        await this.open(undefined, options?.abortSignal);\n\n        if (this.link) {\n          return this.link.maxMessageSize;\n        }\n\n        throw new ServiceBusError(\n          \"Link failed to initialize, cannot get max message size.\",\n          \"GeneralError\",\n        );\n      },\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.senderLink,\n      retryOptions: retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n\n    return retry(config);\n  }\n\n  async createBatch(options?: CreateMessageBatchOptions): Promise<ServiceBusMessageBatch> {\n    throwErrorIfConnectionClosed(this._context);\n    let maxMessageSize = await this.getMaxMessageSize({\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    });\n    if (options?.maxSizeInBytes) {\n      if (options.maxSizeInBytes > maxMessageSize!) {\n        const error = new Error(\n          `Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`,\n        );\n        throw error;\n      }\n      maxMessageSize = options.maxSizeInBytes;\n    }\n    return new ServiceBusMessageBatchImpl(this._context, maxMessageSize!);\n  }\n\n  async sendBatch(\n    batchMessage: ServiceBusMessageBatch,\n    options?: OperationOptionsBase,\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      logger.verbose(\n        \"%s Sender '%s', sending encoded batch message.\",\n        this.logPrefix,\n        this.name,\n        batchMessage,\n      );\n      return await this._trySend(batchMessage._generateMessage(), true, options);\n    } catch (err: any) {\n      logger.logError(\n        err,\n        \"%s Sender '%s': An error occurred while sending the messages: %O\\nError\",\n        this.logPrefix,\n        this.name,\n        batchMessage,\n      );\n      throw err;\n    }\n  }\n\n  static create(\n    identifier: string,\n    context: ConnectionContext,\n    entityPath: string,\n    retryOptions: RetryOptions,\n  ): MessageSender {\n    throwErrorIfConnectionClosed(context);\n\n    const sbSender = new MessageSender(identifier, context, entityPath, retryOptions);\n    context.senders[sbSender.name] = sbSender;\n    return sbSender;\n  }\n\n  protected removeLinkFromContext(): void {\n    delete this._context.senders[this.name];\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport Long from \"long\";\nimport { MessageSender } from \"./core/messageSender\";\nimport { ServiceBusMessage } from \"./serviceBusMessage\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport {\n  errorInvalidMessageTypeSingleOrArray,\n  getSenderClosedErrorMsg,\n  throwErrorIfConnectionClosed,\n  throwIfNotValidServiceBusMessage,\n  throwTypeErrorIfNotInstanceOfParameterType,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n} from \"./util/errors\";\nimport { ServiceBusMessageBatch } from \"./serviceBusMessageBatch\";\nimport { CreateMessageBatchOptions } from \"./models\";\nimport {\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  retry,\n  AmqpAnnotatedMessage,\n} from \"@azure/core-amqp\";\nimport { OperationOptionsBase } from \"./modelsToBeSharedWithEventHubs\";\nimport { TracingSpanLink } from \"@azure/core-tracing\";\nimport { senderLogger as logger } from \"./log\";\nimport { toSpanOptions, tracingClient } from \"./diagnostics/tracing\";\nimport { ensureValidIdentifier } from \"./util/utils\";\nimport { ServiceBusError } from \"./serviceBusError\";\nimport { instrumentMessage } from \"./diagnostics/instrumentServiceBusMessage\";\n\n/**\n * A Sender can be used to send messages, schedule messages to be sent at a later time\n * and cancel such scheduled messages.\n * Use the `createSender` function on the ServiceBusClient to instantiate a Sender.\n * The Sender class is an abstraction over the underlying AMQP sender link.\n */\nexport interface ServiceBusSender {\n  /**\n   * A name used to identify the sender. This can be used to correlate logs and exceptions.\n   * If not specified or empty, a random unique one will be generated.\n   */\n  identifier: string;\n  /**\n   * Sends the given messages after creating an AMQP Sender link if it doesn't already exist.\n   *\n   * - To send messages to a `session` and/or `partition` enabled Queue/Topic, set the `sessionId`\n   * and/or `partitionKey` properties respectively on the messages.\n   * - All messages passed to the same sendMessages() call should have the same `sessionId` (if using\n   *  sessions) and the same `partitionKey` (if using partitions).\n   *\n   * **Note:**\n   *\n   *    __If you want to send messages of size greater than 1MB, please send individual messages instead of sending a batched message or an array of messages like below.__\n   *\n   *  `await sender.sendMessages(message);`\n   *\n   * __This is because the batched messages are not capable of sending the larger messages yet. You'll hit the `force detached` error in this case otherwise. Read [service-bus-premium-messaging#large-messages-support](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-premium-messaging#large-messages-support). More info at [#23014](https://github.com/Azure/azure-sdk-for-js/pull/23014).__\n   *\n   * @param messages - A single message or an array of messages or a batch of messages created via the createBatch()\n   * method to send.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @throws `ServiceBusError` with the code `MessageSizeExceeded` if the provided messages do not fit in a single `ServiceBusMessageBatch`.\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws `ServiceBusError` if the service returns an error while sending messages to the service.\n   */\n  sendMessages(\n    messages:\n      | ServiceBusMessage\n      | ServiceBusMessage[]\n      | ServiceBusMessageBatch\n      | AmqpAnnotatedMessage\n      | AmqpAnnotatedMessage[],\n    options?: OperationOptionsBase,\n  ): Promise<void>;\n\n  /**\n   * Creates an instance of `ServiceBusMessageBatch` to which one can add messages until the maximum supported size is reached.\n   * The batch can be passed to the {@link send} method to send the messages to Azure Service Bus.\n   * @param options - Configures the behavior of the batch.\n   * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   *\n   * @throws `ServiceBusError` if an error is encountered while sending a message.\n   * @throws Error if the underlying connection or sender has been closed.\n   */\n  createMessageBatch(options?: CreateMessageBatchOptions): Promise<ServiceBusMessageBatch>;\n\n  // TODO: Commented out to come up with an alternative name\n  // /**\n  //  * Opens the AMQP link to Azure Service Bus from the sender.\n  //  *\n  //  * It is not necessary to call this method in order to use the sender. It is\n  //  * recommended to call this before your first sendMessages() call if you\n  //  * want to front load the work of setting up the AMQP link to the service.\n  //  *\n  //  * @param options - Options to configure tracing and the abortSignal.\n  //  */\n  // open(options?: OperationOptionsBase): Promise<void>;\n\n  /**\n   * Returns `true` if either the sender or the client that created it has been closed.\n   * @readonly\n   */\n  isClosed: boolean;\n\n  /**\n   * Schedules given messages to appear on Service Bus Queue/Subscription at a later time.\n   *\n   * @param messages - Message or an array of messages that need to be scheduled.\n   * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns The sequence numbers of messages that were scheduled.\n   * You will need the sequence number if you intend to cancel the scheduling of the messages.\n   * Save the `Long` type as-is in your application without converting to number. Since JavaScript\n   * only supports 53 bit numbers, converting the `Long` to number will cause loss in precision.\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws `ServiceBusError` if the service returns an error while scheduling messages.\n   */\n  scheduleMessages(\n    messages:\n      | ServiceBusMessage\n      | ServiceBusMessage[]\n      | AmqpAnnotatedMessage\n      | AmqpAnnotatedMessage[],\n    scheduledEnqueueTimeUtc: Date,\n    options?: OperationOptionsBase,\n  ): Promise<Long[]>;\n\n  /**\n   * Cancels multiple messages that were scheduled to appear on a ServiceBus Queue/Subscription.\n   * @param sequenceNumbers - Sequence number or an array of sequence numbers of the messages to be cancelled.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @throws Error if the underlying connection, client or sender is closed.\n   * @throws `ServiceBusError` if the service returns an error while canceling scheduled messages.\n   */\n  cancelScheduledMessages(\n    sequenceNumbers: Long | Long[],\n    options?: OperationOptionsBase,\n  ): Promise<void>;\n  /**\n   * Path of the entity for which the sender has been created.\n   */\n  entityPath: string;\n  /**\n   * Closes the underlying AMQP sender link.\n   * Once closed, the sender cannot be used for any further operations.\n   * Use the `createSender` function on the QueueClient or TopicClient to instantiate a new Sender\n   *\n   */\n  close(): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport class ServiceBusSenderImpl implements ServiceBusSender {\n  public identifier: string;\n  private _retryOptions: RetryOptions;\n  /**\n   * Denotes if close() was called on this sender\n   */\n  private _isClosed: boolean = false;\n  private _sender: MessageSender;\n  public entityPath: string;\n\n  private get logPrefix(): string {\n    return `[${this._context.connectionId}|sender:${this.entityPath}]`;\n  }\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   */\n  constructor(\n    private _context: ConnectionContext,\n    private _entityPath: string,\n    retryOptions: RetryOptions = {},\n    identifier?: string,\n  ) {\n    throwErrorIfConnectionClosed(_context);\n    this.entityPath = _entityPath;\n    this.identifier = ensureValidIdentifier(this.entityPath, identifier);\n    this._sender = MessageSender.create(this.identifier, this._context, _entityPath, retryOptions);\n    this._retryOptions = retryOptions;\n  }\n\n  private _throwIfSenderOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (this.isClosed) {\n      const errorMessage = getSenderClosedErrorMsg(this._entityPath);\n      const error = new Error(errorMessage);\n      logger.logError(error, `[${this._context.connectionId}] is closed`);\n      throw error;\n    }\n  }\n\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  async sendMessages(\n    messages:\n      | ServiceBusMessage\n      | ServiceBusMessage[]\n      | ServiceBusMessageBatch\n      | AmqpAnnotatedMessage\n      | AmqpAnnotatedMessage[],\n    options?: OperationOptionsBase,\n  ): Promise<void> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"messages\", messages);\n\n    if (!isServiceBusMessageBatch(messages) && !Array.isArray(messages)) {\n      // Case 1: Single message\n      throwIfNotValidServiceBusMessage(messages, errorInvalidMessageTypeSingleOrArray);\n      const originalMessage = messages as ServiceBusMessage | AmqpAnnotatedMessage;\n      const { message, spanContext } = instrumentMessage(\n        originalMessage,\n        options ?? {},\n        this.entityPath,\n        this._context.config.host,\n        \"publish\",\n      );\n      const spanLinks: TracingSpanLink[] = spanContext ? [{ tracingContext: spanContext }] : [];\n      return tracingClient.withSpan(\n        \"ServiceBusSender.send\",\n        options ?? {},\n        (updatedOptions) => this._sender.send(message, updatedOptions),\n        {\n          spanLinks,\n          ...toSpanOptions(\n            { entityPath: this.entityPath, host: this._context.config.host },\n            \"publish\",\n            \"client\",\n          ),\n        },\n      );\n    }\n\n    let batch: ServiceBusMessageBatch;\n    if (isServiceBusMessageBatch(messages)) {\n      // Case 2: Batch message\n      batch = messages;\n    } else {\n      // Case 3: Array of messages\n      batch = await this.createMessageBatch(options);\n      for (const message of messages) {\n        throwIfNotValidServiceBusMessage(message, errorInvalidMessageTypeSingleOrArray);\n        if (!batch.tryAddMessage(message, options)) {\n          // this is too big - throw an error\n          throw new ServiceBusError(\n            \"Messages were too big to fit in a single batch. Remove some messages and try again or create your own batch using createBatch(), which gives more fine-grained control.\",\n            \"MessageSizeExceeded\",\n          );\n        }\n      }\n    }\n\n    const spanLinks: TracingSpanLink[] = batch._messageSpanContexts.map((tracingContext) => {\n      return {\n        tracingContext,\n      };\n    });\n\n    return tracingClient.withSpan(\n      \"ServiceBusSender.send\",\n      options ?? {},\n      (updatedOptions) => this._sender.sendBatch(batch, updatedOptions),\n      {\n        spanLinks,\n        ...toSpanOptions(\n          { entityPath: this.entityPath, host: this._context.config.host },\n          \"publish\",\n          \"client\",\n        ),\n      },\n    );\n  }\n\n  async createMessageBatch(options?: CreateMessageBatchOptions): Promise<ServiceBusMessageBatch> {\n    this._throwIfSenderOrConnectionClosed();\n    return this._sender.createBatch(options);\n  }\n\n  async scheduleMessages(\n    messages:\n      | ServiceBusMessage\n      | ServiceBusMessage[]\n      | AmqpAnnotatedMessage\n      | AmqpAnnotatedMessage[],\n    scheduledEnqueueTimeUtc: Date,\n    options: OperationOptionsBase = {},\n  ): Promise<Long[]> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"scheduledEnqueueTimeUtc\",\n      scheduledEnqueueTimeUtc,\n    );\n    throwTypeErrorIfNotInstanceOfParameterType(\n      this._context.connectionId,\n      \"scheduledEnqueueTimeUtc\",\n      scheduledEnqueueTimeUtc,\n      Date,\n    );\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"messages\", messages);\n    const messagesToSchedule = Array.isArray(messages) ? messages : [messages];\n\n    for (const message of messagesToSchedule) {\n      throwIfNotValidServiceBusMessage(message, errorInvalidMessageTypeSingleOrArray);\n    }\n\n    const scheduleMessageOperationPromise = async (): Promise<Long[]> => {\n      return this._context\n        .getManagementClient(this._entityPath)\n        .scheduleMessages(scheduledEnqueueTimeUtc, messagesToSchedule, {\n          ...options,\n          associatedLinkName: this._sender.name,\n          requestName: \"scheduleMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs,\n        });\n    };\n    const config: RetryConfig<Long[]> = {\n      operation: scheduleMessageOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<Long[]>(config);\n  }\n\n  async cancelScheduledMessages(\n    sequenceNumbers: Long | Long[],\n    options: OperationOptionsBase = {},\n  ): Promise<void> {\n    this._throwIfSenderOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers,\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers,\n    );\n\n    const sequenceNumbersToCancel = Array.isArray(sequenceNumbers)\n      ? sequenceNumbers\n      : [sequenceNumbers];\n    const cancelSchedulesMessagesOperationPromise = async (): Promise<void> => {\n      return this._context\n        .getManagementClient(this._entityPath)\n        .cancelScheduledMessages(sequenceNumbersToCancel, {\n          ...options,\n          associatedLinkName: this._sender.name,\n          requestName: \"cancelScheduledMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs,\n        });\n    };\n    const config: RetryConfig<void> = {\n      operation: cancelSchedulesMessagesOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<void>(config);\n  }\n\n  // async open(options?: OperationOptionsBase): Promise<void> {\n  //   this._throwIfSenderOrConnectionClosed();\n\n  //   const config: RetryConfig<void> = {\n  //     // TODO: Pass tracing options too\n  //     operation: () => this._sender.open(undefined, options?.abortSignal),\n  //     connectionId: this._context.connectionId,\n  //     operationType: RetryOperationType.senderLink,\n  //     retryOptions: this._retryOptions,\n  //     abortSignal: options?.abortSignal\n  //   };\n\n  //   return retry<void>(config);\n  // }\n\n  async close(): Promise<void> {\n    try {\n      this._isClosed = true;\n      await this._sender.close();\n    } catch (err: any) {\n      logger.logError(err, `${this.logPrefix} An error occurred while closing the Sender`);\n      throw err;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function isServiceBusMessageBatch(\n  messageBatchOrAnything: unknown,\n): messageBatchOrAnything is ServiceBusMessageBatch {\n  if (messageBatchOrAnything == null) {\n    return false;\n  }\n\n  const possibleBatch = messageBatchOrAnything as ServiceBusMessageBatch;\n\n  return (\n    typeof possibleBatch.tryAddMessage === \"function\" &&\n    typeof possibleBatch.maxSizeInBytes === \"number\" &&\n    typeof possibleBatch.sizeInBytes === \"number\"\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Constants,\n  ErrorNameConditionMapper,\n  MessagingError,\n  RetryOptions,\n  StandardAbortMessage,\n} from \"@azure/core-amqp\";\nimport {\n  AmqpError,\n  EventContext,\n  OnAmqpEvent,\n  Receiver,\n  ReceiverEvents,\n  ReceiverOptions,\n} from \"rhea-promise\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { LinkEntity } from \"../core/linkEntity\";\nimport { DispositionStatusOptions } from \"../core/managementClient\";\nimport { OnAmqpEventAsPromise, OnError, OnMessage } from \"../core/messageReceiver\";\nimport { receiverLogger as logger } from \"../log\";\nimport { DispositionType, ServiceBusMessageImpl } from \"../serviceBusMessage\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors\";\nimport { calculateRenewAfterDuration, convertTicksToDate } from \"../util/utils\";\nimport { BatchingReceiverLite, MinimalReceiver } from \"../core/batchingReceiver\";\nimport { onMessageSettled, DeferredPromiseAndTimer, createReceiverOptions } from \"../core/shared\";\nimport { AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { ReceiverHelper } from \"../core/receiverHelper\";\nimport {\n  ServiceBusSessionReceiverOptions,\n  ProcessErrorArgs,\n  ReceiveMode,\n  SubscribeOptions,\n} from \"../models\";\nimport { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs\";\nimport { ServiceBusError, translateServiceBusError } from \"../serviceBusError\";\nimport { abandonMessage, completeMessage } from \"../receivers/receiverCommon\";\nimport { delay, isDefined } from \"@azure/core-util\";\n\n/**\n * Describes the options that need to be provided while creating a message session receiver link.\n * @internal\n */\nexport interface CreateMessageSessionReceiverLinkOptions {\n  onClose: OnAmqpEventAsPromise;\n  onSessionClose: OnAmqpEventAsPromise;\n  onError: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSettled: OnAmqpEvent;\n  sessionId?: string;\n}\n\n/**\n * @internal\n * Describes all the options that can be set while instantiating a MessageSession object.\n */\nexport type MessageSessionOptions = Pick<\n  ServiceBusSessionReceiverOptions,\n  \"maxAutoLockRenewalDurationInMs\" | \"abortSignal\"\n> & {\n  receiveMode?: ReceiveMode;\n  retryOptions: RetryOptions | undefined;\n  skipParsingBodyAsJson: boolean;\n  skipConvertingDate: boolean;\n};\n\n/**\n * @internal\n * Describes the receiver for a Message Session.\n */\nexport class MessageSession extends LinkEntity<Receiver> {\n  /**\n   * Provides the duration until which the session is locked.\n   */\n  sessionLockedUntilUtc!: Date;\n  /**\n   * The sessionId for the message session. Empty string is valid sessionId.\n   */\n  sessionId!: string;\n  /**\n   * The maximum number of concurrent sessions that the\n   * client should initiate.\n   * - **Default**: `1`.\n   */\n  maxConcurrentSessions?: number;\n  /**\n   * The maximum number of messages that should be\n   * processed concurrently in a session while in streaming mode. Once this limit has been reached,\n   * more messages will not be received until the user's message handler has completed processing current message.\n   * - **Default**: `1` (message in a session at a time).\n   */\n  maxConcurrentCalls: number = 1;\n  /**\n   * The mode in which messages should be received.\n   * Default: ReceiveMode.peekLock\n   */\n  receiveMode: ReceiveMode;\n  /**\n   * Indicates whether `Message.complete()` should be called\n   * automatically after the message processing is complete while receiving messages with handlers.\n   * Default: false.\n   */\n  autoComplete: boolean;\n  /**\n   * The maximum duration within which the\n   * lock will be renewed automatically. This value should be greater than the longest message\n   * lock duration; for example, the `lockDuration` property on the received message.\n   *\n   * Default: `300 * 1000` (5 minutes);\n   */\n  maxAutoRenewDurationInMs: number;\n  /**\n   * Should lock renewal happen automatically.\n   */\n  autoRenewLock: boolean;\n  /**\n   * Denotes if we are currently receiving messages\n   */\n  get isReceivingMessages(): boolean {\n    return this._batchingReceiverLite.isReceivingMessages || this._isReceivingMessagesForSubscriber;\n  }\n\n  private _batchingReceiverLite: BatchingReceiverLite;\n  private _isReceivingMessagesForSubscriber: boolean;\n\n  /**\n   * Maintains a map of deliveries that\n   * are being actively disposed. It acts as a store for correlating the responses received for\n   * active dispositions.\n   */\n  private _deliveryDispositionMap: Map<number, DeferredPromiseAndTimer> = new Map<\n    number,\n    DeferredPromiseAndTimer\n  >();\n  /**\n   * The message handler provided by the user that will\n   * be wrapped inside _onAmqpMessage.\n   */\n  private _onMessage!: OnMessage;\n  /**\n   * The error handler provided by the user that will be wrapped\n   * inside _onAmqpError.\n   */\n  private _onError?: OnError;\n  /**\n   * If the user provided error handler is present then it will\n   * notify the user's error handler about the error.\n   */\n  private _notifyError: OnError;\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_close\" event.\n   */\n  private _onAmqpClose: OnAmqpEventAsPromise;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEventAsPromise;\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_error\" event.\n   */\n  private _onAmqpError: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"settled\" event.\n   */\n  private _onSettled: OnAmqpEvent;\n  /**\n   * The session lock renewal timer that keeps\n   * track of when the MessageSession is due for session lock renewal.\n   */\n  private _sessionLockRenewalTimer?: NodeJS.Timeout;\n\n  private _totalAutoLockRenewDuration: number;\n\n  /**\n   * Whether to prevent the client from running JSON.parse() on the message body when receiving the message.\n   */\n  private skipParsingBodyAsJson: boolean;\n\n  /**\n   * Whether to skip converting Date type on properties of message annotations\n   * or application properties into numbers when receiving the message. By\n   * default, properties of Date type is converted into UNIX epoch number for\n   * compatibility.\n   */\n  private skipConvertingDate: boolean;\n\n  public get receiverHelper(): ReceiverHelper {\n    return this._receiverHelper;\n  }\n  private _receiverHelper: ReceiverHelper;\n\n  /**\n   * Ensures that the session lock is renewed before it expires. The lock will not be renewed for\n   * more than the configured totalAutoLockRenewDuration.\n   */\n  private _ensureSessionLockRenewal(): void {\n    if (\n      this.autoRenewLock &&\n      new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc! &&\n      Date.now() < this._totalAutoLockRenewDuration &&\n      this.isOpen()\n    ) {\n      const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc!);\n      this._sessionLockRenewalTimer = setTimeout(async () => {\n        try {\n          logger.verbose(\n            \"%s Attempting to renew the session lock for MessageSession '%s' \" + \"with name '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n            this.name,\n          );\n          this.sessionLockedUntilUtc = await this._context\n            .getManagementClient(this.entityPath)\n            .renewSessionLock(this.sessionId, {\n              associatedLinkName: this.name,\n              timeoutInMs: 10000,\n            });\n          logger.verbose(\n            \"%s Successfully renewed the session lock for MessageSession '%s' \" + \"with name '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n            this.name,\n          );\n          logger.verbose(\n            \"%s Calling _ensureSessionLockRenewal() again for MessageSession '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n          );\n          this._ensureSessionLockRenewal();\n        } catch (err: any) {\n          logger.logError(\n            err,\n            \"%s An error occurred while renewing the session lock for MessageSession '%s'\",\n            this.logPrefix,\n            this.sessionId,\n          );\n        }\n      }, nextRenewalTimeout);\n      logger.verbose(\n        \"%s MessageSession '%s' has next session lock renewal in %d milliseconds @(%s).\",\n        this.logPrefix,\n        this.sessionId,\n        nextRenewalTimeout,\n        new Date(Date.now() + nextRenewalTimeout).toString(),\n      );\n    }\n  }\n\n  protected async createRheaLink(\n    options: ReceiverOptions,\n    _abortSignal?: AbortSignalLike,\n  ): Promise<Receiver> {\n    this._lastSBError = undefined;\n    let errorMessage: string = \"\";\n\n    const link = await this._context.connection.createReceiver(options);\n    this._intermediateLink = link;\n\n    const receivedSessionId = link.source?.filter?.[Constants.sessionFilterName];\n    if (!this._providedSessionId && !receivedSessionId) {\n      // When we ask for any sessions (passing option of session-filter: undefined),\n      // but don't receive one back, check whether service has sent any error.\n      if (\n        options.source &&\n        typeof options.source !== \"string\" &&\n        options.source.filter &&\n        Constants.sessionFilterName in options.source.filter &&\n        options.source.filter![Constants.sessionFilterName] === undefined\n      ) {\n        await delay(1); // yield to eventloop\n        if (this._lastSBError) {\n          logger.verbose(\"%s cleaning up resources held by link\", this.logPrefix);\n          await link.close({ closeSession: true });\n          link.remove();\n          throw this._lastSBError;\n        }\n      }\n      // Ideally this code path should never be reached as `MessageSession.createReceiver()` should fail instead\n      // TODO: https://github.com/Azure/azure-sdk-for-js/issues/9775 to figure out why this code path indeed gets hit.\n      errorMessage = `Failed to create a receiver. No unlocked sessions available.`;\n    } else if (this._providedSessionId && receivedSessionId !== this._providedSessionId) {\n      // This code path is reached if the session is already locked by another receiver.\n      // TODO: Check why the service would not throw an error or just timeout instead of giving a misleading successful receiver\n      errorMessage = `Failed to create a receiver for the requested session '${this._providedSessionId}'. It may be locked by another receiver.`;\n    }\n\n    if (errorMessage) {\n      const error = translateServiceBusError({\n        description: errorMessage,\n        condition: ErrorNameConditionMapper.SessionCannotBeLockedError,\n      });\n      logger.logError(error, this.logPrefix);\n      logger.verbose(\n        \"%s cleaning up resources held by intermediate link (SessionCannotBeLockedError)\",\n        this.logPrefix,\n      );\n      await link.close({ closeSession: true });\n      link.remove();\n      throw error;\n    }\n\n    return link;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   */\n  private async _init(\n    opts: { abortSignal?: AbortSignalLike; timeoutInMs?: number } = {},\n  ): Promise<void> {\n    try {\n      const sessionOptions = this._createMessageSessionOptions(this.identifier, opts.timeoutInMs);\n      await this.initLink(sessionOptions, opts.abortSignal);\n\n      if (!this.link) {\n        throw new Error(\"INTERNAL ERROR: failed to create receiver but without an error.\");\n      }\n\n      const receivedSessionId = this.link.source?.filter?.[Constants.sessionFilterName];\n\n      if (!this._providedSessionId) this.sessionId = receivedSessionId;\n      this.sessionLockedUntilUtc = convertTicksToDate(\n        this.link.properties[\"com.microsoft:locked-until-utc\"],\n      );\n      logger.verbose(\n        \"%s Session with id '%s' is locked until: '%s'.\",\n        this.logPrefix,\n        this.sessionId,\n        this.sessionLockedUntilUtc.toISOString(),\n      );\n      logger.verbose(\n        \"%s Receiver created with receiver options: %O\",\n        this.logPrefix,\n        sessionOptions,\n      );\n      if (!this._context.messageSessions[this.name]) {\n        this._context.messageSessions[this.name] = this;\n      }\n      this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;\n      this._ensureSessionLockRenewal();\n    } catch (err: any) {\n      const errObj = translateServiceBusError(err);\n      logger.logError(errObj, \"%s An error occured while creating the receiver\", this.logPrefix);\n\n      // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.\n      if ((errObj as MessagingError).code === \"OperationTimeoutError\") {\n        if (this._providedSessionId) {\n          errObj.message = `Failed to create a receiver for the requested session '${this._providedSessionId}' within allocated time and retry attempts.`;\n        } else {\n          errObj.message = \"Failed to create a receiver within allocated time and retry attempts.\";\n        }\n      }\n      if (this._intermediateLink) {\n        logger.verbose(\"%s cleaning up resources held by intermediate link\", this.logPrefix);\n        await this._intermediateLink.close({ closeSession: true });\n        this._intermediateLink.remove();\n      }\n      throw errObj;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   */\n  private _createMessageSessionOptions(clientId: string, timeoutInMs?: number): ReceiverOptions {\n    const rcvrOptions: ReceiverOptions = createReceiverOptions(\n      this.name,\n      this.receiveMode,\n      {\n        address: this.address,\n        filter: { [Constants.sessionFilterName]: this.sessionId },\n      },\n      clientId,\n      {\n        onClose: (context) =>\n          this._onAmqpClose(context).catch(() => {\n            /* */\n          }),\n        onSessionClose: (context) =>\n          this._onSessionClose(context).catch(() => {\n            /* */\n          }),\n        onError: this._onAmqpError,\n        onSessionError: this._onSessionError,\n        onSettled: this._onSettled,\n      },\n      timeoutInMs,\n    );\n\n    return rcvrOptions;\n  }\n\n  private _retryOptions: RetryOptions | undefined;\n  private _lastSBError: Error | ServiceBusError | undefined;\n  private _intermediateLink: Receiver | undefined;\n\n  /**\n   * Constructs a MessageSession instance which lets you receive messages as batches\n   * or via callbacks using subscribe.\n   *\n   * @param _providedSessionId - The sessionId provided by the user. This can be the\n   * name of a session ID to open (empty string is also valid) or it can be undefined,\n   * to indicate we want the next unlocked non-empty session.\n   */\n  constructor(\n    public identifier: string,\n    connectionContext: ConnectionContext,\n    entityPath: string,\n    private _providedSessionId: string | undefined,\n    options: MessageSessionOptions,\n  ) {\n    super(entityPath, entityPath, connectionContext, \"session\", logger, {\n      address: entityPath,\n      audience: `${connectionContext.config.endpoint}${entityPath}`,\n    });\n    this._receiverHelper = new ReceiverHelper(() => ({\n      receiver: this.link,\n      logPrefix: this.logPrefix,\n    }));\n    this._retryOptions = options.retryOptions;\n    this.autoComplete = false;\n    if (isDefined(this._providedSessionId)) this.sessionId = this._providedSessionId;\n    this.receiveMode = options.receiveMode || \"peekLock\";\n    this.skipParsingBodyAsJson = options.skipParsingBodyAsJson;\n    this.skipConvertingDate = options.skipConvertingDate;\n    this.maxAutoRenewDurationInMs =\n      options.maxAutoLockRenewalDurationInMs != null\n        ? options.maxAutoLockRenewalDurationInMs\n        : 300 * 1000;\n    this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;\n    this.autoRenewLock = this.maxAutoRenewDurationInMs > 0 && this.receiveMode === \"peekLock\";\n\n    this._isReceivingMessagesForSubscriber = false;\n    this._batchingReceiverLite = new BatchingReceiverLite(\n      connectionContext,\n      entityPath,\n      async (_abortSignal?: AbortSignalLike): Promise<MinimalReceiver> => {\n        return this.link!;\n      },\n      this.receiveMode,\n      this.skipParsingBodyAsJson,\n      this.skipConvertingDate,\n    );\n\n    // setting all the handlers\n    this._onSettled = (context: EventContext) => {\n      const delivery = context.delivery;\n\n      onMessageSettled(this.logPrefix, delivery, this._deliveryDispositionMap);\n    };\n\n    this._notifyError = async (args: ProcessErrorArgs) => {\n      if (this._onError) {\n        this._onError(args);\n        logger.verbose(\n          \"%s Notified the user's error handler about the error received by the Receiver\",\n          this.logPrefix,\n        );\n      }\n    };\n\n    this._onAmqpError = (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        if (sbError.code === \"SessionLockLostError\") {\n          sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;\n        }\n        this._lastSBError = sbError;\n        logger.logError(sbError, \"%s An error occurred for Receiver\", this.logPrefix);\n        this._notifyError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n          identifier: this.identifier,\n        });\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const connectionId = this._context.connectionId;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError);\n        logger.logError(\n          sbError,\n          \"[%s] An error occurred on the session for Receiver '%s': %O.\",\n          connectionId,\n          this.name,\n          sbError,\n        );\n        this._notifyError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n          identifier: this.identifier,\n        });\n      }\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const connectionId = this._context.connectionId;\n      const receiverError = context.receiver && context.receiver.error;\n      const receiver = this.link || context.receiver!;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        logger.logError(\n          sbError,\n          \"[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. \" +\n            \"The associated error is: %O\",\n          connectionId,\n          this.name,\n          this.sessionId,\n          sbError,\n        );\n        // no need to notify the user's error handler since rhea guarantees that receiver_error\n        // will always be emitted before receiver_close.\n      }\n      if (receiver && !receiver.isItselfClosed()) {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver for sessionId '%s' \" +\n            \"and the sdk did not initiate this. Hence, let's gracefully close the receiver.\",\n          this.logPrefix,\n          this.sessionId,\n        );\n        try {\n          await this.close();\n        } catch (err: any) {\n          logger.logError(\n            err,\n            \"%s An error occurred while closing the receiver for sessionId '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n          );\n        }\n      } else {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver for sessionId '%s' \" +\n            \"because the sdk initiated it. Hence no need to gracefully close the receiver\",\n          this.logPrefix,\n          this.sessionId,\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const receiver = this.link || context.receiver!;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError);\n        logger.logError(\n          sbError,\n          \"%s 'session_close' event occurred for receiver for sessionId '%s'. \" +\n            \"The associated error is\",\n          this.logPrefix,\n          this.sessionId,\n        );\n        // no need to notify the user's error handler since rhea guarantees that session_error\n        // will always be emitted before session_close.\n      }\n\n      if (receiver && !receiver.isSessionItselfClosed()) {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the receiver for sessionId '%s' \" +\n            \"and the sdk did not initiate this. Hence, let's gracefully close the receiver.\",\n          this.logPrefix,\n          this.sessionId,\n        );\n        try {\n          await this.close();\n        } catch (err: any) {\n          logger.logError(\n            err,\n            \"%s An error occurred while closing the receiver for sessionId '%s'\",\n            this.logPrefix,\n            this.sessionId,\n          );\n        }\n      } else {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the receiver for sessionId'%s' \" +\n            \"because the sdk initiated it. Hence no need to gracefully close the receiver\",\n          this.logPrefix,\n          this.sessionId,\n        );\n      }\n    };\n  }\n\n  /**\n   * Closes the underlying AMQP receiver link.\n   */\n  async close(error?: Error | AmqpError): Promise<void> {\n    try {\n      this._isReceivingMessagesForSubscriber = false;\n      if (this._sessionLockRenewalTimer) clearTimeout(this._sessionLockRenewalTimer);\n      logger.verbose(\n        \"%s Cleared the timers for 'no new message received' task and \" +\n          \"'session lock renewal' task.\",\n        this.logPrefix,\n      );\n\n      await super.close();\n\n      this._batchingReceiverLite.terminate(error);\n    } catch (err: any) {\n      logger.logError(\n        err,\n        \"%s An error occurred while closing the message session with id '%s'\",\n        this.logPrefix,\n        this.sessionId,\n      );\n    }\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   */\n  isOpen(): boolean {\n    const result: boolean = this.link! && this.link!.isOpen();\n    logger.verbose(\n      \"%s Receiver for sessionId '%s' is open? -> %s\",\n      this.logPrefix,\n      this.sessionId,\n      result,\n    );\n    return result;\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the SessionReceiver or set the property\n   * `newMessageWaitTimeoutInMs` in the options to provide a timeout.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control whether messages should be automatically completed. You can\n   * also provide a timeout in milliseconds to denote the amount of time to wait for a new message\n   * before closing the receiver.\n   */\n  public subscribe(onMessage: OnMessage, onError: OnError, options: SubscribeOptions): void {\n    this.receiverHelper.resume();\n    this._subscribeImpl(onMessage, onError, options);\n  }\n\n  private _subscribeImpl(onMessage: OnMessage, onError: OnError, options: SubscribeOptions): void {\n    if (!options) options = {};\n\n    if (options.abortSignal?.aborted) {\n      throw new AbortError(StandardAbortMessage);\n    }\n\n    this._isReceivingMessagesForSubscriber = true;\n    if (typeof options.maxConcurrentCalls === \"number\" && options.maxConcurrentCalls > 0) {\n      this.maxConcurrentCalls = options.maxConcurrentCalls;\n    }\n\n    // If explicitly set to false then autoComplete is false else true (default).\n    this.autoComplete =\n      options.autoCompleteMessages === false ? options.autoCompleteMessages : true;\n    this._onMessage = onMessage;\n    this._onError = onError;\n\n    if (this.link && this.link.isOpen()) {\n      const onSessionMessage = async (context: EventContext): Promise<void> => {\n        // If the receiver got closed in PeekLock mode, avoid processing the message as we\n        // cannot settle the message.\n        if (this.receiveMode === \"peekLock\" && (!this.link || !this.link.isOpen())) {\n          logger.verbose(\n            \"%s Not calling the user's message handler for the current message \" +\n              \"as the receiver is closed\",\n            this.logPrefix,\n          );\n          return;\n        }\n\n        const bMessage = new ServiceBusMessageImpl(\n          context.message!,\n          context.delivery!,\n          true,\n          this.receiveMode,\n          this.skipParsingBodyAsJson,\n          this.skipConvertingDate,\n        );\n\n        try {\n          await this._onMessage(bMessage);\n\n          if (\n            this.autoComplete &&\n            this.receiveMode === \"peekLock\" &&\n            !bMessage.delivery.remote_settled\n          ) {\n            try {\n              logger.verbose(\n                \"%s Auto completing the message with id '%s' on the receiver.\",\n                this.logPrefix,\n                bMessage.messageId,\n              );\n              await completeMessage(bMessage, this._context, this.entityPath, this._retryOptions);\n            } catch (completeError: any) {\n              const translatedError = translateServiceBusError(completeError);\n              logger.logError(\n                translatedError,\n                \"%s An error occurred while completing the message with id '%s' on the \" +\n                  \"receiver\",\n                this.logPrefix,\n                bMessage.messageId,\n              );\n              await this._notifyError({\n                error: translatedError,\n                errorSource: \"complete\",\n                entityPath: this.entityPath,\n                fullyQualifiedNamespace: this._context.config.host,\n                identifier: this.identifier,\n              });\n            }\n          }\n        } catch (err: any) {\n          logger.logError(\n            err,\n            \"%s An error occurred while running user's message handler for the message \" +\n              \"with id '%s' on the receiver\",\n            this.logPrefix,\n            bMessage.messageId,\n          );\n          await this._onError!({\n            error: err,\n            errorSource: \"processMessageCallback\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n            identifier: this.identifier,\n          });\n\n          const error = translateServiceBusError(err);\n          // Nothing much to do if user's message handler throws. Let us try abandoning the message.\n          if (\n            !bMessage.delivery.remote_settled &&\n            this.receiveMode === \"peekLock\" &&\n            this.isOpen() // only try to abandon the messages if the connection is still open\n          ) {\n            try {\n              logger.logError(\n                error,\n                \"%s Abandoning the message with id '%s' on the receiver since an error occured\",\n                this.logPrefix,\n                bMessage.messageId,\n              );\n              await abandonMessage(\n                bMessage,\n                this._context,\n                this.entityPath,\n                undefined,\n                this._retryOptions,\n              );\n            } catch (abandonError: any) {\n              const translatedError = translateServiceBusError(abandonError);\n              logger.logError(\n                translatedError,\n                \"%s An error occurred while abandoning the message with id '%s' on the \" +\n                  \"receiver\",\n                this.logPrefix,\n                bMessage.messageId,\n                translatedError,\n              );\n              await this._notifyError({\n                error: translatedError,\n                errorSource: \"abandon\",\n                entityPath: this.entityPath,\n                fullyQualifiedNamespace: this._context.config.host,\n                identifier: this.identifier,\n              });\n            }\n          }\n          return;\n        } finally {\n          try {\n            this.receiverHelper.addCredit(1);\n          } catch (err: any) {\n            // this isn't something we expect in normal operation - we'd only get here\n            // because of a bug in our code.\n            this.processCreditError(err);\n          }\n        }\n      };\n      // setting the \"message\" event listener.\n      this.link.on(ReceiverEvents.message, onSessionMessage);\n\n      try {\n        this.receiverHelper.addCredit(this.maxConcurrentCalls);\n      } catch (err: any) {\n        // this isn't something we expect in normal operation - we'd only get here\n        // because of a bug in our code.\n        this.processCreditError(err);\n      }\n    } else {\n      this._isReceivingMessagesForSubscriber = false;\n      const msg =\n        `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +\n        `has either not been created or is not open.`;\n      logger.verbose(\"[%s] %s\", this._context.connectionId, msg);\n      this._notifyError({\n        error: new Error(msg),\n        // This is _probably_ the right error code since we require that\n        // the message session is created before we even give back the receiver. So it not\n        // being open at this point is either:\n        //\n        // 1. we didn't acquire the lock\n        // 2. the connection was broken (we don't reconnect)\n        //\n        // If any of these becomes untrue you'll probably want to re-evaluate this classification.\n        errorSource: \"receive\",\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host,\n        identifier: this.identifier,\n      });\n    }\n  }\n\n  private async processCreditError(err: any): Promise<void> {\n    if (err.name === \"AbortError\") {\n      // if we fail to add credits because the user has asked us to stop\n      // then this isn't an error - it's normal.\n      return;\n    }\n\n    logger.logError(err, \"Cannot request messages on the receiver\");\n\n    const error = new ServiceBusError(\"Cannot request messages on the receiver\", \"SessionLockLost\");\n    error.retryable = false;\n\n    // from the user's perspective this is a fatal link error and they should retry\n    // opening the link.\n    await this._onError!({\n      error,\n      errorSource: \"processMessageCallback\",\n      entityPath: this.entityPath,\n      fullyQualifiedNamespace: this._context.config.host,\n      identifier: this.identifier,\n    });\n  }\n\n  /**\n   * Returns a batch of messages based on given count and timeout over an AMQP receiver link\n   * from a Queue/Subscription.\n   *\n   * @param maxMessageCount - The maximum number of messages to receive from Queue/Subscription.\n   * @param maxWaitTimeInMs - The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * @returns A promise that resolves with an array of Message objects.\n   */\n  async receiveMessages(\n    maxMessageCount: number,\n    maxWaitTimeInMs: number,\n    maxTimeAfterFirstMessageInMs: number,\n    options: OperationOptionsBase,\n  ): Promise<ServiceBusMessageImpl[]> {\n    try {\n      return await this._batchingReceiverLite.receiveMessages({\n        maxMessageCount,\n        maxWaitTimeInMs,\n        maxTimeAfterFirstMessageInMs,\n        ...options,\n      });\n    } catch (error: any) {\n      logger.logError(error, `${this.logPrefix} Rejecting receiveMessages() with error`);\n      throw error;\n    }\n  }\n\n  /**\n   * To be called when connection is disconnected to gracefully close ongoing receive request.\n   * @param connectionError - The connection error if any.\n   */\n  async onDetached(connectionError: AmqpError | Error): Promise<void> {\n    logger.error(\n      translateServiceBusError(connectionError),\n      `${this.logPrefix} onDetached: closing link (session receiver will not reconnect)`,\n    );\n    try {\n      // Notifying so that the streaming receiver knows about the error\n      await this._notifyError({\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host,\n        error: translateServiceBusError(connectionError),\n        errorSource: \"receive\",\n        identifier: this.identifier,\n      });\n    } catch (error: any) {\n      logger.error(\n        translateServiceBusError(error),\n        `${\n          this.logPrefix\n        } onDetached: unexpected error seen when tried calling \"_notifyError\" with ${translateServiceBusError(\n          connectionError,\n        )}`,\n      );\n    }\n    await this.close(connectionError);\n  }\n\n  /**\n   * Settles the message with the specified disposition.\n   * @param message - The ServiceBus Message that needs to be settled.\n   * @param operation - The disposition type.\n   * @param options - Optional parameters that can be provided while disposing the message.\n   */\n  async settleMessage(\n    message: ServiceBusMessageImpl,\n    operation: DispositionType,\n    options: DispositionStatusOptions,\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {\n        return reject(new Error(`operation: '${operation}' is not a valid operation.`));\n      }\n      const delivery = message.delivery;\n      const timer = setTimeout(() => {\n        this._deliveryDispositionMap.delete(delivery.id);\n        logger.verbose(\n          \"[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. \" +\n            \"Hence rejecting the promise with timeout error\",\n          this._context.connectionId,\n          delivery.id,\n          Constants.defaultOperationTimeoutInMs,\n        );\n\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description:\n            \"Operation to settle the message has timed out. The disposition of the \" +\n            \"message may or may not be successful\",\n        };\n        return reject(translateServiceBusError(e));\n      }, Constants.defaultOperationTimeoutInMs);\n      this._deliveryDispositionMap.set(delivery.id, {\n        resolve: resolve,\n        reject: reject,\n        timer: timer,\n      });\n      if (operation === DispositionType.complete) {\n        delivery.accept();\n      } else if (operation === DispositionType.abandon) {\n        const params: any = {\n          undeliverable_here: false,\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.defer) {\n        const params: any = {\n          undeliverable_here: true,\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.deadletter) {\n        const error: AmqpError = {\n          condition: Constants.deadLetterName,\n          info: {\n            ...options.propertiesToModify,\n            DeadLetterReason: options.deadLetterReason,\n            DeadLetterErrorDescription: options.deadLetterDescription,\n          },\n        };\n        delivery.reject(error);\n      }\n    });\n  }\n\n  /**\n   * Creates a new instance of the MessageSession based on the provided parameters.\n   * @param identifier - name to identify the message session\n   * @param context - The client entity context\n   * @param options - Options that can be provided while creating the MessageSession.\n   */\n  static async create(\n    identifier: string,\n    context: ConnectionContext,\n    entityPath: string,\n    sessionId: string | undefined,\n    options: MessageSessionOptions,\n  ): Promise<MessageSession> {\n    throwErrorIfConnectionClosed(context);\n    const messageSession = new MessageSession(identifier, context, entityPath, sessionId, options);\n    let timeoutInMs: number | undefined;\n    // Only passing client timeout in link properties for accepting next available\n    // session as this is the only long-polling scenario.\n    if (sessionId === undefined) {\n      timeoutInMs = options.retryOptions?.timeoutInMs ?? Constants.defaultOperationTimeoutInMs;\n      // The number of milliseconds to use as the basis for calculating a random jitter amount\n      // opening receiver links. This is intended to ensure that multiple\n      // session operations don't timeout at the same exact moment.\n      const openReceiveLinkBaseJitterInMs = 100;\n      // The amount of time to subtract from the client timeout when setting the server timeout when attempting to\n      // accept the next available session. This will decrease the likelihood that the client times out before receiving a\n      // response from the server.\n      const openReceiveLinkBufferInMs = 20;\n      // The amount minimum threshold for the server timeout for which we will subtract the \"openReceiveLinkBufferInMs\".\n      // If the server timeout is less than this, we will not subtract the additional buffer.\n      const openReceiveLinkBufferThresholdInMs = 1000;\n      // Subtract a random amount up to 100ms from the operation timeout as the jitter when attempting to open next available session link.\n      // This prevents excessive resource usage when using high amounts of concurrency and accepting the next available session.\n      // Take the min of 1% of the total timeout and the base jitter amount so that we don't end up subtracting more than 1% of the total timeout.\n      const jitterBaseInMs = Math.min(timeoutInMs * 0.01, openReceiveLinkBaseJitterInMs);\n      // We set the operation timeout on the properties not only to include the jitter, but also because the server will otherwise\n      // restrict the maximum timeout to 1 minute and 5 seconds, regardless of the client timeout. We only do this for accepting next available\n      // session as this is the only long-polling scenario.\n      timeoutInMs = Math.floor(timeoutInMs - jitterBaseInMs * Math.random());\n      // Subtract an additional constant buffer to reduce the likelihood that the client times out before the service which leads to unnecessary\n      // network traffic. If the timeout is too short, we won't do this.\n      if (timeoutInMs >= openReceiveLinkBufferThresholdInMs) {\n        timeoutInMs -= openReceiveLinkBufferInMs;\n      }\n    }\n\n    await messageSession._init({\n      abortSignal: options?.abortSignal,\n      timeoutInMs,\n    });\n    return messageSession;\n  }\n\n  protected removeLinkFromContext(): void {\n    delete this._context.messageSessions[this.name];\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  isNamedKeyCredential,\n  isSASCredential,\n  isTokenCredential,\n  NamedKeyCredential,\n  SASCredential,\n  TokenCredential,\n} from \"@azure/core-auth\";\n\n/**\n * Typeguard that checks if the input is a credential type the clients accept.\n * @param thing - Any object.\n * @internal\n */\nexport function isCredential(\n  thing: unknown,\n): thing is TokenCredential | NamedKeyCredential | SASCredential {\n  return isTokenCredential(thing) || isNamedKeyCredential(thing) || isSASCredential(thing);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionConfig } from \"@azure/core-amqp\";\nimport { TokenCredential, NamedKeyCredential, SASCredential } from \"@azure/core-auth\";\nimport {\n  ServiceBusClientOptions,\n  createConnectionContextForConnectionString,\n  createConnectionContextForCredential,\n} from \"./constructorHelpers\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport {\n  ServiceBusReceiverOptions,\n  ServiceBusSessionReceiverOptions,\n  ReceiveMode,\n  ServiceBusSenderOptions,\n} from \"./models\";\nimport { ServiceBusReceiver, ServiceBusReceiverImpl } from \"./receivers/receiver\";\nimport {\n  ServiceBusSessionReceiver,\n  ServiceBusSessionReceiverImpl,\n} from \"./receivers/sessionReceiver\";\nimport { ServiceBusRuleManager, ServiceBusRuleManagerImpl } from \"./serviceBusRuleManager\";\nimport { ServiceBusSender, ServiceBusSenderImpl } from \"./sender\";\nimport { entityPathMisMatchError } from \"./util/errors\";\nimport { MessageSession } from \"./session/messageSession\";\nimport { isDefined } from \"@azure/core-util\";\nimport { isCredential } from \"./util/typeGuards\";\nimport { ensureValidIdentifier } from \"./util/utils\";\n\n/**\n * A client that can create Sender instances for sending messages to queues and\n * topics as well as Receiver instances to receive messages from queues and subscriptions.\n */\nexport class ServiceBusClient {\n  private _connectionContext: ConnectionContext;\n  private _clientOptions: ServiceBusClientOptions;\n  /**\n   * The fully qualified namespace of the Service Bus instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  public fullyQualifiedNamespace: string;\n  /**\n   * The name used to identify this ServiceBusClient.\n   * If not specified or empty, a random unique one will be generated.\n   */\n  public identifier: string;\n  /**\n   * Creates an instance of the ServiceBusClient class which can be used to create senders and receivers to\n   * the Azure Service Bus namespace provided in the connection string. No connection is made to the service\n   * until the senders/receivers created with the client are used to send/receive messages.\n   * @param connectionString - A connection string for Azure Service Bus namespace.\n   * NOTE: this connection string can contain an EntityPath, which is ignored.\n   * @param options - Options for the service bus client.\n   */\n  constructor(connectionString: string, options?: ServiceBusClientOptions);\n  /**\n   * Creates an instance of the ServiceBusClient class which can be used to create senders and receivers to\n   * the Azure Service Bus namespace provided. No connection is made to the service until\n   * the senders/receivers created with the client are used to send/receive messages.\n   * @param fullyQualifiedNamespace - The full namespace of your Service Bus instance which is\n   * likely to be similar to <yournamespace>.servicebus.windows.net.\n   * @param credential - A credential object used by the client to get the token to authenticate the connection\n   * with the Azure Service Bus. See &commat;azure/identity for creating the credentials.\n   * If you're using an own implementation of the `TokenCredential` interface against AAD, then set the \"scopes\" for service-bus\n   * to be `[\"https://servicebus.azure.net//user_impersonation\"]` to get the appropriate token.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    options?: ServiceBusClientOptions,\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    credentialOrOptions2?:\n      | TokenCredential\n      | NamedKeyCredential\n      | SASCredential\n      | ServiceBusClientOptions,\n    options3?: ServiceBusClientOptions,\n  ) {\n    if (isCredential(credentialOrOptions2)) {\n      const fullyQualifiedNamespace: string = fullyQualifiedNamespaceOrConnectionString1;\n      const credential = credentialOrOptions2;\n      this._clientOptions = options3 || {};\n\n      this._connectionContext = createConnectionContextForCredential(\n        credential,\n        fullyQualifiedNamespace,\n        this._clientOptions,\n      );\n    } else {\n      const connectionString: string = fullyQualifiedNamespaceOrConnectionString1;\n      this._clientOptions = credentialOrOptions2 || {};\n\n      this._connectionContext = createConnectionContextForConnectionString(\n        connectionString,\n        this._clientOptions,\n      );\n    }\n    this.fullyQualifiedNamespace = this._connectionContext.config.host;\n    this.identifier = ensureValidIdentifier(\n      this.fullyQualifiedNamespace,\n      this._clientOptions.identifier,\n    );\n    this._clientOptions.retryOptions = this._clientOptions.retryOptions || {};\n\n    const timeoutInMs = this._clientOptions.retryOptions.timeoutInMs;\n    if (\n      isDefined(timeoutInMs) &&\n      (typeof timeoutInMs !== \"number\" || !isFinite(timeoutInMs) || timeoutInMs <= 0)\n    ) {\n      throw new Error(`${timeoutInMs} is an invalid value for retryOptions.timeoutInMs`);\n    }\n  }\n\n  /**\n   * Creates a receiver for an Azure Service Bus queue. No connection is made\n   * to the service until one of the methods on the receiver is called.\n   *\n   * To target sub queues like the dead letter queue or the transfer dead letter queue, provide the\n   * `subQueue` in the options. To learn more about dead letter queues, see\n   * https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * Messages that are not settled within the lock duration will be redelivered as many times as\n   * the max delivery count set on the queue, after which they get sent to a separate dead letter\n   * queue.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param queueName - The name of the queue to receive from.\n   * @param options - Options to pass the receiveMode, defaulted to peekLock.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n  createReceiver(queueName: string, options?: ServiceBusReceiverOptions): ServiceBusReceiver;\n  /**\n   * Creates a receiver for an Azure Service Bus subscription. No connection is made\n   * to the service until one of the methods on the receiver is called.\n   *\n   * To target sub queues like the dead letter queue or the transfer dead letter queue, provide the\n   * `subQueue` in the options. To learn more about dead letter queues, see\n   * https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * Messages that are not settled within the lock duration will be redelivered as many times as\n   * the max delivery count set on the subscription, after which they get sent to a separate dead letter\n   * queue.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param topicName - Name of the topic for the subscription we want to receive from.\n   * @param subscriptionName - Name of the subscription (under the `topic`) that we want to receive from.\n   * @param options - Options to pass the receiveMode, defaulted to peekLock.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  createReceiver(\n    topicName: string,\n    subscriptionName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusReceiverOptions,\n  ): ServiceBusReceiver;\n  createReceiver(\n    queueOrTopicName1: string,\n    optionsOrSubscriptionName2?: ServiceBusReceiverOptions | string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options3?: ServiceBusReceiverOptions,\n  ): ServiceBusReceiver {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName1);\n\n    // NOTE: we don't currently have any options for this kind of receiver but\n    // when we do make sure you pass them in and extract them.\n    const { entityPath, receiveMode, options } = extractReceiverArguments(\n      queueOrTopicName1,\n      optionsOrSubscriptionName2,\n      options3,\n    );\n\n    let entityPathWithSubQueue = entityPath;\n    if (options?.subQueueType) {\n      switch (options?.subQueueType) {\n        case \"deadLetter\":\n          entityPathWithSubQueue += \"/$DeadLetterQueue\";\n          break;\n        case \"transferDeadLetter\":\n          entityPathWithSubQueue += \"/$Transfer/$DeadLetterQueue\";\n          break;\n        default:\n          throw new Error(\n            `Invalid subQueueType '${options?.subQueueType}' provided. Valid values are 'deadLetter' and 'transferDeadLetter'`,\n          );\n      }\n    }\n\n    const maxLockAutoRenewDurationInMs =\n      options?.maxAutoLockRenewalDurationInMs != null\n        ? options.maxAutoLockRenewalDurationInMs\n        : 5 * 60 * 1000;\n\n    return new ServiceBusReceiverImpl(\n      this._connectionContext,\n      entityPathWithSubQueue,\n      receiveMode,\n      maxLockAutoRenewDurationInMs,\n      options?.skipParsingBodyAsJson ?? false,\n      options?.skipConvertingDate ?? false,\n      this._clientOptions.retryOptions,\n      options?.identifier,\n    );\n  }\n\n  /**\n   * Creates an instance of {@link ServiceBusRuleManager} that is used to manage\n   * the rules for a subscription.\n   *\n   * @param topicName - the topic to create {@link ServiceBusRuleManager}\n   * @param subscriptionName - the subscription specific to the specified topic to create a {@link ServiceBusRuleManager} for.\n   * @returns a {@link ServiceBusRuleManager} scoped to the specified subscription and topic.\n   */\n  createRuleManager(topicName: string, subscriptionName: string): ServiceBusRuleManager {\n    validateEntityPath(this._connectionContext.config, topicName);\n\n    const { entityPath } = extractReceiverArguments(topicName, subscriptionName);\n    return new ServiceBusRuleManagerImpl(\n      this._connectionContext,\n      entityPath,\n      this._clientOptions.retryOptions,\n    );\n  }\n\n  /**\n   * Creates a receiver for a session enabled Azure Service Bus queue.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param queueName - The name of the queue to receive from.\n   * @param sessionId - The id of the session from which messages need to be received\n   * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptSession(\n    queueName: string,\n    sessionId: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver>;\n  /**\n   * Creates a receiver for a session enabled Azure Service Bus subscription.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param topicName - Name of the topic for the subscription we want to receive from.\n   * @param subscriptionName - Name of the subscription (under the `topic`) that we want to receive from.\n   * @param sessionId - The id of the session from which messages need to be received\n   * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptSession(\n    topicName: string,\n    subscriptionName: string,\n    sessionId: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver>;\n  async acceptSession(\n    queueOrTopicName1: string,\n    optionsOrSubscriptionNameOrSessionId2?: ServiceBusSessionReceiverOptions | string,\n    optionsOrSessionId3?: ServiceBusSessionReceiverOptions | string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options4?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver> {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName1);\n\n    let sessionId: string;\n    let entityPath: string;\n    let receiveMode: \"peekLock\" | \"receiveAndDelete\";\n    let options: ServiceBusSessionReceiverOptions | undefined;\n\n    if (\n      typeof queueOrTopicName1 === \"string\" &&\n      typeof optionsOrSubscriptionNameOrSessionId2 === \"string\" &&\n      typeof optionsOrSessionId3 === \"string\"\n    ) {\n      // subscription constructor\n      sessionId = optionsOrSessionId3;\n\n      ({ entityPath, receiveMode, options } = extractReceiverArguments(\n        queueOrTopicName1,\n        optionsOrSubscriptionNameOrSessionId2,\n        // skip the session ID parameter (3)\n        options4,\n      ));\n    } else if (\n      typeof queueOrTopicName1 === \"string\" &&\n      typeof optionsOrSubscriptionNameOrSessionId2 === \"string\" &&\n      typeof optionsOrSessionId3 !== \"string\"\n    ) {\n      // queue constructor (but only because we know we're not a subscription constructor)\n      sessionId = optionsOrSubscriptionNameOrSessionId2;\n\n      ({ entityPath, receiveMode, options } = extractReceiverArguments(\n        queueOrTopicName1,\n        // skip the session ID parameter (2)\n        optionsOrSessionId3,\n        undefined,\n      ));\n    } else {\n      throw new Error(\"Unhandled set of parameters\");\n    }\n\n    const messageSession = await MessageSession.create(\n      ensureValidIdentifier(entityPath, options?.identifier),\n      this._connectionContext,\n      entityPath,\n      sessionId,\n      {\n        maxAutoLockRenewalDurationInMs: options?.maxAutoLockRenewalDurationInMs,\n        receiveMode,\n        abortSignal: options?.abortSignal,\n        retryOptions: this._clientOptions.retryOptions,\n        skipParsingBodyAsJson: options?.skipParsingBodyAsJson ?? false,\n        skipConvertingDate: options?.skipConvertingDate ?? false,\n      },\n    );\n\n    const sessionReceiver = new ServiceBusSessionReceiverImpl(\n      messageSession,\n      this._connectionContext,\n      entityPath,\n      receiveMode,\n      options?.skipParsingBodyAsJson ?? false,\n      options?.skipConvertingDate ?? false,\n      this._clientOptions.retryOptions,\n    );\n\n    return sessionReceiver;\n  }\n\n  /**\n   * Creates a receiver for the next available session in a session-enabled Azure Service Bus queue.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param queueName - The name of the queue to receive from.\n   * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptNextSession(\n    queueName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver>;\n  /**\n   * Creates a receiver for the next available session in a session-enabled Azure Service Bus subscription.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://docs.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param topicName - Name of the topic for the subscription we want to receive from.\n   * @param subscriptionName - Name of the subscription (under the `topic`) that we want to receive from.\n   * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptNextSession(\n    topicName: string,\n    subscriptionName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver>;\n  async acceptNextSession(\n    queueOrTopicName1: string,\n    optionsOrSubscriptionName2?: ServiceBusSessionReceiverOptions | string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options3?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver> {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName1);\n\n    const { entityPath, receiveMode, options } = extractReceiverArguments(\n      queueOrTopicName1,\n      optionsOrSubscriptionName2,\n      options3,\n    );\n\n    const messageSession = await MessageSession.create(\n      ensureValidIdentifier(entityPath, options?.identifier),\n      this._connectionContext,\n      entityPath,\n      undefined,\n      {\n        maxAutoLockRenewalDurationInMs: options?.maxAutoLockRenewalDurationInMs,\n        receiveMode,\n        abortSignal: options?.abortSignal,\n        retryOptions: this._clientOptions.retryOptions,\n        skipParsingBodyAsJson: options?.skipParsingBodyAsJson ?? false,\n        skipConvertingDate: options?.skipConvertingDate ?? false,\n      },\n    );\n\n    const sessionReceiver = new ServiceBusSessionReceiverImpl(\n      messageSession,\n      this._connectionContext,\n      entityPath,\n      receiveMode,\n      options?.skipParsingBodyAsJson ?? false,\n      options?.skipConvertingDate ?? false,\n      this._clientOptions.retryOptions,\n    );\n\n    return sessionReceiver;\n  }\n\n  /**\n   * Creates a Sender which can be used to send messages, schedule messages to be\n   * sent at a later time and cancel such scheduled messages. No connection is made\n   * to the service until one of the methods on the sender is called.\n   * @param queueOrTopicName - The name of a queue or topic to send messages to.\n   */\n  createSender(queueOrTopicName: string, options: ServiceBusSenderOptions = {}): ServiceBusSender {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName);\n\n    return new ServiceBusSenderImpl(\n      this._connectionContext,\n      queueOrTopicName,\n      this._clientOptions.retryOptions,\n      options.identifier,\n    );\n  }\n\n  /**\n   * Closes the underlying AMQP connection.\n   * NOTE: this will also disconnect any Receiver or Sender instances created from this\n   * instance.\n   */\n  close(): Promise<void> {\n    return ConnectionContext.close(this._connectionContext);\n  }\n}\n\n/**\n * Helper to validate and extract the common arguments from both the create*Receiver() overloads that\n * have this pattern:\n *\n * queue, options\n * topic, subscription, options\n *\n * @internal\n */\nexport function extractReceiverArguments<OptionsT extends { receiveMode?: ReceiveMode }>(\n  queueOrTopicName1: string,\n  optionsOrSubscriptionName2: string | OptionsT | undefined,\n  definitelyOptions3?: OptionsT,\n): {\n  entityPath: string;\n  receiveMode: ReceiveMode;\n  options?: Omit<OptionsT, \"receiveMode\">;\n} {\n  let entityPath: string;\n  let options: OptionsT | undefined;\n  if (typeof optionsOrSubscriptionName2 === \"string\") {\n    const topic = queueOrTopicName1;\n    const subscription = optionsOrSubscriptionName2;\n    entityPath = `${topic}/Subscriptions/${subscription}`;\n    options = definitelyOptions3;\n  } else {\n    entityPath = queueOrTopicName1;\n    options = optionsOrSubscriptionName2;\n  }\n  let receiveMode: ReceiveMode;\n  if (!options || !isDefined(options.receiveMode) || options.receiveMode === \"peekLock\") {\n    receiveMode = \"peekLock\";\n  } else if (options.receiveMode === \"receiveAndDelete\") {\n    receiveMode = \"receiveAndDelete\";\n  } else {\n    throw new TypeError(\n      `Invalid receiveMode '${options?.receiveMode}' provided. Valid values are 'peekLock' and 'receiveAndDelete'`,\n    );\n  }\n  delete options?.receiveMode;\n  return {\n    entityPath,\n    receiveMode,\n    options,\n  };\n}\n\n/**\n * Validates that the EntityPath in the connection string (if any) matches with the\n * queue or topic name passed to the methods that create senders and receivers.\n *\n * @internal\n */\nfunction validateEntityPath(connectionConfig: ConnectionConfig, queueOrTopicName: string): void {\n  if (connectionConfig.entityPath && connectionConfig.entityPath !== queueOrTopicName) {\n    throw new Error(entityPathMisMatchError);\n  }\n}\n"],"names":["isObjectWithProperties","createClientLogger","URL","HttpHeadersV1","MessagingError","translate","isMessagingError","generate_uuid","Buffer","isDefined","Constants.XML_METADATA_MARKER","AbortError","StandardAbortMessage","OperationTimeoutError","Constants.packageJsonInfo","delay","ErrorNameConditionMapper","stringifyXML","logger","parseXML","RestError","Constants.ATOM_METADATA_MARKER","Constants.HttpResponseCodes","Constants.QUEUE_NAME","Constants.FORWARD_TO","Constants.USER_METADATA","Constants.LOCK_DURATION","Constants.MAX_SIZE_IN_MEGABYTES","Constants.MAX_DELIVERY_COUNT","Constants.ENABLE_PARTITIONING","Constants.REQUIRES_SESSION","Constants.ENABLE_BATCHED_OPERATIONS","Constants.DEFAULT_MESSAGE_TIME_TO_LIVE","Constants.AUTO_DELETE_ON_IDLE","Constants.REQUIRES_DUPLICATE_DETECTION","Constants.DUPLICATE_DETECTION_HISTORY_TIME_WINDOW","Constants.DEAD_LETTERING_ON_MESSAGE_EXPIRATION","Constants.FORWARD_DEADLETTERED_MESSAGES_TO","Constants.AUTHORIZATION_RULES","Constants.STATUS","Constants.ENABLE_EXPRESS","Constants.ENTITY_AVAILABILITY_STATUS","Constants.MAX_MESSAGE_SIZE_IN_KILOBYTES","Constants.COUNT_DETAILS","Constants.SIZE_IN_BYTES","Constants.MESSAGE_COUNT","Constants.CREATED_AT","Constants.UPDATED_AT","Constants.ACCESSED_AT","Constants.XML_VALUE_MARKER","Constants.SUBSCRIPTION_NAME","Constants.TOPIC_NAME","Constants.DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS","Constants.SUPPORT_ORDERING","Constants.SUBSCRIPTION_COUNT","createSasTokenProvider","createHttpHeaders","createTracingClient","ServiceClient","isTokenCredential","bearerTokenAuthenticationPolicy","AMQPConstants","isNamedKeyCredential","parseConnectionString","createPipelineFromOptions","Constants.CURRENT_API_VERSION","createPipelineRequest","Constants.API_VERSION_QUERY_KEY","message","AmqpAnnotatedMessage","Constants","uuid_to_string","defaultCancellableLock","isSasTokenProvider","TokenType","AbortController","RequestResponseLink","ReceiverEvents","types","RheaMessageUtil","ConditionErrorNameMapper","string_to_uuid","os","ConnectionContextBase","ConnectionEvents","ConnectionConfig","isSASCredential","retry","RetryOperationType","RetryMode","SessionEvents","getPagedAsyncIterator","RheaMessagePropertiesList"],"mappings":"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"}