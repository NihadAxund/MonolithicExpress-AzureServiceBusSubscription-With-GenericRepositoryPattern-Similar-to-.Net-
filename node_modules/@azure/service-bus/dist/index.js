'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAmqp = require('@azure/core-amqp');
var coreAuth = require('@azure/core-auth');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var logger$1 = require('@azure/logger');
var coreUtil = require('@azure/core-util');
var coreXml = require('@azure/core-xml');
var buffer = require('buffer');
var url = require('url');
var Long = require('long');
var rheaPromise = require('rhea-promise');
var isBuffer = require('is-buffer');
var abortController = require('@azure/abort-controller');
var crypto = require('crypto');
var coreTracing = require('@azure/core-tracing');
var os = require('os');
var corePaging = require('@azure/core-paging');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var os__namespace = /*#__PURE__*/_interopNamespaceDefault(os);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The `@azure/logger` configuration for this package.
 * This will output logs using the `azure:service-bus` namespace prefix.
 * @internal
 */
const logger = createServiceBusLogger("service-bus");
/**
 * Logging for ServiceBusReceivers of any type (session, non-session)
 * @internal
 */
const receiverLogger = createServiceBusLogger("service-bus:receiver");
/**
 * Logging for ServiceBusSenders
 * @internal
 */
const senderLogger = createServiceBusLogger("service-bus:sender");
/**
 * Logging for ServiceBusRuleManagers
 * @internal
 */
const ruleManagerLogger = createServiceBusLogger("service-bus:rulemanager");
/**
 * Logging for connection management
 * @internal
 */
const connectionLogger = createServiceBusLogger("service-bus:connection");
/**
 * Logging for the ServiceBusAdministrationClient
 * @internal
 */
const administrationLogger = createServiceBusLogger("service-bus:administration");
/**
 * Logging related to message encoding/decoding.
 * @internal
 */
const messageLogger = createServiceBusLogger("service-bus:messages");
/**
 * Logging related to message encoding/decoding.
 * @internal
 */
const managementClientLogger = createServiceBusLogger("service-bus:management");
/**
 * Logs the error's stack trace to "verbose" if a stack trace is available.
 * @param error - Error containing a stack trace.
 * @internal
 */
function logErrorStackTrace(_logger, error) {
    if (coreUtil.isObjectWithProperties(error, ["stack"]) && error.stack) {
        _logger.verbose(error.stack);
    }
}
/**
 * Creates an AzureLogger with any additional methods for standardized logging (for example, with errors)
 * @internal
 */
function createServiceBusLogger(namespace) {
    const _logger = logger$1.createClientLogger(namespace);
    _logger["logError"] = (err, ...args) => {
        let l;
        // abort errors are user initiated so we don't have to treat them as warnings, like we
        // would with other errors.
        if (isError(err) && err.name === "AbortError") {
            l = _logger.info;
        }
        else {
            l = _logger.warning;
        }
        // tack on the error object so it also gets logged.
        args.push(":", err);
        // let the normal formatting work and include the error at the end.
        l(...args);
        // optionally log the stack trace if it's available but this always goes to verbose
        if (err && err.stack) {
            _logger.verbose(err.stack);
        }
    };
    return _logger;
}
/**
 * @internal
 */
function isError(err) {
    return err != null && err.name != null;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
const packageJsonInfo = {
    name: "@azure/service-bus",
    version: "7.9.5",
};
/**
 * The amount of time in milliseconds that a receiver
 * will wait while draining credits before returning.
 * @internal
 */
const receiveDrainTimeoutInMs = 200;
/**
 * @internal
 */
const max32BitNumber = Math.pow(2, 31) - 1;
/**
 * Queue name identifier
 * @internal
 */
const QUEUE_NAME = "QueueName";
/**
 * Topic name identifier
 * @internal
 */
const TOPIC_NAME = "TopicName";
/**
 * Subscription name identifier
 * @internal
 */
const SUBSCRIPTION_NAME = "SubscriptionName";
/**
 * Accessed at field
 * @internal
 */
const ACCESSED_AT = "AccessedAt";
/**
 * Updated at field
 * @internal
 */
const UPDATED_AT = "UpdatedAt";
/**
 * Created at field
 * @internal
 */
const CREATED_AT = "CreatedAt";
/**
 * Authorization rules on the entity
 * @internal
 */
const AUTHORIZATION_RULES = "AuthorizationRules";
/**
 * Entity Availability Status field
 * @internal
 */
const ENTITY_AVAILABILITY_STATUS = "EntityAvailabilityStatus";
/**
 * Enable express option
 * @internal
 */
const ENABLE_EXPRESS = "EnableExpress";
/**
 * The entity's size in bytes.
 *
 * @internal
 */
const SIZE_IN_BYTES = "SizeInBytes";
/**
 * The entity's message count.
 *
 * @internal
 */
const MESSAGE_COUNT = "MessageCount";
/**
 * The topic's subscription count.
 *
 * @internal
 */
const SUBSCRIPTION_COUNT = "SubscriptionCount";
/**
 * The topic / subscription's count details.
 *
 * @internal
 */
const COUNT_DETAILS = "CountDetails";
/**
 * Max idle time before entity is deleted.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 */
const AUTO_DELETE_ON_IDLE = "AutoDeleteOnIdle";
/**
 * The status information on response
 *
 * @internal
 */
const STATUS = "Status";
/**
 * The URL of Service Bus entity to forward messages to.
 *
 * @internal
 */
const FORWARD_TO = "ForwardTo";
/**
 * The user meta data information
 *
 * @internal
 */
const USER_METADATA = "UserMetadata";
/**
 * The maximum size in megabytes.
 *
 * @internal
 */
const MAX_SIZE_IN_MEGABYTES = "MaxSizeInMegabytes";
/**
 * The maximum size in kilobytes.
 *
 * @internal
 */
const MAX_MESSAGE_SIZE_IN_KILOBYTES = "MaxMessageSizeInKilobytes";
/**
 * The default message time to live.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 */
const DEFAULT_MESSAGE_TIME_TO_LIVE = "DefaultMessageTimeToLive";
/**
 * The lock duration.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 */
const LOCK_DURATION = "LockDuration";
/**
 * The indication if session is required or not.
 *
 * @internal
 */
const REQUIRES_SESSION = "RequiresSession";
/**
 * The indication if duplicate detection is required or not.
 *
 * @internal
 */
const REQUIRES_DUPLICATE_DETECTION = "RequiresDuplicateDetection";
/**
 * The indication if dead lettering on message expiration. If it is enabled and a message expires,
 * the Service Bus moves the message from the queue into the entity dead-letter sub-queue.
 * If disabled, message will be permanently deleted from the main entity.
 * Settable only at entity creation time.
 *
 * @internal
 */
const DEAD_LETTERING_ON_MESSAGE_EXPIRATION = "DeadLetteringOnMessageExpiration";
/**
 * The indication if dead lettering on filter evaluation exceptions.
 *
 * @internal
 */
const DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS = "DeadLetteringOnFilterEvaluationExceptions";
/**
 * The history time window for duplicate detection.
 * This is specified in ISO-8601 duration format such as "PT1M" for 1 minute, "PT5S" for 5 seconds.
 * @internal
 */
const DUPLICATE_DETECTION_HISTORY_TIME_WINDOW = "DuplicateDetectionHistoryTimeWindow";
/**
 * The maximum delivery count of messages after which if it is still not settled, gets moved to the dead-letter sub-queue.
 *
 * @internal
 */
const MAX_DELIVERY_COUNT = "MaxDeliveryCount";
/**
 * Indicates if the queue has enabled batch operations.
 *
 * @internal
 */
const ENABLE_BATCHED_OPERATIONS = "EnableBatchedOperations";
/**
 * Indicates whether the topic can be ordered
 *
 * @internal
 */
const SUPPORT_ORDERING = "SupportOrdering";
/**
 * Indicates whether the topic/queue should be split across multiple partitions
 *
 * @internal
 */
const ENABLE_PARTITIONING = "EnablePartitioning";
/**
 * The URL of Service Bus entity to forward deadlettered messages to.
 *
 * @internal
 */
const FORWARD_DEADLETTERED_MESSAGES_TO = "ForwardDeadLetteredMessagesTo";
/**
 * Query string parameter to set Service Bus API version
 *
 * @internal
 */
const API_VERSION_QUERY_KEY = "api-version";
/**
 * Current API version being sent to service bus
 *
 * @internal
 */
const CURRENT_API_VERSION = "2021-05";
/**
 * Marker for atom metadata.
 *
 * @internal
 */
const XML_METADATA_MARKER = "$";
/**
 * Marker for atom value.
 *
 * @internal
 */
const XML_VALUE_MARKER = "_";
/**
 * Constant representing the property where the atom default elements are stored.
 *
 * @internal
 */
const ATOM_METADATA_MARKER = "_";
/**
 * Known HTTP status codes as documented and referenced in ATOM based management API feature
 * https://docs.microsoft.com/dotnet/api/system.net.httpstatuscode?view=netframework-4.8
 * @internal
 */
const HttpResponseCodes = {
    100: "Continue",
    101: "SwitchingProtocols",
    200: "Ok",
    201: "Created",
    202: "Accepted",
    203: "NonAuthoritativeInformation",
    204: "NoContent",
    205: "ResetContent",
    206: "PartialContent",
    300: "MultipleChoices",
    301: "Moved",
    302: "Redirect",
    303: "RedirectMethod",
    304: "NotModified",
    305: "UseProxy",
    306: "Unused",
    400: "BadRequest",
    401: "Unauthorized",
    402: "PaymentRequired",
    403: "Forbidden",
    404: "NotFound",
    405: "MethodNotAllowed",
    406: "NotAcceptable",
    407: "ProxyAuthenticationRequired",
    409: "Conflict",
    410: "Gone",
    411: "LengthRequired",
    412: "PreconditionFailed",
    413: "RequestEntityTooLarge",
    414: "RequestUriTooLong",
    415: "UnsupportedMediaType",
    416: "RequestRangeNotSatisfiable",
    417: "ExpectationFailed",
    426: "UpgradeRequired",
    500: "InternalServerError",
    501: "NotImplemented",
    502: "BadGateway",
    503: "ServiceUnavailable",
    504: "GatewayTimeout",
    505: "HttpVersionNotSupported",
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 */
/**
 * @internal
 */
const parseURL = (rawUrl) => {
    return new url.URL(rawUrl);
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A collection of HttpHeaders that can be sent with a HTTP request.
 */
function getHeaderKey(headerName) {
    return headerName.toLowerCase();
}
/**
 * A collection of HTTP header key/value pairs.
 */
class HttpHeaders {
    constructor(rawHeaders) {
        this._headersMap = {};
        if (rawHeaders) {
            for (const headerName in rawHeaders) {
                this.set(headerName, rawHeaders[headerName]);
            }
        }
    }
    /**
     * Set a header in this collection with the provided name and value. The name is
     * case-insensitive.
     * @param headerName - The name of the header to set. This value is case-insensitive.
     * @param headerValue - The value of the header to set.
     */
    set(headerName, headerValue) {
        this._headersMap[getHeaderKey(headerName)] = {
            name: headerName,
            value: headerValue.toString(),
        };
    }
    /**
     * Get the header value for the provided header name, or undefined if no header exists in this
     * collection with the provided name.
     * @param headerName - The name of the header.
     */
    get(headerName) {
        const header = this._headersMap[getHeaderKey(headerName)];
        return !header ? undefined : header.value;
    }
    /**
     * Get whether or not this header collection contains a header entry for the provided header name.
     */
    contains(headerName) {
        return !!this._headersMap[getHeaderKey(headerName)];
    }
    /**
     * Remove the header with the provided headerName. Return whether or not the header existed and
     * was removed.
     * @param headerName - The name of the header to remove.
     */
    remove(headerName) {
        const result = this.contains(headerName);
        delete this._headersMap[getHeaderKey(headerName)];
        return result;
    }
    /**
     * Get the headers that are contained this collection as an object.
     */
    rawHeaders() {
        return this.toJson({ preserveCase: true });
    }
    /**
     * Get the headers that are contained in this collection as an array.
     */
    headersArray() {
        const headers = [];
        for (const headerKey in this._headersMap) {
            headers.push(this._headersMap[headerKey]);
        }
        return headers;
    }
    /**
     * Get the header names that are contained in this collection.
     */
    headerNames() {
        const headerNames = [];
        const headers = this.headersArray();
        for (let i = 0; i < headers.length; ++i) {
            headerNames.push(headers[i].name);
        }
        return headerNames;
    }
    /**
     * Get the header values that are contained in this collection.
     */
    headerValues() {
        const headerValues = [];
        const headers = this.headersArray();
        for (let i = 0; i < headers.length; ++i) {
            headerValues.push(headers[i].value);
        }
        return headerValues;
    }
    /**
     * Get the JSON object representation of this HTTP header collection.
     */
    toJson(options = {}) {
        const result = {};
        if (options.preserveCase) {
            for (const headerKey in this._headersMap) {
                const header = this._headersMap[headerKey];
                result[header.name] = header.value;
            }
        }
        else {
            for (const headerKey in this._headersMap) {
                const header = this._headersMap[headerKey];
                result[getHeaderKey(header.name)] = header.value;
            }
        }
        return result;
    }
    /**
     * Get the string representation of this HTTP header collection.
     */
    toString() {
        return JSON.stringify(this.toJson({ preserveCase: true }));
    }
    /**
     * Create a deep clone/copy of this HttpHeaders collection.
     */
    clone() {
        const resultPreservingCasing = {};
        for (const headerKey in this._headersMap) {
            const header = this._headersMap[headerKey];
            resultPreservingCasing[header.name] = header.value;
        }
        return new HttpHeaders(resultPreservingCasing);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function toHttpHeaderLike(headers) {
    return new HttpHeaders(headers.toJSON({ preserveCase: true }));
}
function toWebResourceLike(request) {
    return {
        url: request.url,
        method: request.method,
        headers: toHttpHeaderLike(request.headers),
        withCredentials: request.withCredentials,
        timeout: request.timeout,
        requestId: request.headers.get("x-ms-client-request-id") || "",
    };
}
/**
 * Helper to transform PipelineResponse to slimmed-down HttpResponse used in Service Bus.
 */
function toHttpResponse(response) {
    return {
        request: toWebResourceLike(response.request),
        status: response.status,
        headers: toHttpHeaderLike(response.headers),
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Translation between the MessagingErrorCodes into a ServiceBusCode
 *
 * @internal
 */
const wellKnownMessageCodesToServiceBusCodes = new Map([
    ["MessagingEntityNotFoundError", "MessagingEntityNotFound"],
    ["MessageLockLostError", "MessageLockLost"],
    ["MessageNotFoundError", "MessageNotFound"],
    ["MessageTooLargeError", "MessageSizeExceeded"],
    ["MessagingEntityAlreadyExistsError", "MessagingEntityAlreadyExists"],
    ["MessagingEntityDisabledError", "MessagingEntityDisabled"],
    ["QuotaExceededError", "QuotaExceeded"],
    ["ServerBusyError", "ServiceBusy"],
    ["OperationTimeoutError", "ServiceTimeout"],
    ["ServiceUnavailableError", "ServiceTimeout"],
    ["ServiceCommunicationError", "ServiceCommunicationProblem"],
    ["SessionCannotBeLockedError", "SessionCannotBeLocked"],
    ["SessionLockLostError", "SessionLockLost"],
    ["UnauthorizedError", "UnauthorizedAccess"],
]);
/**
 * Errors that occur within Service Bus.
 */
class ServiceBusError extends coreAmqp.MessagingError {
    constructor(messageOrError, code) {
        const message = typeof messageOrError === "string" ? messageOrError : messageOrError.message;
        super(message);
        if (typeof messageOrError === "string") {
            this.code = code ?? "GeneralError";
        }
        else {
            for (const prop in messageOrError) {
                this[prop] = messageOrError[prop];
            }
            this.code = ServiceBusError.normalizeMessagingCode(messageOrError.code);
            // For GeneralErrors, prefix the error message with the MessagingError code to provide
            // more context to the user.
            if (this.code === "GeneralError" && messageOrError.code) {
                this.message = `${messageOrError.code}: ${this.message}`;
            }
        }
        this.name = "ServiceBusError";
    }
    static normalizeMessagingCode(oldCode) {
        if (oldCode == null || !wellKnownMessageCodesToServiceBusCodes.has(oldCode)) {
            return "GeneralError";
        }
        return wellKnownMessageCodesToServiceBusCodes.get(oldCode);
    }
}
/**
 * Translates an error into either an Error or a ServiceBusError which provides a `reason` code that
 * can be used by clients to programmatically react to errors.
 *
 * If you are calling `@azure/core-amqp/translate` you should swap to using this function instead since it provides
 * Service Bus specific handling of the error (falling back to default translate behavior otherwise).
 *
 * @internal
 */
function translateServiceBusError(err) {
    if (isServiceBusError(err)) {
        return err;
    }
    const translatedError = coreAmqp.translate(err);
    if (coreAmqp.isMessagingError(translatedError)) {
        return new ServiceBusError(translatedError);
    }
    return translatedError;
}
/**
 * Determines if an error is of type `ServiceBusError`
 *
 * @param err - An error to check to see if it's of type ServiceBusError
 */
function isServiceBusError(err) {
    return coreUtil.isObjectWithProperties(err, ["name"]) && err.name === "ServiceBusError";
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Provides a uniue name by appending a string guid to the given string in the following format:
 * `{name}-{uuid}`.
 * @param name - The nme of the entity
 */
function getUniqueName(name) {
    return `${name}-${rheaPromise.generate_uuid()}`;
}
/**
 * @internal
 * Returns the passed identifier if it is not undefined or empty;
 * otherwise generate and returns a unique one in the following format;
 *   `{prefix}-{uuid}`.
 * @param prefix - The prefix used to generate identifier
 * @param identifier - an identifier name
 */
function ensureValidIdentifier(prefix, identifier) {
    return identifier ? identifier : getUniqueName(prefix);
}
/**
 * @internal
 * If you try to turn a Guid into a Buffer in .NET, the bytes of the first three groups get
 * flipped within the group, but the last two groups don't get flipped, so we end up with a
 * different byte order. This is the order of bytes needed to make Service Bus recognize the token.
 *
 * @param lockToken - The lock token whose bytes need to be reorded.
 * @returns Buffer representing reordered bytes.
 */
function reorderLockToken(lockTokenBytes) {
    if (!lockTokenBytes || !buffer.Buffer.isBuffer(lockTokenBytes)) {
        return lockTokenBytes;
    }
    return buffer.Buffer.from([
        lockTokenBytes[3],
        lockTokenBytes[2],
        lockTokenBytes[1],
        lockTokenBytes[0],
        lockTokenBytes[5],
        lockTokenBytes[4],
        lockTokenBytes[7],
        lockTokenBytes[6],
        lockTokenBytes[8],
        lockTokenBytes[9],
        lockTokenBytes[10],
        lockTokenBytes[11],
        lockTokenBytes[12],
        lockTokenBytes[13],
        lockTokenBytes[14],
        lockTokenBytes[15],
    ]);
}
/**
 * @internal
 * Provides the time in milliseconds after which the lock renewal should occur.
 * @param lockedUntilUtc - The time until which the message is locked.
 */
function calculateRenewAfterDuration(lockedUntilUtc) {
    const now = Date.now();
    const lockedUntil = lockedUntilUtc.getTime();
    const remainingTime = lockedUntil - now;
    receiverLogger.verbose("Locked until utc  : %d", lockedUntil);
    receiverLogger.verbose("Current time is   : %d", now);
    receiverLogger.verbose("Remaining time is : %d", remainingTime);
    if (remainingTime < 1000) {
        return 0;
    }
    const buffer = Math.min(remainingTime / 2, 10000); // 10 seconds
    const renewAfter = remainingTime - buffer;
    receiverLogger.verbose("Renew after       : %d", renewAfter);
    return renewAfter;
}
/**
 * @internal
 * Converts the .net ticks to a JS Date object.
 *
 * - The epoch for the DateTimeOffset type is `0000-01-01`, while the epoch for JS Dates is
 * `1970-01-01`.
 * - The DateTimeOffset ticks value for the date `1970-01-01` is `621355968000000000`.
 *   - Hence, to convert it to the JS epoch; we `subtract` the delta from the given value.
 * - Ticks in DateTimeOffset is `1/10000000` second, while ticks in JS Date is `1/1000` second.
 *   - Thus, we `divide` the value by `10000` to convert it to JS Date ticks.
 *
 * @param buf - Input as a Buffer
 * @returns The JS Date object.
 */
function convertTicksToDate(buf) {
    const epochMicroDiff = 621355968000000000;
    const longValue = Long.fromBytesBE(buf);
    const timeInMS = longValue.sub(epochMicroDiff).div(10000).toNumber();
    const result = new Date(timeInMS);
    logger.verbose("The converted date is: %s", result.toString());
    return result;
}
/**
 * @internal
 * Converts any given input to a Buffer.
 * @param input - The input that needs to be converted to a Buffer.
 */
function toBuffer(input) {
    let result;
    messageLogger.verbose("[utils.toBuffer] The given message body that needs to be converted to buffer is: ", input);
    if (isBuffer(input)) {
        result = input;
    }
    else {
        // string, undefined, null, boolean, array, object, number should end up here
        // coercing undefined to null as that will ensure that null value will be given to the
        // customer on receive.
        if (input === undefined)
            input = null;
        try {
            const inputStr = JSON.stringify(input);
            result = buffer.Buffer.from(inputStr, "utf8");
        }
        catch (err) {
            const msg = `An error occurred while executing JSON.stringify() on the given input ` +
                input +
                `${err instanceof Error ? err.stack : JSON.stringify(err)}`;
            messageLogger.warning("[utils.toBuffer] " + msg);
            throw err instanceof Error ? err : new Error(msg);
        }
    }
    messageLogger.verbose("[utils.toBuffer] The converted buffer is: %O.", result);
    return result;
}
/**
 * @internal
 * Helper utility to retrieve `string` value from given string,
 * or throws error if undefined.
 */
function getString(value, nameOfProperty) {
    const result = getStringOrUndefined(value);
    if (result === undefined) {
        throw new Error(`"${nameOfProperty}" received from service expected to be a string value and not undefined.`);
    }
    return result;
}
/**
 * @internal
 * Helper utility to retrieve `string` value from given input,
 * or undefined if not passed in.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function getStringOrUndefined(value) {
    if (!coreUtil.isDefined(value)) {
        return undefined;
    }
    return value.toString();
}
/**
 * @internal
 * Helper utility to retrieve `integer` value from given string,
 * or throws error if undefined.
 */
function getInteger(value, nameOfProperty) {
    const result = getIntegerOrUndefined(value);
    if (result === undefined) {
        throw new Error(`"${nameOfProperty}" received from service expected to be a number value and not undefined.`);
    }
    return result;
}
/**
 * @internal
 * Helper utility to retrieve `integer` value from given string,
 * or undefined if not passed in.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function getIntegerOrUndefined(value) {
    if (!coreUtil.isDefined(value)) {
        return undefined;
    }
    const result = parseInt(value.toString());
    return isNaN(result) ? undefined : result;
}
/**
 * @internal
 * Helper utility to convert ISO-8601 time into Date type.
 */
function getDate(value, nameOfProperty) {
    return new Date(getString(value, nameOfProperty));
}
/**
 * @internal
 * Helper utility to retrieve `boolean` value from given string,
 * or throws error if undefined.
 */
function getBoolean(value, nameOfProperty) {
    const result = getBooleanOrUndefined(value);
    if (result === undefined) {
        throw new Error(`"${nameOfProperty}" received from service expected to be a boolean value and not undefined.`);
    }
    return result;
}
/**
 * @internal
 * Helper utility to retrieve `boolean` value from given string,
 * or undefined if not passed in.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function getBooleanOrUndefined(value) {
    if (!coreUtil.isDefined(value)) {
        return undefined;
    }
    return value.toString().trim().toLowerCase() === "true";
}
/**
 * @internal
 * Helps in differentiating JSON like objects from other kinds of objects.
 */
const EMPTY_JSON_OBJECT_CONSTRUCTOR = {}.constructor;
/**
 * @internal
 * Returns `true` if given input is a JSON like object.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function isJSONLikeObject(value) {
    // `value.constructor === {}.constructor` differentiates among the "object"s,
    //    would filter the JSON objects and won't match any array or other kinds of objects
    // -------------------------------------------------------------------------------
    // Few examples       | typeof obj ==="object" |  obj.constructor==={}.constructor
    // -------------------------------------------------------------------------------
    // {abc:1}            | true                   | true
    // ["a","b"]          | true                   | false
    // [{"a":1},{"b":2}]  | true                   | false
    // new Date()         | true                   | false
    // 123                | false                  | false
    // -------------------------------------------------------------------------------
    return typeof value === "object" && value.constructor === EMPTY_JSON_OBJECT_CONSTRUCTOR;
}
/**
 * @internal
 * Helper utility to retrieve message count details from given input,
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function getMessageCountDetails(value) {
    const xmlnsPrefix = getXMLNSPrefix(value);
    if (!coreUtil.isDefined(value)) {
        value = {};
    }
    return {
        activeMessageCount: parseInt(value[`${xmlnsPrefix}:ActiveMessageCount`]) || 0,
        deadLetterMessageCount: parseInt(value[`${xmlnsPrefix}:DeadLetterMessageCount`]) || 0,
        scheduledMessageCount: parseInt(value[`${xmlnsPrefix}:ScheduledMessageCount`]) || 0,
        transferMessageCount: parseInt(value[`${xmlnsPrefix}:TransferMessageCount`]) || 0,
        transferDeadLetterMessageCount: parseInt(value[`${xmlnsPrefix}:TransferDeadLetterMessageCount`]) || 0,
    };
}
/**
 * @internal
 * Gets the xmlns prefix from the root of the objects that are part of the parsed response body.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function getXMLNSPrefix(value) {
    if (!value[XML_METADATA_MARKER]) {
        throw new Error(`Error occurred while parsing the response body - cannot find the XML_METADATA_MARKER "$" on the object ${JSON.stringify(value)}`);
    }
    const keys = Object.keys(value[XML_METADATA_MARKER]);
    if (keys.length !== 1) {
        throw new Error(`Error occurred while parsing the response body - unexpected number of "xmlns:\${prefix}" keys at ${JSON.stringify(value[XML_METADATA_MARKER])}`);
    }
    if (!keys[0].startsWith("xmlns:")) {
        throw new Error(`Error occurred while parsing the response body - unexpected key at ${JSON.stringify(value[XML_METADATA_MARKER])}`);
    }
    // Pick the substring that's after "xmlns:"
    const xmlnsPrefix = keys[0].substring(6);
    if (!xmlnsPrefix) {
        throw new Error(`Error occurred while parsing the response body - unexpected xmlns prefix at ${JSON.stringify(value[XML_METADATA_MARKER])}`);
    }
    return xmlnsPrefix;
}
/**
 * @internal
 * Helper utility to retrieve array of `AuthorizationRule` from given input,
 * or undefined if not passed in.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function getAuthorizationRulesOrUndefined(value) {
    const authorizationRules = [];
    // Ignore special case as Service Bus treats "" as a valid value for authorization rules
    if (typeof value === "string" && value.trim() === "") {
        return undefined;
    }
    if (!coreUtil.isDefined(value)) {
        return undefined;
    }
    const rawAuthorizationRules = value.AuthorizationRule;
    if (Array.isArray(rawAuthorizationRules)) {
        for (let i = 0; i < rawAuthorizationRules.length; i++) {
            authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules[i]));
        }
    }
    else {
        authorizationRules.push(buildAuthorizationRule(rawAuthorizationRules));
    }
    return authorizationRules;
}
/**
 * @internal
 * Helper utility to build an instance of parsed authorization rule as `AuthorizationRule` from given input.
 */
function buildAuthorizationRule(value) {
    let accessRights;
    if (coreUtil.isDefined(value["Rights"])) {
        accessRights = value["Rights"]["AccessRights"];
    }
    const authorizationRule = {
        claimType: value["ClaimType"],
        accessRights,
        keyName: value["KeyName"],
        primaryKey: value["PrimaryKey"],
        secondaryKey: value["SecondaryKey"],
    };
    if (authorizationRule.accessRights && !Array.isArray(authorizationRule.accessRights)) {
        authorizationRule.accessRights = [authorizationRule.accessRights];
    }
    return authorizationRule;
}
/**
 * @internal
 * Helper utility to extract output containing array of `RawAuthorizationRule` instances from given input,
 * or undefined if not passed in.
 */
function getRawAuthorizationRules(authorizationRules) {
    if (!coreUtil.isDefined(authorizationRules)) {
        return undefined;
    }
    if (!Array.isArray(authorizationRules)) {
        throw new TypeError(`authorizationRules must be an array of AuthorizationRule objects or undefined, but received ${JSON.stringify(authorizationRules, undefined, 2)}`);
    }
    const rawAuthorizationRules = [];
    for (let i = 0; i < authorizationRules.length; i++) {
        rawAuthorizationRules.push(buildRawAuthorizationRule(authorizationRules[i]));
    }
    return { AuthorizationRule: rawAuthorizationRules };
}
/**
 * @internal
 * Helper utility to build an instance of raw authorization rule as RawAuthorizationRule from given `AuthorizationRule` input.
 * @param authorizationRule - parsed Authorization Rule instance
 */
function buildRawAuthorizationRule(authorizationRule) {
    if (!isJSONLikeObject(authorizationRule) || authorizationRule === null) {
        throw new TypeError(`Expected authorizationRule input to be a JS object value, but received ${JSON.stringify(authorizationRule, undefined, 2)}`);
    }
    const rawAuthorizationRule = {
        ClaimType: authorizationRule.claimType,
        // ClaimValue is not settable by the users, but service expects the value for PUT requests
        ClaimValue: "None",
        Rights: {
            AccessRights: authorizationRule.accessRights,
        },
        KeyName: authorizationRule.keyName,
        PrimaryKey: authorizationRule.primaryKey,
        SecondaryKey: authorizationRule.secondaryKey,
    };
    rawAuthorizationRule[XML_METADATA_MARKER] = {
        "p5:type": "SharedAccessAuthorizationRule",
        "xmlns:p5": "http://www.w3.org/2001/XMLSchema-instance",
    };
    return rawAuthorizationRule;
}
/**
 * @internal
 * Helper utility to check if given string is an absolute URL
 */
function isAbsoluteUrl(url) {
    const _url = url.toLowerCase();
    return _url.startsWith("sb://") || _url.startsWith("http://") || _url.startsWith("https://");
}
/**
 * An executor for a function that returns a Promise that obeys both a timeout and an
 * optional AbortSignal.
 * @param timeoutMs - The number of milliseconds to allow before throwing an OperationTimeoutError.
 * @param timeoutMessage - The message to place in the .description field for the thrown exception for Timeout.
 * @param abortSignal - The abortSignal associated with containing operation.
 * @param abortErrorMsg - The abort error message associated with containing operation.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 *
 * @internal
 */
async function waitForTimeoutOrAbortOrResolve(args) {
    if (args.abortSignal && args.abortSignal.aborted) {
        throw new abortController.AbortError(coreAmqp.StandardAbortMessage);
    }
    let timer = undefined;
    let clearAbortSignal = undefined;
    const clearAbortSignalAndTimer = () => {
        (args.timeoutFunctions?.clearTimeoutFn ?? clearTimeout)(timer);
        if (clearAbortSignal) {
            clearAbortSignal();
        }
    };
    // eslint-disable-next-line promise/param-names
    const abortOrTimeoutPromise = new Promise((_resolve, reject) => {
        clearAbortSignal = checkAndRegisterWithAbortSignal(reject, args.abortSignal);
        timer = (args.timeoutFunctions?.setTimeoutFn ?? setTimeout)(() => {
            reject(new rheaPromise.OperationTimeoutError(args.timeoutMessage));
        }, args.timeoutMs);
    });
    try {
        return await Promise.race([abortOrTimeoutPromise, args.actionFn()]);
    }
    finally {
        clearAbortSignalAndTimer();
    }
}
/**
 * Registers listener to the abort event on the abortSignal to call your abortFn and
 * returns a function that will clear the same listener.
 *
 * If abort signal is already aborted, then throws an AbortError and returns a function that does nothing
 *
 * @returns A function that removes any of our attached event listeners on the abort signal or an empty function if
 * the abortSignal was not defined.
 *
 * @internal
 */
function checkAndRegisterWithAbortSignal(onAbortFn, abortSignal) {
    if (abortSignal == null) {
        return () => {
            /** Nothing to do here, no abort signal */
        };
    }
    if (abortSignal.aborted) {
        throw new abortController.AbortError(coreAmqp.StandardAbortMessage);
    }
    const onAbort = () => {
        abortSignal.removeEventListener("abort", onAbort);
        onAbortFn(new abortController.AbortError(coreAmqp.StandardAbortMessage));
    };
    abortSignal.addEventListener("abort", onAbort);
    return () => abortSignal.removeEventListener("abort", onAbort);
}
/**
 * @internal
 * The user agent prefix string for the ServiceBus client.
 * See guideline at https://azure.github.io/azure-sdk/general_azurecore.html#telemetry-policy
 */
const libInfo = `azsdk-js-azureservicebus/${packageJsonInfo.version}`;
/**
 * @internal
 * Returns the formatted prefix by removing the spaces, by appending the libInfo.
 */
function formatUserAgentPrefix(prefix) {
    let userAgentPrefix = `${(prefix || "").replace(" ", "")}`;
    userAgentPrefix = userAgentPrefix.length > 0 ? userAgentPrefix + " " : "";
    return `${userAgentPrefix}${libInfo}`;
}
/**
 * @internal
 * Helper method which returns `HttpResponse` from an object of shape `PipelineResponse`.
 * TODO: remove this and use toHttpResponse() directly
 */
const getHttpResponseOnly = (pipelineResponse) => toHttpResponse(pipelineResponse);
/**
 * @internal
 * Waits for one second if a sender is not sendable then check again. Throws
 * SenderBusyError if it is still not sendable.
 * Only waits when operation timeout is greater than one second.
 * @returns the actual waiting time.
 */
async function waitForSendable(sendLogger, logPrefix, name, timeout, sender, outgoingAvaiable) {
    let waitTimeForSendable = 1000;
    if (!sender?.sendable() && timeout > waitTimeForSendable) {
        sendLogger.verbose("%s Sender '%s', waiting for 1 second for sender to become sendable", logPrefix, name);
        await coreAmqp.delay(waitTimeForSendable);
        sendLogger.verbose("%s Sender '%s' after waiting for a second, credit: %d available: %d", logPrefix, name, sender?.credit, outgoingAvaiable);
    }
    else {
        waitTimeForSendable = 0;
    }
    if (!sender?.sendable()) {
        // let us retry to send the message after some time.
        const msg = `[${logPrefix}] Sender "${name}", ` + `cannot send the message right now. Please try later.`;
        sendLogger.warning(msg);
        const amqpError = {
            condition: coreAmqp.ErrorNameConditionMapper.SenderBusyError,
            description: msg,
        };
        throw translateServiceBusError(amqpError);
    }
    return waitTimeForSendable;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
   applies options to the pipeline request.
  */
function applyRequestOptions(request, options) {
    if (options.headers) {
        const headers = options.headers;
        for (const headerName of Object.keys(headers)) {
            request.headers.set(headerName, headers[headerName]);
        }
    }
    request.onDownloadProgress = options.onDownloadProgress;
    request.onUploadProgress = options.onUploadProgress;
    request.abortSignal = options.abortSignal;
    request.timeout = options.timeout;
    if (options.tracingOptions) {
        request.tracingOptions = options.tracingOptions;
    }
}
/**
 * @internal
 * Utility to execute Atom XML operations as HTTP requests
 */
async function executeAtomXmlOperation(serviceBusAtomManagementClient, request, serializer, operationOptions, requestObject) {
    if (requestObject) {
        request.body = coreXml.stringifyXML(serializer.serialize(requestObject), { rootName: "entry" });
        if (request.method === "PUT") {
            request.headers.set("content-length", buffer.Buffer.byteLength(request.body));
        }
    }
    administrationLogger.verbose(`Executing ATOM based HTTP request: ${request.body}`);
    const reqPrepareOptions = {
        headers: operationOptions.requestOptions?.customHeaders,
        onUploadProgress: operationOptions.requestOptions?.onUploadProgress,
        onDownloadProgress: operationOptions.requestOptions?.onDownloadProgress,
        abortSignal: operationOptions.abortSignal,
        tracingOptions: operationOptions.tracingOptions,
        disableJsonStringifyOnBody: true,
        timeout: operationOptions.requestOptions?.timeout || 0,
    };
    applyRequestOptions(request, reqPrepareOptions);
    const response = await serviceBusAtomManagementClient.sendRequest(request);
    administrationLogger.verbose(`Received ATOM based HTTP response: ${response.bodyAsText}`);
    try {
        if (response.bodyAsText) {
            response.parsedBody = await coreXml.parseXML(response.bodyAsText, {
                includeRoot: true,
            });
        }
    }
    catch (err) {
        const error = new coreRestPipeline.RestError(`Error occurred while parsing the response body - expected the service to return valid xml content.`, {
            code: coreRestPipeline.RestError.PARSE_ERROR,
            statusCode: response.status,
            request: response.request,
            response,
        });
        administrationLogger.logError(err, "Error parsing response body from Service");
        throw error;
    }
    return serializer.deserialize(response);
}
/**
 * @internal
 * The key-value pairs having undefined/null as the values would lead to the empty tags in the serialized XML request.
 * Empty tags in the request body is problematic because of the following reasons.
 * - ATOM based management operations throw a "Bad Request" error if empty tags are included in the XML request body at top level.
 * - At the inner levels, Service assigns the empty strings as values to the empty tags instead of throwing an error.
 *
 * This method recursively removes the key-value pairs with undefined/null as the values from the request object that is to be serialized.
 *
 */
function sanitizeSerializableObject(resource) {
    Object.keys(resource).forEach(function (property) {
        if (!coreUtil.isDefined(resource[property])) {
            delete resource[property];
        }
        else if (isJSONLikeObject(resource[property])) {
            sanitizeSerializableObject(resource[property]);
        }
    });
}
/**
 * @internal
 * Serializes input information to construct the Atom XML request
 * @param resourceName - Name of the resource to be serialized like `QueueDescription`
 * @param resource - The entity details
 * @param allowedProperties - The set of properties that are allowed by the service for the
 * associated operation(s);
 */
function serializeToAtomXmlRequest(resourceName, resource) {
    const content = {};
    content[resourceName] = Object.assign({}, resource);
    sanitizeSerializableObject(content[resourceName]);
    content[resourceName][XML_METADATA_MARKER] = {
        xmlns: "http://schemas.microsoft.com/netservices/2010/10/servicebus/connect",
        "xmlns:i": "http://www.w3.org/2001/XMLSchema-instance",
    };
    content[XML_METADATA_MARKER] = { type: "application/xml" };
    const requestDetails = {
        updated: new Date().toISOString(),
        content: content,
    };
    requestDetails[XML_METADATA_MARKER] = {
        xmlns: "http://www.w3.org/2005/Atom",
    };
    return requestDetails;
}
/**
 * @internal
 * Transforms response to contain the parsed data.
 * @param nameProperties - The set of 'name' properties to be constructed on the
 * resultant object e.g., QueueName, TopicName, etc.
 */
async function deserializeAtomXmlResponse(nameProperties, response) {
    // If received data is a non-valid HTTP response, the body is expected to contain error information
    if (response.status < 200 || response.status >= 300) {
        throw buildError(response);
    }
    parseAtomResult(response, nameProperties);
    return response;
}
/**
 * @internal
 * Utility to deserialize the given JSON content in response body based on
 * if it's a single `entry` or `feed` and updates the `response.parsedBody` to hold the evaluated output.
 * @param response - Response containing the JSON value in `response.parsedBody`
 * @param nameProperties - The set of 'name' properties to be constructed on the
 * resultant object e.g., QueueName, TopicName, etc.
 * */
function parseAtomResult(response, nameProperties) {
    const atomResponseInJson = response.parsedBody;
    let result;
    if (!atomResponseInJson) {
        response.parsedBody = undefined;
        return;
    }
    if (atomResponseInJson.feed) {
        result = parseFeedResult(atomResponseInJson.feed);
    }
    else if (atomResponseInJson.entry) {
        result = parseEntryResult(atomResponseInJson.entry);
    }
    if (result) {
        if (Array.isArray(result)) {
            result.forEach((entry) => {
                setName(entry, nameProperties);
            });
        }
        else {
            setName(result, nameProperties);
        }
        response.parsedBody = result;
        return;
    }
    administrationLogger.warning("Failure in parsing response body from service. Expected response to be in Atom XML format and have either feed or entry components, but received - %0", atomResponseInJson);
    throw new coreRestPipeline.RestError("Error occurred while parsing the response body - expected the service to return atom xml content with either feed or entry elements.", {
        code: coreRestPipeline.RestError.PARSE_ERROR,
        statusCode: response.status,
        request: response.request,
        response,
    });
}
/**
 * @internal
 * Utility to help parse given `entry` result
 */
function parseEntryResult(entry) {
    let result;
    if (typeof entry !== "object" ||
        entry == null ||
        typeof entry.content !== "object" ||
        entry.content == null) {
        return undefined;
    }
    const contentElementNames = Object.keys(entry.content).filter(function (key) {
        return key !== XML_METADATA_MARKER;
    });
    if (contentElementNames && contentElementNames[0]) {
        const contentRootElementName = contentElementNames[0];
        delete entry.content[contentRootElementName][XML_METADATA_MARKER];
        result = entry.content[contentRootElementName];
        if (result) {
            if (entry[XML_METADATA_MARKER]) {
                result[ATOM_METADATA_MARKER] = entry[XML_METADATA_MARKER];
            }
            else {
                result[ATOM_METADATA_MARKER] = {};
            }
            result[ATOM_METADATA_MARKER]["ContentRootElement"] = contentRootElementName;
            Object.keys(entry).forEach((property) => {
                if (property !== "content" && property !== XML_METADATA_MARKER) {
                    result[ATOM_METADATA_MARKER][property] = entry[property];
                }
            });
            return result;
        }
    }
    return undefined;
}
/**
 * @internal
 * Utility to help parse link info from the given `feed` result
 */
function parseLinkInfo(feedLink, relationship) {
    if (!feedLink || !Array.isArray(feedLink)) {
        return undefined;
    }
    for (const linkInfo of feedLink) {
        if (linkInfo[XML_METADATA_MARKER].rel === relationship) {
            return linkInfo[XML_METADATA_MARKER].href;
        }
    }
    return undefined;
}
/**
 * @internal
 * Utility to help parse given `feed` result
 */
function parseFeedResult(feed) {
    const result = [];
    if (typeof feed === "object" && feed != null && feed.entry) {
        if (Array.isArray(feed.entry)) {
            feed.entry.forEach((entry) => {
                const parsedEntryResult = parseEntryResult(entry);
                if (parsedEntryResult) {
                    result.push(parsedEntryResult);
                }
            });
        }
        else {
            const parsedEntryResult = parseEntryResult(feed.entry);
            if (parsedEntryResult) {
                result.push(parsedEntryResult);
            }
        }
        result.nextLink = parseLinkInfo(feed.link, "next");
    }
    return result;
}
/**
 * @internal
 */
function isKnownResponseCode(statusCode) {
    return !!HttpResponseCodes[statusCode];
}
/**
 * @internal
 * Extracts the applicable entity name(s) from the URL based on the known structure
 * and instantiates the corresponding name properties to the deserialized response
 *
 * The pattern matching checks to extract entity names are based on following
 * constraints dictated by the service
 * - '/' is allowed in Queue and Topic names
 * - '/' is not allowed in Namespace, Subscription and Rule names
 * - Valid pathname URL structures used in the ATOM based management API are
 *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>/Rules/<rule-name>`
 *     - `<namespace-component>/<topic-name>/Subscriptions/<subscription-name>`
 *     - `<namespace-component>/<any-entity-name>`
 *
 */
function setName(entry, nameProperties) {
    if (entry[ATOM_METADATA_MARKER]) {
        let rawUrl = entry[ATOM_METADATA_MARKER].id;
        // The parsedUrl gets constructed differently for browser vs Node.
        // It is specifically behaves different for some of the Atom based management API where
        // the received URL in "id" element is of type "sb:// ... " and not a standard HTTP one
        // Hence, normalizing the URL for parsing to work as expected in browser
        if (rawUrl.startsWith("sb://")) {
            rawUrl = "https://" + rawUrl.substring(5);
        }
        const parsedUrl = parseURL(rawUrl);
        const pathname = parsedUrl.pathname;
        const firstIndexOfDelimiter = pathname.indexOf("/");
        if (pathname.match("(.*)/(.*)/Subscriptions/(.*)/Rules/(.*)")) {
            const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf("/Subscriptions/");
            const firstIndexOfRulesDelimiter = pathname.indexOf("/Rules/");
            entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1, lastIndexOfSubscriptionsDelimiter);
            entry[nameProperties[1]] = pathname.substring(lastIndexOfSubscriptionsDelimiter + 15, firstIndexOfRulesDelimiter);
            entry[nameProperties[2]] = pathname.substring(firstIndexOfRulesDelimiter + 7);
        }
        else if (pathname.match("(.*)/(.*)/Subscriptions/(.*)")) {
            const lastIndexOfSubscriptionsDelimiter = pathname.lastIndexOf("/Subscriptions/");
            entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1, lastIndexOfSubscriptionsDelimiter);
            entry[nameProperties[1]] = pathname.substring(lastIndexOfSubscriptionsDelimiter + 15);
        }
        else if (pathname.match("(.*)/(.*)")) {
            entry[nameProperties[0]] = pathname.substring(firstIndexOfDelimiter + 1);
        }
    }
}
/**
 * @internal
 * Utility to help construct the normalized `RestError` object based on given error
 * information and other data present in the received `response` object.
 */
function buildError(response) {
    if (!isKnownResponseCode(response.status)) {
        throw new coreRestPipeline.RestError(`Service returned an error response with an unrecognized HTTP status code - ${response.status}`, {
            code: "ServiceError",
            statusCode: response.status,
            request: response.request,
            response,
        });
    }
    const errorBody = response.parsedBody;
    let errorMessage;
    if (typeof errorBody === "string") {
        errorMessage = errorBody;
    }
    else {
        if (!coreUtil.isDefined(errorBody) ||
            !coreUtil.isDefined(errorBody.Error) ||
            !coreUtil.isDefined(errorBody.Error.Detail)) {
            errorMessage =
                "Detailed error message information not available. Look at the 'code' property on error for more information.";
        }
        else {
            errorMessage = errorBody.Error.Detail;
        }
    }
    const errorCode = getErrorCode(response, errorMessage);
    const error = new coreRestPipeline.RestError(errorMessage, {
        code: errorCode,
        statusCode: response.status,
        request: response.request,
        response,
    });
    return error;
}
/**
 * @internal
 * Helper utility to construct user friendly error codes based on based on given error
 * information and other data present in the received `response` object.
 */
function getErrorCode(response, errorMessage) {
    if (response.status === 401) {
        return "UnauthorizedRequestError";
    }
    if (response.status === 404) {
        return "MessageEntityNotFoundError";
    }
    if (response.status === 409) {
        if (response.request.method === "DELETE") {
            return "ServiceError";
        }
        if (response.request.method === "PUT" && response.request.headers.get("If-Match") === "*") {
            return "ServiceError";
        }
        if (errorMessage && errorMessage.toLowerCase().includes("subcode=40901")) {
            return "ServiceError";
        }
        return "MessageEntityAlreadyExistsError";
    }
    if (response.status === 403) {
        if (errorMessage && errorMessage.toLowerCase().includes("subcode=40301")) {
            return "InvalidOperationError";
        }
        return "QuotaExceededError";
    }
    if (response.status === 400) {
        return "ServiceError";
    }
    if (response.status === 503) {
        return "ServerBusyError";
    }
    return HttpResponseCodes[response.status];
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Builds the namespace object from the raw json object gotten after deserializing the
 * response from the service
 */
function buildNamespace(rawNamespace) {
    const messagingSku = (getString(rawNamespace["MessagingSKU"], "messagingSku"));
    return {
        createdAt: getDate(rawNamespace["CreatedTime"], "createdAt"),
        messagingSku: messagingSku,
        modifiedAt: getDate(rawNamespace["ModifiedTime"], "modifiedAt"),
        name: getString(rawNamespace["Name"], "name"),
        messagingUnits: messagingSku === "Premium"
            ? getInteger(rawNamespace["MessagingUnits"], "messagingUnits")
            : undefined,
    };
}
/**
 * @internal
 * Atom XML Serializer for Namespaces.
 */
class NamespaceResourceSerializer {
    serialize() {
        return serializeToAtomXmlRequest("NamespaceProperties", {});
    }
    async deserialize(response) {
        return deserializeAtomXmlResponse(["name"], response);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Builds the queue options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 */
function buildQueueOptions(queue) {
    return {
        // NOTE: this ordering is extremely important. As an example, misordering of the ForwardTo property
        // resulted in a customer bug where the Forwarding attributes appeared to be set but the portal was
        // not picking up on it.
        //
        // The authority on this ordering is here:
        // https://github.com/Azure/azure-sdk-for-net/blob/8af2dfc32c96ef3e340f9d20013bf588d97ea756/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/QueuePropertiesExtensions.cs#L20
        LockDuration: queue.lockDuration,
        MaxSizeInMegabytes: getStringOrUndefined(queue.maxSizeInMegabytes),
        RequiresDuplicateDetection: getStringOrUndefined(queue.requiresDuplicateDetection),
        RequiresSession: getStringOrUndefined(queue.requiresSession),
        DefaultMessageTimeToLive: queue.defaultMessageTimeToLive,
        DeadLetteringOnMessageExpiration: getStringOrUndefined(queue.deadLetteringOnMessageExpiration),
        DuplicateDetectionHistoryTimeWindow: queue.duplicateDetectionHistoryTimeWindow,
        MaxDeliveryCount: getStringOrUndefined(queue.maxDeliveryCount),
        EnableBatchedOperations: getStringOrUndefined(queue.enableBatchedOperations),
        AuthorizationRules: getRawAuthorizationRules(queue.authorizationRules),
        Status: getStringOrUndefined(queue.status),
        ForwardTo: getStringOrUndefined(queue.forwardTo),
        UserMetadata: getStringOrUndefined(queue.userMetadata),
        AutoDeleteOnIdle: getStringOrUndefined(queue.autoDeleteOnIdle),
        EnablePartitioning: getStringOrUndefined(queue.enablePartitioning),
        ForwardDeadLetteredMessagesTo: getStringOrUndefined(queue.forwardDeadLetteredMessagesTo),
        EntityAvailabilityStatus: getStringOrUndefined(queue.availabilityStatus),
        EnableExpress: getStringOrUndefined(queue.enableExpress),
        MaxMessageSizeInKilobytes: getStringOrUndefined(queue.maxMessageSizeInKilobytes),
    };
}
/**
 * @internal
 * Builds the queue object from the raw json object gotten after deserializing the
 * response from the service
 */
function buildQueue(rawQueue) {
    return {
        name: getString(rawQueue[QUEUE_NAME], "queueName"),
        forwardTo: getStringOrUndefined(rawQueue[FORWARD_TO]),
        userMetadata: rawQueue[USER_METADATA],
        lockDuration: getString(rawQueue[LOCK_DURATION], "lockDuration"),
        maxSizeInMegabytes: getInteger(rawQueue[MAX_SIZE_IN_MEGABYTES], "maxSizeInMegabytes"),
        maxDeliveryCount: getInteger(rawQueue[MAX_DELIVERY_COUNT], "maxDeliveryCount"),
        enablePartitioning: getBoolean(rawQueue[ENABLE_PARTITIONING], "enablePartitioning"),
        requiresSession: getBoolean(rawQueue[REQUIRES_SESSION], "requiresSession"),
        enableBatchedOperations: getBoolean(rawQueue[ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
        defaultMessageTimeToLive: getString(rawQueue[DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTimeToLive"),
        autoDeleteOnIdle: rawQueue[AUTO_DELETE_ON_IDLE],
        requiresDuplicateDetection: getBoolean(rawQueue[REQUIRES_DUPLICATE_DETECTION], "requiresDuplicateDetection"),
        duplicateDetectionHistoryTimeWindow: getString(rawQueue[DUPLICATE_DETECTION_HISTORY_TIME_WINDOW], "duplicateDetectionHistoryTimeWindow"),
        deadLetteringOnMessageExpiration: getBoolean(rawQueue[DEAD_LETTERING_ON_MESSAGE_EXPIRATION], "deadLetteringOnMessageExpiration"),
        forwardDeadLetteredMessagesTo: getStringOrUndefined(rawQueue[FORWARD_DEADLETTERED_MESSAGES_TO]),
        authorizationRules: getAuthorizationRulesOrUndefined(rawQueue[AUTHORIZATION_RULES]),
        status: rawQueue[STATUS],
        enableExpress: getBoolean(rawQueue[ENABLE_EXPRESS], "enableExpress"),
        availabilityStatus: rawQueue[ENTITY_AVAILABILITY_STATUS],
        maxMessageSizeInKilobytes: getIntegerOrUndefined(rawQueue[MAX_MESSAGE_SIZE_IN_KILOBYTES]),
    };
}
/**
 * @internal
 * Builds the queue runtime info object from the raw json object gotten after deserializing the
 * response from the service
 */
function buildQueueRuntimeProperties(rawQueue) {
    const messageCountDetails = getMessageCountDetails(rawQueue[COUNT_DETAILS]);
    return {
        name: getString(rawQueue[QUEUE_NAME], "queueName"),
        sizeInBytes: getIntegerOrUndefined(rawQueue[SIZE_IN_BYTES]),
        totalMessageCount: getIntegerOrUndefined(rawQueue[MESSAGE_COUNT]),
        ...messageCountDetails,
        createdAt: getDate(rawQueue[CREATED_AT], "createdAt"),
        modifiedAt: getDate(rawQueue[UPDATED_AT], "modifiedAt"),
        accessedAt: getDate(rawQueue[ACCESSED_AT], "accessedAt"),
    };
}
/**
 * @internal
 * Atom XML Serializer for Queues.
 */
class QueueResourceSerializer {
    serialize(resource) {
        return serializeToAtomXmlRequest("QueueDescription", resource);
    }
    async deserialize(response) {
        return deserializeAtomXmlResponse(["QueueName"], response);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Builds the rule object from the raw json object gotten after deserializing the
 * response from the service
 */
function buildRule(rawRule) {
    return {
        name: getString(rawRule["RuleName"], "ruleName"),
        filter: getTopicFilter(rawRule["Filter"]),
        action: getRuleAction(rawRule["Action"]),
    };
}
/**
 * @internal
 * Helper utility to retrieve `filter` value from given input,
 * or undefined if not passed in.
 */
function getTopicFilter(value) {
    let result;
    if (coreUtil.isDefined(value["SqlExpression"])) {
        result = {
            sqlExpression: value["SqlExpression"],
            sqlParameters: getKeyValuePairsOrUndefined(value["Parameters"], "SQLParameters"),
        };
    }
    else {
        result = {
            correlationId: getStringOrUndefined(value["CorrelationId"]),
            subject: getStringOrUndefined(value["Label"]),
            to: getStringOrUndefined(value["To"]),
            replyTo: getStringOrUndefined(value["ReplyTo"]),
            replyToSessionId: getStringOrUndefined(value["ReplyToSessionId"]),
            sessionId: getStringOrUndefined(value["SessionId"]),
            messageId: getStringOrUndefined(value["MessageId"]),
            contentType: getStringOrUndefined(value["ContentType"]),
            applicationProperties: getKeyValuePairsOrUndefined(value["Properties"], "ApplicationProperties"),
        };
    }
    return result;
}
/**
 * @internal
 * Helper utility to retrieve rule `action` value from given input.
 */
function getRuleAction(value) {
    return {
        sqlExpression: value["SqlExpression"],
        sqlParameters: getKeyValuePairsOrUndefined(value["Parameters"], "SQLParameters"),
    };
}
/**
 * @internal
 *
 */
function buildInternalRuleResource(rule) {
    const resource = {
        Filter: {},
        Action: {},
        Name: rule.name,
    };
    if (!coreUtil.isDefined(rule.filter)) {
        // Defaults to creating a true filter if none specified
        resource.Filter = {
            SqlExpression: "1=1",
        };
        resource.Filter[XML_METADATA_MARKER] = {
            "p4:type": "SqlFilter",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance",
        };
    }
    else {
        if (coreUtil.isObjectWithProperties(rule.filter, ["sqlExpression"])) {
            const sqlFilter = rule.filter;
            resource.Filter = {
                SqlExpression: sqlFilter.sqlExpression,
                Parameters: buildInternalRawKeyValuePairs(sqlFilter.sqlParameters, "sqlParameters"),
            };
            resource.Filter[XML_METADATA_MARKER] = {
                "p4:type": "SqlFilter",
                "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance",
            };
        }
        else {
            const correlationFilter = rule.filter;
            resource.Filter = {
                CorrelationId: correlationFilter.correlationId,
                Label: correlationFilter.subject,
                To: correlationFilter.to,
                ReplyTo: correlationFilter.replyTo,
                ReplyToSessionId: correlationFilter.replyToSessionId,
                ContentType: correlationFilter.contentType,
                SessionId: correlationFilter.sessionId,
                MessageId: correlationFilter.messageId,
                Properties: buildInternalRawKeyValuePairs(correlationFilter.applicationProperties, "applicationProperties"),
            };
            resource.Filter[XML_METADATA_MARKER] = {
                "p4:type": "CorrelationFilter",
                "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance",
            };
        }
    }
    if (!coreUtil.isDefined(rule.action) || !coreUtil.isDefined(rule.action.sqlExpression)) {
        // Defaults to creating an empty rule action instance if none specified
        resource.Action = {};
        resource.Action[XML_METADATA_MARKER] = {
            "p4:type": "EmptyRuleAction",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance",
        };
    }
    else {
        resource.Action = {
            SqlExpression: rule.action.sqlExpression,
            Parameters: buildInternalRawKeyValuePairs(rule.action.sqlParameters, "sqlParameters"),
        };
        resource.Action[XML_METADATA_MARKER] = {
            "p4:type": "SqlRuleAction",
            "xmlns:p4": "http://www.w3.org/2001/XMLSchema-instance",
        };
    }
    return resource;
}
/**
 * @internal
 * RuleResourceSerializer for serializing / deserializing Rule entities
 */
class RuleResourceSerializer {
    serialize(rule) {
        return serializeToAtomXmlRequest("RuleDescription", buildInternalRuleResource(rule));
    }
    async deserialize(response) {
        return deserializeAtomXmlResponse(["TopicName", "SubscriptionName", "RuleName"], response);
    }
}
/**
 * @internal
 */
function isSqlRuleAction(action) {
    return coreUtil.isObjectWithProperties(action, ["sqlExpression"]);
}
/**
 * Service expects the XML request with the special type names serialized in the request,
 * the request would fail otherwise.
 *
 * @internal
 */
var TypeMapForRequestSerialization;
(function (TypeMapForRequestSerialization) {
    TypeMapForRequestSerialization["double"] = "l28:double";
    TypeMapForRequestSerialization["string"] = "l28:string";
    TypeMapForRequestSerialization["long"] = "l28:long";
    TypeMapForRequestSerialization["date"] = "l28:dateTime";
    TypeMapForRequestSerialization["boolean"] = "l28:boolean";
})(TypeMapForRequestSerialization || (TypeMapForRequestSerialization = {}));
/**
 * @internal
 */
var TypeMapForResponseDeserialization;
(function (TypeMapForResponseDeserialization) {
    TypeMapForResponseDeserialization["int"] = "int";
    TypeMapForResponseDeserialization["double"] = "double";
    TypeMapForResponseDeserialization["string"] = "string";
    TypeMapForResponseDeserialization["boolean"] = "boolean";
    TypeMapForResponseDeserialization["date"] = "dateTime";
})(TypeMapForResponseDeserialization || (TypeMapForResponseDeserialization = {}));
/**
 * Key-value pairs are supposed to be wrapped with this tag in the XML request, they are ignored otherwise.
 *
 * @internal
 */
const keyValuePairXMLTag = "KeyValueOfstringanyType";
/**
 * @internal
 * Helper utility to retrieve the key-value pairs from the RawKeyValue object from given input,
 * or undefined if not passed in.
 */
function getKeyValuePairsOrUndefined(value, attribute) {
    if (!value) {
        return undefined;
    }
    const properties = {};
    let rawProperties;
    if (!Array.isArray(value[keyValuePairXMLTag]) && value[keyValuePairXMLTag]?.Key) {
        // When a single property is present,
        //    value["KeyValueOfstringanyType"] is { Key: <key>, Value: [Object] }
        // When multiple properties are present,
        //    value["KeyValueOfstringanyType"] is [ { Key: <key-1>, Value: [Object] }, { Key: <key-2>, Value: [Object] } ]
        // For consistency, wrapping `value["KeyValueOfstringanyType"]` as an array for the "single property" case.
        rawProperties = [value[keyValuePairXMLTag]];
    }
    else {
        rawProperties = value[keyValuePairXMLTag];
    }
    if (Array.isArray(rawProperties)) {
        for (const rawProperty of rawProperties) {
            const key = rawProperty.Key;
            const _value = rawProperty.Value["_"];
            const encodedValueType = rawProperty.Value["$"]["i:type"].toString().substring(5);
            if (encodedValueType === TypeMapForResponseDeserialization.int ||
                encodedValueType === TypeMapForResponseDeserialization.double) {
                properties[key] = Number(_value);
            }
            else if (encodedValueType === TypeMapForResponseDeserialization.string) {
                properties[key] = _value;
            }
            else if (encodedValueType === TypeMapForResponseDeserialization.boolean) {
                properties[key] = _value === "true" ? true : false;
            }
            else if (encodedValueType === TypeMapForResponseDeserialization.date) {
                properties[key] = new Date(_value);
            }
            else {
                throw new TypeError(`Unable to parse the key-value pairs in the response - ${JSON.stringify(rawProperty)}`);
            }
        }
    }
    else {
        throw new TypeError(`${attribute} in the response is not an array, unable to parse the response - ${JSON.stringify(value)}`);
    }
    return properties;
}
/**
 * @internal
 * Helper utility to extract array of user properties key-value instances from given input,
 * or undefined if not passed in.
 */
function buildInternalRawKeyValuePairs(parameters, attribute) {
    if (!coreUtil.isDefined(parameters)) {
        return undefined;
    }
    if (Array.isArray(parameters) ||
        typeof parameters === "string" ||
        typeof parameters !== "object" ||
        Object.entries(parameters).length < 1) {
        throw new TypeError(`Unsupported value for the ${attribute} ${JSON.stringify(parameters)}, expected a JSON object with key-value pairs.`);
    }
    const rawParameters = [];
    for (const key of Object.keys(parameters)) {
        let type;
        let value = parameters[key];
        if (typeof value === "number") {
            type = TypeMapForRequestSerialization.double;
        }
        else if (typeof value === "string") {
            type = TypeMapForRequestSerialization.string;
        }
        else if (typeof value === "boolean") {
            type = TypeMapForRequestSerialization.boolean;
        }
        else if (value instanceof Date && !isNaN(value.valueOf())) {
            type = TypeMapForRequestSerialization.date;
            value = value.toJSON();
        }
        else {
            throw new TypeError(`Unsupported type for the value in the ${attribute} for the key '${key}'`);
        }
        const rawParameter = {
            Key: key,
            Value: {
                [XML_METADATA_MARKER]: {
                    "p4:type": type,
                    "xmlns:l28": "http://www.w3.org/2001/XMLSchema",
                },
                [XML_VALUE_MARKER]: value,
            },
        };
        rawParameters.push(rawParameter);
    }
    return {
        [keyValuePairXMLTag]: rawParameters,
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Builds the subscription options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 */
function buildSubscriptionOptions(subscription) {
    return {
        // NOTE: this ordering is extremely important. As an example, misordering of the ForwardTo property
        // resulted in a customer bug where the Forwarding attributes appeared to be set but the portal was
        // not picking up on it.
        //
        // The authority on this ordering is here:
        // https://github.com/Azure/azure-sdk-for-net/blob/8af2dfc32c96ef3e340f9d20013bf588d97ea756/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/SubscriptionPropertiesExtensions.cs#L191
        LockDuration: subscription.lockDuration,
        RequiresSession: getStringOrUndefined(subscription.requiresSession),
        DefaultMessageTimeToLive: getStringOrUndefined(subscription.defaultMessageTimeToLive),
        DeadLetteringOnMessageExpiration: getStringOrUndefined(subscription.deadLetteringOnMessageExpiration),
        DeadLetteringOnFilterEvaluationExceptions: getStringOrUndefined(subscription.deadLetteringOnFilterEvaluationExceptions),
        DefaultRuleDescription: subscription.defaultRuleOptions
            ? buildInternalRuleResource(subscription.defaultRuleOptions)
            : undefined,
        MaxDeliveryCount: getStringOrUndefined(subscription.maxDeliveryCount),
        EnableBatchedOperations: getStringOrUndefined(subscription.enableBatchedOperations),
        Status: getStringOrUndefined(subscription.status),
        ForwardTo: getStringOrUndefined(subscription.forwardTo),
        UserMetadata: getStringOrUndefined(subscription.userMetadata),
        ForwardDeadLetteredMessagesTo: getStringOrUndefined(subscription.forwardDeadLetteredMessagesTo),
        AutoDeleteOnIdle: getStringOrUndefined(subscription.autoDeleteOnIdle),
        EntityAvailabilityStatus: getStringOrUndefined(subscription.availabilityStatus),
    };
}
/**
 * @internal
 * Builds the subscription object from the raw json object gotten after deserializing
 * the response from the service
 */
function buildSubscription(rawSubscription) {
    return {
        subscriptionName: getString(rawSubscription[SUBSCRIPTION_NAME], "subscriptionName"),
        topicName: getString(rawSubscription[TOPIC_NAME], "topicName"),
        lockDuration: getString(rawSubscription[LOCK_DURATION], "lockDuration"),
        maxDeliveryCount: getInteger(rawSubscription[MAX_DELIVERY_COUNT], "maxDeliveryCount"),
        requiresSession: getBoolean(rawSubscription[REQUIRES_SESSION], "requiresSession"),
        enableBatchedOperations: getBoolean(rawSubscription[ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
        defaultMessageTimeToLive: getString(rawSubscription[DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTimeToLive"),
        autoDeleteOnIdle: getString(rawSubscription[AUTO_DELETE_ON_IDLE], "autoDeleteOnIdle"),
        deadLetteringOnMessageExpiration: getBoolean(rawSubscription[DEAD_LETTERING_ON_MESSAGE_EXPIRATION], "deadLetteringOnMessageExpiration"),
        deadLetteringOnFilterEvaluationExceptions: getBoolean(rawSubscription[DEAD_LETTERING_ON_FILTER_EVALUATION_EXCEPTIONS], "deadLetteringOnFilterEvaluationExceptions"),
        forwardDeadLetteredMessagesTo: getStringOrUndefined(rawSubscription[FORWARD_DEADLETTERED_MESSAGES_TO]),
        forwardTo: getStringOrUndefined(rawSubscription[FORWARD_TO]),
        userMetadata: rawSubscription[USER_METADATA],
        status: getString(rawSubscription[STATUS], "status"),
        availabilityStatus: getString(rawSubscription[ENTITY_AVAILABILITY_STATUS], "availabilityStatus"),
    };
}
/**
 * @internal
 * Builds the subscription runtime info object from the raw json object gotten after deserializing
 * the response from the service
 */
function buildSubscriptionRuntimeProperties(rawSubscription) {
    const messageCountDetails = getMessageCountDetails(rawSubscription[COUNT_DETAILS]);
    return {
        subscriptionName: getString(rawSubscription[SUBSCRIPTION_NAME], "subscriptionName"),
        topicName: getString(rawSubscription[TOPIC_NAME], "topicName"),
        totalMessageCount: getInteger(rawSubscription[MESSAGE_COUNT], "messageCount"),
        activeMessageCount: messageCountDetails.activeMessageCount,
        deadLetterMessageCount: messageCountDetails.deadLetterMessageCount,
        transferDeadLetterMessageCount: messageCountDetails.transferDeadLetterMessageCount,
        transferMessageCount: messageCountDetails.transferMessageCount,
        createdAt: getDate(rawSubscription[CREATED_AT], "createdAt"),
        modifiedAt: getDate(rawSubscription[UPDATED_AT], "modifiedAt"),
        accessedAt: getDate(rawSubscription[ACCESSED_AT], "accessedAt"),
    };
}
/**
 * @internal
 * SubscriptionResourceSerializer for serializing / deserializing Subscription entities
 */
class SubscriptionResourceSerializer {
    serialize(resource) {
        return serializeToAtomXmlRequest("SubscriptionDescription", resource);
    }
    async deserialize(response) {
        return deserializeAtomXmlResponse(["TopicName", "SubscriptionName"], response);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Builds the topic options object from the user provided options.
 * Handles the differences in casing for the property names,
 * converts values to string and ensures the right order as expected by the service
 */
function buildTopicOptions(topic) {
    return {
        // NOTE: this ordering is extremely important. As an example, misordering of the ForwardTo property
        // resulted in a customer bug where the Forwarding attributes appeared to be set but the portal was
        // not picking up on it.
        //
        // The authority on this ordering is here:
        // https://github.com/Azure/azure-sdk-for-net/blob/8af2dfc32c96ef3e340f9d20013bf588d97ea756/sdk/servicebus/Azure.Messaging.ServiceBus/src/Administration/TopicPropertiesExtensions.cs#L175
        DefaultMessageTimeToLive: topic.defaultMessageTimeToLive,
        MaxSizeInMegabytes: getStringOrUndefined(topic.maxSizeInMegabytes),
        RequiresDuplicateDetection: getStringOrUndefined(topic.requiresDuplicateDetection),
        DuplicateDetectionHistoryTimeWindow: topic.duplicateDetectionHistoryTimeWindow,
        EnableBatchedOperations: getStringOrUndefined(topic.enableBatchedOperations),
        AuthorizationRules: getRawAuthorizationRules(topic.authorizationRules),
        Status: getStringOrUndefined(topic.status),
        UserMetadata: getStringOrUndefined(topic.userMetadata),
        SupportOrdering: getStringOrUndefined(topic.supportOrdering),
        AutoDeleteOnIdle: getStringOrUndefined(topic.autoDeleteOnIdle),
        EnablePartitioning: getStringOrUndefined(topic.enablePartitioning),
        EntityAvailabilityStatus: getStringOrUndefined(topic.availabilityStatus),
        EnableExpress: getStringOrUndefined(topic.enableExpress),
        MaxMessageSizeInKilobytes: getStringOrUndefined(topic.maxMessageSizeInKilobytes),
    };
}
/**
 * @internal
 * Builds the topic object from the raw json object gotten after deserializing the
 * response from the service
 */
function buildTopic(rawTopic) {
    return {
        name: getString(rawTopic[TOPIC_NAME], "topicName"),
        maxSizeInMegabytes: getInteger(rawTopic[MAX_SIZE_IN_MEGABYTES], "maxSizeInMegabytes"),
        enablePartitioning: getBoolean(rawTopic[ENABLE_PARTITIONING], "enablePartitioning"),
        supportOrdering: getBoolean(rawTopic[SUPPORT_ORDERING], "supportOrdering"),
        enableBatchedOperations: getBoolean(rawTopic[ENABLE_BATCHED_OPERATIONS], "enableBatchedOperations"),
        defaultMessageTimeToLive: getString(rawTopic[DEFAULT_MESSAGE_TIME_TO_LIVE], "defaultMessageTimeToLive"),
        autoDeleteOnIdle: rawTopic[AUTO_DELETE_ON_IDLE],
        requiresDuplicateDetection: getBoolean(rawTopic[REQUIRES_DUPLICATE_DETECTION], "requiresDuplicateDetection"),
        duplicateDetectionHistoryTimeWindow: getString(rawTopic[DUPLICATE_DETECTION_HISTORY_TIME_WINDOW], "duplicateDetectionHistoryTimeWindow"),
        authorizationRules: getAuthorizationRulesOrUndefined(rawTopic[AUTHORIZATION_RULES]),
        userMetadata: rawTopic[USER_METADATA],
        status: rawTopic[STATUS],
        enableExpress: getBoolean(rawTopic[ENABLE_EXPRESS], "enableExpress"),
        availabilityStatus: rawTopic[ENTITY_AVAILABILITY_STATUS],
        maxMessageSizeInKilobytes: getIntegerOrUndefined(rawTopic[MAX_MESSAGE_SIZE_IN_KILOBYTES]),
    };
}
/**
 * @internal
 * Builds the topic runtime info object from the raw json object gotten after deserializing the
 * response from the service
 */
function buildTopicRuntimeProperties(rawTopic) {
    return {
        name: getString(rawTopic[TOPIC_NAME], "topicName"),
        sizeInBytes: getIntegerOrUndefined(rawTopic[SIZE_IN_BYTES]),
        subscriptionCount: getIntegerOrUndefined(rawTopic[SUBSCRIPTION_COUNT]),
        createdAt: getDate(rawTopic[CREATED_AT], "createdAt"),
        scheduledMessageCount: getMessageCountDetails(rawTopic[COUNT_DETAILS])
            .scheduledMessageCount,
        modifiedAt: getDate(rawTopic[UPDATED_AT], "modifiedAt"),
        accessedAt: getDate(rawTopic[ACCESSED_AT], "accessedAt"),
    };
}
/**
 * @internal
 * TopicResourceSerializer for serializing / deserializing Topic entities
 */
class TopicResourceSerializer {
    serialize(resource) {
        return serializeToAtomXmlRequest("TopicDescription", resource);
    }
    async deserialize(response) {
        return deserializeAtomXmlResponse(["TopicName"], response);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 */
async function generateKey(secret, stringToSign) {
    const result = encodeURIComponent(crypto.createHmac("sha256", secret).update(stringToSign).digest("base64"));
    return result;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
class SasServiceClientCredentials {
    /**
     * Creates a new sasServiceClientCredentials object.
     *
     * @param credential - The NamedKeyCredential containing the key name and secret key value.
     */
    constructor(credential) {
        this._credential = credential;
        this._tokenProvider = coreAmqp.createSasTokenProvider(credential);
    }
    async _generateSignature(targetUri, expirationDate) {
        const stringToSign = `${targetUri}\n${expirationDate}`;
        const result = await generateKey(this._credential.key, stringToSign);
        return result;
    }
    /**
     * Signs a request with the Authentication header.
     *
     * @param request - The {@link PipelineRequest} to be signed.
     * @returns The signed request object.
     */
    async signRequest(request) {
        if (!request.headers)
            request.headers = coreRestPipeline.createHttpHeaders();
        const targetUri = encodeURIComponent(request.url.toLowerCase()).toLowerCase();
        const date = new Date();
        date.setMinutes(date.getMinutes() + 5);
        const expirationDate = Math.round(date.getTime() / 1000);
        const signature = await this._generateSignature(targetUri, expirationDate);
        request.headers.set("authorization", `SharedAccessSignature sig=${signature}&se=${expirationDate}&skn=${this._credential.name}&sr=${targetUri}`);
        request.withCredentials = true;
        return request;
    }
    getToken(audience) {
        return this._tokenProvider.getToken(audience);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The {@link TracingClient} that is used to add tracing spans.
 */
const tracingClient = coreTracing.createTracingClient({
    namespace: "Microsoft.ServiceBus",
    packageName: packageJsonInfo.name,
    packageVersion: packageJsonInfo.version,
});
/**
 * Creates {@link TracingSpanOptions} from the provided data.
 * @param serviceBusConfig - The configuration object containing initial attributes to set on the span.
 * @param spanKind - The {@link TracingSpanKind} for the newly created span.
 * @param operation - The operation type.
 * @returns a {@link TracingSpanOptions} that can be passed to a {@link TracingClient}
 */
function toSpanOptions(serviceBusConfig, operation, spanKind) {
    const propertyName = operation === "process" || operation === "receive"
        ? "messaging.source.name"
        : "messaging.destination.name";
    const spanOptions = {
        spanAttributes: {
            "messaging.system": "servicebus",
            [propertyName]: serviceBusConfig.entityPath,
            "messaging.operation": operation,
            "net.peer.name": serviceBusConfig.host,
        },
    };
    if (spanKind) {
        spanOptions.spanKind = spanKind;
    }
    return spanOptions;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function signingPolicy(credentials) {
    return {
        name: "signingPolicy",
        async sendRequest(request, next) {
            const signed = await credentials.signRequest(request);
            return next(signed);
        },
    };
}
/**
 * All operations return promises that resolve to an object that has the relevant output.
 * These objects also have a property called `_response` that you can use if you want to
 * access the direct response from the service.
 */
class ServiceBusAdministrationClient extends coreClient.ServiceClient {
    constructor(fullyQualifiedNamespaceOrConnectionString1, credentialOrOptions2, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options3) {
        let options;
        let fullyQualifiedNamespace;
        let credentials;
        let authPolicy;
        if (coreAuth.isTokenCredential(credentialOrOptions2)) {
            fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;
            options = options3 || {};
            credentials = credentialOrOptions2;
            authPolicy = coreRestPipeline.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: coreAmqp.Constants.aadServiceBusScope,
            });
        }
        else if (coreAuth.isNamedKeyCredential(credentialOrOptions2)) {
            fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;
            credentials = new SasServiceClientCredentials(credentialOrOptions2);
            options = options3 || {};
            authPolicy = signingPolicy(credentials);
        }
        else {
            const connectionString = fullyQualifiedNamespaceOrConnectionString1;
            options = credentialOrOptions2 || {};
            const connectionStringObj = coreAmqp.parseConnectionString(connectionString);
            if (connectionStringObj.Endpoint === undefined) {
                throw new Error("Missing Endpoint in connection string.");
            }
            try {
                fullyQualifiedNamespace = connectionStringObj.Endpoint.match(".*://([^/]*)")[1];
            }
            catch (error) {
                throw new Error("Endpoint in the connection string is not valid.");
            }
            credentials = new SasServiceClientCredentials({
                key: connectionStringObj.SharedAccessKey,
                name: connectionStringObj.SharedAccessKeyName,
            });
            authPolicy = signingPolicy(credentials);
        }
        const userAgentPrefix = formatUserAgentPrefix(options.userAgentOptions?.userAgentPrefix);
        const serviceClientOptions = coreRestPipeline.createPipelineFromOptions({
            ...options,
            userAgentOptions: {
                userAgentPrefix,
            },
        });
        serviceClientOptions.addPolicy(authPolicy);
        super({ pipeline: serviceClientOptions });
        this.endpoint = fullyQualifiedNamespace;
        this.endpointWithProtocol = fullyQualifiedNamespace.endsWith("/")
            ? "sb://" + fullyQualifiedNamespace
            : "sb://" + fullyQualifiedNamespace + "/";
        this.serviceVersion = options.serviceVersion ?? CURRENT_API_VERSION;
        this.credentials = credentials;
        this.namespaceResourceSerializer = new NamespaceResourceSerializer();
        this.queueResourceSerializer = new QueueResourceSerializer();
        this.topicResourceSerializer = new TopicResourceSerializer();
        this.subscriptionResourceSerializer = new SubscriptionResourceSerializer();
        this.ruleResourceSerializer = new RuleResourceSerializer();
    }
    /**
     * Returns an object representing the metadata related to a service bus namespace.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     */
    async getNamespaceProperties(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        administrationLogger.verbose(`Performing management operation - getNamespaceProperties()`);
        return tracingClient.withSpan("ServiceBusAdministrationClient.getNamespaceProperties", operationOptions, async (updatedOptions) => {
            const response = await this.getResource("$namespaceinfo", this.namespaceResourceSerializer, updatedOptions);
            return this.buildNamespacePropertiesResponse(response);
        });
    }
    /**
     * Creates a queue with given name, configured using the given options
     * @param options - Options to configure the Queue being created(For example, you can configure a queue to support partitions or sessions)
     *  and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async createQueue(queueName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.createQueue", options, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - createQueue() for "${queueName}" with options: %j`, options);
            const response = await this.putResource(queueName, buildQueueOptions(options || {}), this.queueResourceSerializer, false, updatedOptions);
            return this.buildQueueResponse(response);
        });
    }
    /**
     * Returns an object representing the Queue and its properties.
     * If you want to get the Queue runtime info like message count details, use `getQueueRuntimeProperties` API.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getQueue(queueName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getQueue", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getQueue() for "${queueName}"`);
            const response = await this.getResource(queueName, this.queueResourceSerializer, updatedOptions);
            return this.buildQueueResponse(response);
        });
    }
    /**
     * Returns an object representing the Queue runtime info like message count details.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getQueueRuntimeProperties(queueName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getQueueRuntimeProperties", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getQueueRuntimeProperties() for "${queueName}"`);
            const response = await this.getResource(queueName, this.queueResourceSerializer, updatedOptions);
            return this.buildQueueRuntimePropertiesResponse(response);
        });
    }
    /**
     * Returns a list of objects, each representing a Queue along with its properties.
     * If you want to get the runtime info of the queues like message count, use `getQueuesRuntimeProperties` API instead.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getQueues(options = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getQueues", options, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getQueues() with options: %j`, options);
            const response = await this.listResources("$Resources/Queues", updatedOptions, this.queueResourceSerializer);
            return this.buildListQueuesResponse(response);
        });
    }
    async *listQueuesPage(marker, options = {}) {
        let listResponse;
        do {
            listResponse = await this.getQueues({
                skip: Number(marker),
                maxCount: options.maxPageSize,
                ...options,
            });
            marker = listResponse.continuationToken;
            yield listResponse;
        } while (marker);
    }
    async *listQueuesAll(options = {}) {
        let marker;
        for await (const segment of this.listQueuesPage(marker, options)) {
            yield* segment;
        }
    }
    /**
     * Returns an async iterable iterator to list all the queues.
     *
     * .byPage() returns an async iterable iterator to list the queues in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listQueues(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        administrationLogger.verbose(`Performing management operation - listQueues() with options: %j`, options);
        const iter = this.listQueuesAll(options);
        return {
            /**
             */
            next() {
                return iter.next();
            },
            /**
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listQueuesPage(settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...options,
                });
            },
        };
    }
    /**
     * Returns a list of objects, each representing a Queue's runtime info like message count details.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getQueuesRuntimeProperties(options = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getQueuesRuntimeProperties", options, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getQueuesRuntimeProperties() with options: %j`, options);
            const response = await this.listResources("$Resources/Queues", updatedOptions, this.queueResourceSerializer);
            return this.buildListQueuesRuntimePropertiesResponse(response);
        });
    }
    async *listQueuesRuntimePropertiesPage(marker, options = {}) {
        let listResponse;
        do {
            listResponse = await this.getQueuesRuntimeProperties({
                skip: Number(marker),
                maxCount: options.maxPageSize,
                ...options,
            });
            marker = listResponse.continuationToken;
            yield listResponse;
        } while (marker);
    }
    async *listQueuesRuntimePropertiesAll(options = {}) {
        let marker;
        for await (const segment of this.listQueuesRuntimePropertiesPage(marker, options)) {
            yield* segment;
        }
    }
    /**
     * Returns an async iterable iterator to list runtime info of the queues.
     *
     * .byPage() returns an async iterable iterator to list runtime info of the queues in pages.
     *
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listQueuesRuntimeProperties(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        administrationLogger.verbose(`Performing management operation - listQueuesRuntimeProperties() with options: %j`, options);
        const iter = this.listQueuesRuntimePropertiesAll(options);
        return {
            /**
             */
            next() {
                return iter.next();
            },
            /**
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listQueuesRuntimePropertiesPage(settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...options,
                });
            },
        };
    }
    /**
     * Updates the queue based on the queue properties provided.
     * All queue properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getQueue()`, update the desired properties in it, and then pass the modified object to `updateQueue()`.
     *
     * The properties that cannot be updated are marked as readonly in the `QueueProperties` interface.
     *
     * @param queue - Object representing the properties of the queue and the raw response.
     * `requiresSession`, `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the queue.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async updateQueue(queue, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.updateQueue", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - updateQueue() for "${queue.name}" with options: %j`, queue);
            if (!isJSONLikeObject(queue) || queue == null) {
                throw new TypeError(`Parameter "queue" must be an object of type "QueueDescription" and cannot be undefined or null.`);
            }
            if (!queue.name) {
                throw new TypeError(`"name" attribute of the parameter "queue" cannot be undefined.`);
            }
            const response = await this.putResource(queue.name, buildQueueOptions(queue), this.queueResourceSerializer, true, updatedOptions);
            return this.buildQueueResponse(response);
        });
    }
    /**
     * Deletes a queue.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async deleteQueue(queueName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.deleteQueue", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - deleteQueue() for "${queueName}"`);
            const response = await this.deleteResource(queueName, this.queueResourceSerializer, updatedOptions);
            return { _response: getHttpResponseOnly(response) };
        });
    }
    /**
     * Checks whether a given queue exists or not.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     */
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    async queueExists(queueName, operationOptions = {}) {
        administrationLogger.verbose(`Performing management operation - queueExists() for "${queueName}"`);
        const { span, updatedOptions } = tracingClient.startSpan("ServiceBusAdministrationClient.queueExists", operationOptions);
        try {
            await this.getQueue(queueName, updatedOptions);
            span.setStatus({ status: "success" });
            return true;
        }
        catch (e) {
            span.setStatus({ status: "error", error: e });
            return false;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a topic with given name, configured using the given options
     * @param options - Options to configure the Topic being created(For example, you can configure a topic to support partitions)
     * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async createTopic(topicName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.createTopic", options, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - createTopic() for "${topicName}" with options: %j`, options);
            const response = await this.putResource(topicName, buildTopicOptions(options || {}), this.topicResourceSerializer, false, updatedOptions);
            return this.buildTopicResponse(response);
        });
    }
    /**
     * Returns an object representing the Topic and its properties.
     * If you want to get the Topic runtime info like subscription count details, use `getTopicRuntimeProperties` API.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getTopic(topicName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getTopic", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getTopic() for "${topicName}"`);
            const response = await this.getResource(topicName, this.topicResourceSerializer, updatedOptions);
            return this.buildTopicResponse(response);
        });
    }
    /**
     * Returns an object representing the Topic runtime info like subscription count.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getTopicRuntimeProperties(topicName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getTopicRuntimeProperties", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getTopicRuntimeProperties() for "${topicName}"`);
            const response = await this.getResource(topicName, this.topicResourceSerializer, updatedOptions);
            return this.buildTopicRuntimePropertiesResponse(response);
        });
    }
    /**
     * Returns a list of objects, each representing a Topic along with its properties.
     * If you want to get the runtime info of the topics like subscription count, use `getTopicsRuntimeProperties` API instead.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getTopics(options = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getTopics", options, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getTopics() with options: %j`, options);
            const response = await this.listResources("$Resources/Topics", updatedOptions, this.topicResourceSerializer);
            return this.buildListTopicsResponse(response);
        });
    }
    async *listTopicsPage(marker, options = {}) {
        let listResponse;
        do {
            listResponse = await this.getTopics({
                skip: Number(marker),
                maxCount: options.maxPageSize,
                ...options,
            });
            marker = listResponse.continuationToken;
            yield listResponse;
        } while (marker);
    }
    async *listTopicsAll(options = {}) {
        let marker;
        for await (const segment of this.listTopicsPage(marker, options)) {
            yield* segment;
        }
    }
    /**
     * Returns an async iterable iterator to list all the topics.
     *
     * .byPage() returns an async iterable iterator to list the topics in pages.
     *
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listTopics(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        administrationLogger.verbose(`Performing management operation - listTopics() with options: %j`, options);
        const iter = this.listTopicsAll(options);
        return {
            /**
             */
            next() {
                return iter.next();
            },
            /**
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listTopicsPage(settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...options,
                });
            },
        };
    }
    /**
     * Returns a list of objects, each representing a Topic's runtime info like subscription count.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getTopicsRuntimeProperties(options = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getTopicsRuntimeProperties", options, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getTopicsRuntimeProperties() with options: %j`, options);
            const response = await this.listResources("$Resources/Topics", updatedOptions, this.topicResourceSerializer);
            return this.buildListTopicsRuntimePropertiesResponse(response);
        });
    }
    async *listTopicsRuntimePropertiesPage(marker, options = {}) {
        let listResponse;
        do {
            listResponse = await this.getTopicsRuntimeProperties({
                skip: Number(marker),
                maxCount: options.maxPageSize,
                ...options,
            });
            marker = listResponse.continuationToken;
            yield listResponse;
        } while (marker);
    }
    async *listTopicsRuntimePropertiesAll(options = {}) {
        let marker;
        for await (const segment of this.listTopicsRuntimePropertiesPage(marker, options)) {
            yield* segment;
        }
    }
    /**
     * Returns an async iterable iterator to list runtime info of the topics.
     *
     * .byPage() returns an async iterable iterator to list runtime info of the topics in pages.
     *
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listTopicsRuntimeProperties(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        administrationLogger.verbose(`Performing management operation - listTopicsRuntimeProperties() with options: %j`, options);
        const iter = this.listTopicsRuntimePropertiesAll(options);
        return {
            /**
             * The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listTopicsRuntimePropertiesPage(settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...options,
                });
            },
        };
    }
    /**
     * Updates the topic based on the topic properties provided.
     * All topic properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getTopic()`, update the desired properties in it, and then pass the modified object to `updateTopic()`.
     *
     * The properties that cannot be updated are marked as readonly in the `TopicProperties` interface.
     *
     * @param topic - Object representing the properties of the topic and the raw response.
     * `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the topic.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async updateTopic(topic, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.updateTopic", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - updateTopic() for "${topic.name}" with options: %j`, topic);
            if (!isJSONLikeObject(topic) || topic == null) {
                throw new TypeError(`Parameter "topic" must be an object of type "TopicDescription" and cannot be undefined or null.`);
            }
            if (!topic.name) {
                throw new TypeError(`"name" attribute of the parameter "topic" cannot be undefined.`);
            }
            const response = await this.putResource(topic.name, buildTopicOptions(topic), this.topicResourceSerializer, true, updatedOptions);
            return this.buildTopicResponse(response);
        });
    }
    /**
     * Deletes a topic.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async deleteTopic(topicName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.deleteTopic", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - deleteTopic() for "${topicName}"`);
            const response = await this.deleteResource(topicName, this.topicResourceSerializer, updatedOptions);
            return { _response: getHttpResponseOnly(response) };
        });
    }
    /**
     * Checks whether a given topic exists or not.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     */
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    async topicExists(topicName, operationOptions) {
        administrationLogger.verbose(`Performing management operation - topicExists() for "${topicName}"`);
        const { span, updatedOptions } = tracingClient.startSpan("ServiceBusAdministrationClient.topicExists", operationOptions);
        try {
            span.setStatus({ status: "success" });
            await this.getTopic(topicName, updatedOptions);
            return true;
        }
        catch (e) {
            span.setStatus({ status: "error", error: e });
            return false;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a subscription with given name, configured using the given options
     * @param options - Options to configure the Subscription being created(For example, you can configure a Subscription to support partitions or sessions)
     * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async createSubscription(topicName, subscriptionName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.createSubscription", options, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - createSubscription() for "${subscriptionName}" with options: %j`, options);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = await this.putResource(fullPath, buildSubscriptionOptions(options || {}), this.subscriptionResourceSerializer, false, updatedOptions);
            return this.buildSubscriptionResponse(response);
        });
    }
    /**
     * Returns an object representing the Subscription and its properties.
     * If you want to get the Subscription runtime info like message count details, use `getSubscriptionRuntimeProperties` API.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getSubscription(topicName, subscriptionName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getSubscription", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getSubscription() for "${subscriptionName}"`);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = await this.getResource(fullPath, this.subscriptionResourceSerializer, updatedOptions);
            return this.buildSubscriptionResponse(response);
        });
    }
    /**
     * Returns an object representing the Subscription runtime info like message count details.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getSubscriptionRuntimeProperties(topicName, subscriptionName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getSubscriptionRuntimeProperties", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getSubscriptionRuntimeProperties() for "${subscriptionName}"`);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = await this.getResource(fullPath, this.subscriptionResourceSerializer, updatedOptions);
            return this.buildSubscriptionRuntimePropertiesResponse(response);
        });
    }
    /**
     * Returns a list of objects, each representing a Subscription along with its properties.
     * If you want to get the runtime info of the subscriptions like message count, use `getSubscriptionsRuntimeProperties` API instead.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getSubscriptions(topicName, options = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getSubscriptions", options, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getSubscriptions() with options: %j`, options);
            const response = await this.listResources(topicName + "/Subscriptions/", updatedOptions, this.subscriptionResourceSerializer);
            return this.buildListSubscriptionsResponse(response);
        });
    }
    async *listSubscriptionsPage(topicName, marker, options = {}) {
        let listResponse;
        do {
            listResponse = await this.getSubscriptions(topicName, {
                skip: Number(marker),
                maxCount: options.maxPageSize,
                ...options,
            });
            marker = listResponse.continuationToken;
            yield listResponse;
        } while (marker);
    }
    async *listSubscriptionsAll(topicName, options = {}) {
        let marker;
        for await (const segment of this.listSubscriptionsPage(topicName, marker, options)) {
            yield* segment;
        }
    }
    /**
     *
     * Returns an async iterable iterator to list all the subscriptions
     * under the specified topic.
     *
     * .byPage() returns an async iterable iterator to list the subscriptions in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listSubscriptions(topicName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        administrationLogger.verbose(`Performing management operation - listSubscriptions() with options: %j`, options);
        const iter = this.listSubscriptionsAll(topicName, options);
        return {
            /**
             */
            next() {
                return iter.next();
            },
            /**
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listSubscriptionsPage(topicName, settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...options,
                });
            },
        };
    }
    /**
     * Returns a list of objects, each representing a Subscription's runtime info like message count details.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getSubscriptionsRuntimeProperties(topicName, options = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getSubscriptionsRuntimeProperties", options, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getSubscriptionsRuntimeProperties() with options: %j`, options);
            const response = await this.listResources(topicName + "/Subscriptions/", updatedOptions, this.subscriptionResourceSerializer);
            return this.buildListSubscriptionsRuntimePropertiesResponse(response);
        });
    }
    async *listSubscriptionsRuntimePropertiesPage(topicName, marker, options = {}) {
        let listResponse;
        do {
            listResponse = await this.getSubscriptionsRuntimeProperties(topicName, {
                skip: Number(marker),
                maxCount: options.maxPageSize,
                ...options,
            });
            marker = listResponse.continuationToken;
            yield listResponse;
        } while (marker);
    }
    async *listSubscriptionsRuntimePropertiesAll(topicName, options = {}) {
        let marker;
        for await (const segment of this.listSubscriptionsRuntimePropertiesPage(topicName, marker, options)) {
            yield* segment;
        }
    }
    /**
     * Returns an async iterable iterator to list runtime info of the subscriptions
     * under the specified topic.
     *
     * .byPage() returns an async iterable iterator to list runtime info of subscriptions in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listSubscriptionsRuntimeProperties(topicName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        administrationLogger.verbose(`Performing management operation - listSubscriptionsRuntimeProperties() with options: %j`, options);
        const iter = this.listSubscriptionsRuntimePropertiesAll(topicName, options);
        return {
            /**
             */
            next() {
                return iter.next();
            },
            /**
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listSubscriptionsRuntimePropertiesPage(topicName, settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...options,
                });
            },
        };
    }
    /**
     * Updates the subscription based on the subscription properties provided.
     * All subscription properties must be set even though only a subset of them are actually updatable.
     * Therefore, the suggested flow is to use the output from `getSubscription()`, update the desired properties in it, and then pass the modified object to `updateSubscription()`.
     *
     * The properties that cannot be updated are marked as readonly in the `SubscriptionProperties` interface.
     * @param subscription - Object representing the properties of the subscription and the raw response.
     * `subscriptionName`, `topicName`, and `requiresSession` can't be updated after creating the subscription.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async updateSubscription(subscription, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.updateSubscription", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - updateSubscription() for "${subscription.subscriptionName}" with options: %j`, subscription);
            if (!isJSONLikeObject(subscription) || subscription == null) {
                throw new TypeError(`Parameter "subscription" must be an object of type "SubscriptionDescription" and cannot be undefined or null.`);
            }
            if (!subscription.topicName || !subscription.subscriptionName) {
                throw new TypeError(`The attributes "topicName" and "subscriptionName" of the parameter "subscription" cannot be undefined.`);
            }
            const fullPath = this.getSubscriptionPath(subscription.topicName, subscription.subscriptionName);
            const response = await this.putResource(fullPath, buildSubscriptionOptions(subscription), this.subscriptionResourceSerializer, true, updatedOptions);
            return this.buildSubscriptionResponse(response);
        });
    }
    /**
     * Deletes a subscription.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async deleteSubscription(topicName, subscriptionName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.deleteSubscription", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - deleteSubscription() for "${subscriptionName}"`);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName);
            const response = await this.deleteResource(fullPath, this.subscriptionResourceSerializer, updatedOptions);
            return { _response: getHttpResponseOnly(response) };
        });
    }
    /**
     * Checks whether a given subscription exists in the topic or not.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     */
    async subscriptionExists(topicName, subscriptionName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        administrationLogger.verbose(`Performing management operation - subscriptionExists() for "${topicName}" and "${subscriptionName}"`);
        const { span, updatedOptions } = tracingClient.startSpan("ServiceBusAdministrationClient.subscriptionExists", operationOptions);
        try {
            span.setStatus({ status: "success" });
            await this.getSubscription(topicName, subscriptionName, updatedOptions);
            return true;
        }
        catch (e) {
            span.setStatus({ status: "error", error: e });
            return false;
        }
        finally {
            span.end();
        }
    }
    async createRule(topicName, subscriptionName, ruleName, ruleFilter, ruleActionOrOperationOptions, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions) {
        let ruleAction = undefined;
        let operOptions;
        if (ruleActionOrOperationOptions) {
            if (isSqlRuleAction(ruleActionOrOperationOptions)) {
                // Overload#2 - where the sqlExpression in the ruleAction is defined
                ruleAction = ruleActionOrOperationOptions;
                operOptions = operationOptions;
            }
            else {
                // Overload#1
                // Overload#2 - where the sqlExpression in the ruleAction is undefined
                operOptions = { ...ruleActionOrOperationOptions, ...operationOptions };
            }
        }
        return tracingClient.withSpan("ServiceBusAdministrationClient.createRule", operOptions ?? {}, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - createRule() for "${ruleName}" with filter: "%j"`, ruleFilter);
            const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
            const response = await this.putResource(fullPath, { name: ruleName, filter: ruleFilter, action: ruleAction }, this.ruleResourceSerializer, false, updatedOptions);
            return this.buildRuleResponse(response);
        });
    }
    /**
     * Returns an object representing the Rule with the given name along with all its properties.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getRule(topicName, subscriptionName, ruleName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getRule", operationOptions, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getRule() for "${ruleName}"`);
            const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
            const response = await this.getResource(fullPath, this.ruleResourceSerializer, updatedOptions);
            return this.buildRuleResponse(response);
        });
    }
    /**
     * Lists existing rules.
     * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async getRules(topicName, subscriptionName, options = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getRules", options, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - getRules() with options: %j`, options);
            const fullPath = this.getSubscriptionPath(topicName, subscriptionName) + "/Rules/";
            const response = await this.listResources(fullPath, updatedOptions, this.ruleResourceSerializer);
            return this.buildListRulesResponse(response);
        });
    }
    async *listRulesPage(topicName, subscriptionName, marker, options = {}) {
        let listResponse;
        do {
            listResponse = await this.getRules(topicName, subscriptionName, {
                skip: Number(marker),
                maxCount: options.maxPageSize,
                ...options,
            });
            marker = listResponse.continuationToken;
            yield listResponse;
        } while (marker);
    }
    async *listRulesAll(topicName, subscriptionName, options = {}) {
        let marker;
        for await (const segment of this.listRulesPage(topicName, subscriptionName, marker, options)) {
            yield* segment;
        }
    }
    /**
     * Returns an async iterable iterator to list all the rules
     * under the specified subscription.
     *
     * .byPage() returns an async iterable iterator to list the rules in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listRules(topicName, subscriptionName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        administrationLogger.verbose(`Performing management operation - listRules() with options: %j`, options);
        const iter = this.listRulesAll(topicName, subscriptionName, options);
        return {
            /**
             */
            next() {
                return iter.next();
            },
            /**
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             */
            byPage: (settings = {}) => {
                this.throwIfInvalidContinuationToken(settings.continuationToken);
                return this.listRulesPage(topicName, subscriptionName, settings.continuationToken, {
                    maxPageSize: settings.maxPageSize,
                    ...options,
                });
            },
        };
    }
    /**
     * Updates properties on the Rule by the given name based on the given options.
     * All rule properties must be set even if one of them is being updated.
     * Therefore, the suggested flow is to use the output from `getRule()`, update the desired properties in it, and then pass the modified object to `updateRule()`.
     *
     * @param rule - Options to configure the Rule being updated and the raw response.
     * For example, you can configure the filter to apply on associated Topic/Subscription.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async updateRule(topicName, subscriptionName, rule, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.updateRule", operationOptions ?? {}, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - updateRule() for "${rule.name}" with options: %j`, rule);
            if (!isJSONLikeObject(rule) || rule === null) {
                throw new TypeError(`Parameter "rule" must be an object of type "RuleDescription" and cannot be undefined or null.`);
            }
            if (!rule.name) {
                throw new TypeError(`"name" attribute of the parameter "rule" cannot be undefined.`);
            }
            const fullPath = this.getRulePath(topicName, subscriptionName, rule.name);
            const response = await this.putResource(fullPath, rule, this.ruleResourceSerializer, true, updatedOptions);
            return this.buildRuleResponse(response);
        });
    }
    /**
     * Deletes a rule.
     * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.
     *
     * Following are errors that can be expected from this operation
     * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,
     * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,
     * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,
     * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,
     * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as
     * bad requests or requests resulting in conflicting operation on the server,
     * @throws `RestError` with code and statusCode representing the standard set of REST API errors.
     */
    async deleteRule(topicName, subscriptionName, ruleName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.deleteRule", operationOptions ?? {}, async (updatedOptions) => {
            administrationLogger.verbose(`Performing management operation - deleteRule() for "${ruleName}"`);
            const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);
            const response = await this.deleteResource(fullPath, this.ruleResourceSerializer, updatedOptions);
            return { _response: getHttpResponseOnly(response) };
        });
    }
    /**
     * Checks whether a given rule exists or not.
     *
     */
    async ruleExists(topicName, subscriptionName, ruleName, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    operationOptions = {}) {
        administrationLogger.verbose(`Performing management operation - ruleExists() for "${ruleName}"`);
        const { span, updatedOptions } = tracingClient.startSpan("ServiceBusAdministrationClient.ruleExists", operationOptions);
        try {
            span.setStatus({ status: "success" });
            await this.getRule(topicName, subscriptionName, ruleName, updatedOptions);
            return true;
        }
        catch (e) {
            span.setStatus({ status: "error", error: e });
            return false;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates or updates a resource based on `isUpdate` parameter.
     */
    async putResource(name, entityFields, serializer, isUpdate = false, operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.putResource", operationOptions, async (updatedOptions) => {
            const request = coreRestPipeline.createPipelineRequest({
                url: this.getUrl(name),
                method: "PUT",
            });
            if (isUpdate) {
                request.headers.set("If-Match", "*");
            }
            const queueOrSubscriptionFields = entityFields;
            if (queueOrSubscriptionFields.ForwardTo ||
                queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {
                const token = this.credentials instanceof SasServiceClientCredentials
                    ? (await this.credentials.getToken(this.endpoint)).token
                    : (await this.credentials.getToken([coreAmqp.Constants.aadServiceBusScope])).token;
                if (queueOrSubscriptionFields.ForwardTo) {
                    request.headers.set("ServiceBusSupplementaryAuthorization", token);
                    if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardTo)) {
                        queueOrSubscriptionFields.ForwardTo = this.endpointWithProtocol.concat(queueOrSubscriptionFields.ForwardTo);
                    }
                }
                if (queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {
                    request.headers.set("ServiceBusDlqSupplementaryAuthorization", token);
                    if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo)) {
                        queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo =
                            this.endpointWithProtocol.concat(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo);
                    }
                }
            }
            request.headers.set("content-type", "application/atom+xml;type=entry;charset=utf-8");
            return executeAtomXmlOperation(this, request, serializer, updatedOptions, entityFields);
        });
    }
    /**
     * Gets a resource.
     */
    async getResource(name, serializer, operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.getResource", operationOptions, async (updatedOptions) => {
            const request = coreRestPipeline.createPipelineRequest({
                url: this.getUrl(name),
                method: "GET",
            });
            const response = await executeAtomXmlOperation(this, request, serializer, updatedOptions);
            if (!coreUtil.isDefined(response.parsedBody) ||
                (Array.isArray(response.parsedBody) && response.parsedBody.length === 0)) {
                const err = new coreRestPipeline.RestError(`The messaging entity "${name}" being requested cannot be found.`, {
                    code: "MessageEntityNotFoundError",
                    statusCode: response.status,
                    request,
                    response,
                });
                throw err;
            }
            return response;
        });
    }
    /**
     * Lists existing resources
     */
    async listResources(name, options = {}, serializer) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.listResources", options, async (updatedOptions) => {
            const queryParams = {};
            if (options) {
                if (options.skip) {
                    queryParams["$skip"] = options.skip.toString();
                }
                if (options.maxCount) {
                    queryParams["$top"] = options.maxCount.toString();
                }
            }
            const request = coreRestPipeline.createPipelineRequest({
                url: this.getUrl(name, queryParams),
                method: "GET",
            });
            return executeAtomXmlOperation(this, request, serializer, updatedOptions);
        });
    }
    /**
     * Deletes a resource.
     */
    async deleteResource(name, serializer, operationOptions = {}) {
        return tracingClient.withSpan("ServiceBusAdministrationClient.deleteResource", operationOptions, async (updatedOptions) => {
            const request = coreRestPipeline.createPipelineRequest({
                url: this.getUrl(name),
                method: "DELETE",
            });
            return executeAtomXmlOperation(this, request, serializer, updatedOptions);
        });
    }
    getUrl(path, queryParams) {
        const baseUri = `https://${this.endpoint}/${path}`;
        const requestUrl = new URL(baseUri);
        requestUrl.searchParams.set(API_VERSION_QUERY_KEY, this.serviceVersion);
        if (queryParams) {
            for (const key of Object.keys(queryParams)) {
                requestUrl.searchParams.set(key, queryParams[key]);
            }
        }
        return requestUrl.toString();
    }
    getSubscriptionPath(topicName, subscriptionName) {
        return topicName + "/Subscriptions/" + subscriptionName;
    }
    getRulePath(topicName, subscriptionName, ruleName) {
        return topicName + "/Subscriptions/" + subscriptionName + "/Rules/" + ruleName;
    }
    getMarkerFromNextLinkUrl(url) {
        if (!url) {
            return undefined;
        }
        try {
            const value = parseURL(url).searchParams.get(XML_METADATA_MARKER + "skip");
            return value !== null ? value : undefined;
        }
        catch (error) {
            throw new Error(`Unable to parse the '${XML_METADATA_MARKER}skip' from the next-link in the response ` +
                error);
        }
    }
    buildNamespacePropertiesResponse(response) {
        try {
            const namespace = buildNamespace(response.parsedBody);
            const namespaceResponse = Object.defineProperty(namespace || {}, "_response", { value: getHttpResponseOnly(response) });
            return namespaceResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a namespace object using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildListQueuesResponse(response) {
        try {
            const queues = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawQueueArray = response.parsedBody;
            for (let i = 0; i < rawQueueArray.length; i++) {
                const queue = buildQueue(rawQueueArray[i]);
                if (queue) {
                    queues.push(queue);
                }
            }
            const listQueuesResponse = Object.defineProperty(queues, "_response", {
                value: getHttpResponseOnly(response),
            });
            listQueuesResponse.continuationToken = nextMarker;
            return listQueuesResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildListQueuesRuntimePropertiesResponse(response) {
        try {
            const queues = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawQueueArray = response.parsedBody;
            for (let i = 0; i < rawQueueArray.length; i++) {
                const queue = buildQueueRuntimeProperties(rawQueueArray[i]);
                if (queue) {
                    queues.push(queue);
                }
            }
            const listQueuesResponse = Object.defineProperty(queues, "_response", {
                value: getHttpResponseOnly(response),
            });
            listQueuesResponse.continuationToken = nextMarker;
            return listQueuesResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildQueueResponse(response) {
        try {
            const queue = buildQueue(response.parsedBody);
            const queueResponse = Object.defineProperty(queue || {}, "_response", {
                value: getHttpResponseOnly(response),
            });
            return queueResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a queue object using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildQueueRuntimePropertiesResponse(response) {
        try {
            const queue = buildQueueRuntimeProperties(response.parsedBody);
            const queueResponse = Object.defineProperty(queue || {}, "_response", {
                value: getHttpResponseOnly(response),
            });
            return queueResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a queue object using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildListTopicsResponse(response) {
        try {
            const topics = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawTopicArray = response.parsedBody;
            for (let i = 0; i < rawTopicArray.length; i++) {
                const topic = buildTopic(rawTopicArray[i]);
                if (topic) {
                    topics.push(topic);
                }
            }
            const listTopicsResponse = Object.defineProperty(topics, "_response", {
                value: getHttpResponseOnly(response),
            });
            listTopicsResponse.continuationToken = nextMarker;
            return listTopicsResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildListTopicsRuntimePropertiesResponse(response) {
        try {
            const topics = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawTopicArray = response.parsedBody;
            for (let i = 0; i < rawTopicArray.length; i++) {
                const topic = buildTopicRuntimeProperties(rawTopicArray[i]);
                if (topic) {
                    topics.push(topic);
                }
            }
            const listTopicsResponse = Object.defineProperty(topics, "_response", {
                value: getHttpResponseOnly(response),
            });
            listTopicsResponse.continuationToken = nextMarker;
            return listTopicsResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildTopicResponse(response) {
        try {
            const topic = buildTopic(response.parsedBody);
            const topicResponse = Object.defineProperty(topic || {}, "_response", {
                value: getHttpResponseOnly(response),
            });
            return topicResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a topic object using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildTopicRuntimePropertiesResponse(response) {
        try {
            const topic = buildTopicRuntimeProperties(response.parsedBody);
            const topicResponse = Object.defineProperty(topic || {}, "_response", {
                value: getHttpResponseOnly(response),
            });
            return topicResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a topic object using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildListSubscriptionsResponse(response) {
        try {
            const subscriptions = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawSubscriptionArray = response.parsedBody;
            for (let i = 0; i < rawSubscriptionArray.length; i++) {
                const subscription = buildSubscription(rawSubscriptionArray[i]);
                if (subscription) {
                    subscriptions.push(subscription);
                }
            }
            const listSubscriptionsResponse = Object.defineProperty(subscriptions, "_response", {
                value: getHttpResponseOnly(response),
            });
            listSubscriptionsResponse.continuationToken = nextMarker;
            return listSubscriptionsResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildListSubscriptionsRuntimePropertiesResponse(response) {
        try {
            const subscriptions = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawSubscriptionArray = response.parsedBody;
            for (let i = 0; i < rawSubscriptionArray.length; i++) {
                const subscription = buildSubscriptionRuntimeProperties(rawSubscriptionArray[i]);
                if (subscription) {
                    subscriptions.push(subscription);
                }
            }
            const listSubscriptionsResponse = Object.defineProperty(subscriptions, "_response", {
                value: getHttpResponseOnly(response),
            });
            listSubscriptionsResponse.continuationToken = nextMarker;
            return listSubscriptionsResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildSubscriptionResponse(response) {
        try {
            const subscription = buildSubscription(response.parsedBody);
            const subscriptionResponse = Object.defineProperty(subscription || {}, "_response", {
                value: getHttpResponseOnly(response),
            });
            return subscriptionResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildSubscriptionRuntimePropertiesResponse(response) {
        try {
            const subscription = buildSubscriptionRuntimeProperties(response.parsedBody);
            const subscriptionResponse = Object.defineProperty(subscription || {}, "_response", {
                value: getHttpResponseOnly(response),
            });
            return subscriptionResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildListRulesResponse(response) {
        try {
            const rules = [];
            const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);
            if (!Array.isArray(response.parsedBody)) {
                throw new TypeError(`${response.parsedBody} was expected to be of type Array`);
            }
            const rawRuleArray = response.parsedBody;
            for (let i = 0; i < rawRuleArray.length; i++) {
                const rule = buildRule(rawRuleArray[i]);
                if (rule) {
                    rules.push(rule);
                }
            }
            const listRulesResponse = Object.defineProperty(rules, "_response", {
                value: getHttpResponseOnly(response),
            });
            listRulesResponse.continuationToken = nextMarker;
            return listRulesResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a list of rules using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    buildRuleResponse(response) {
        try {
            const rule = buildRule(response.parsedBody);
            const ruleResponse = Object.defineProperty(rule || {}, "_response", {
                value: getHttpResponseOnly(response),
            });
            return ruleResponse;
        }
        catch (err) {
            administrationLogger.logError(err, "Failure parsing response from service");
            throw new coreRestPipeline.RestError(`Error occurred while parsing the response body - cannot form a rule object using the response from the service.`, {
                code: coreRestPipeline.RestError.PARSE_ERROR,
                statusCode: response.status,
                request: response.request,
                response,
            });
        }
    }
    throwIfInvalidContinuationToken(token) {
        if (!(token === undefined || (typeof token === "string" && Number(token) >= 0))) {
            throw new Error(`Invalid continuationToken ${token} provided`);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** @internal */
const dataSectionTypeCode = 0x75;
/** @internal */
const sequenceSectionTypeCode = 0x76;
/** @internal */
const valueSectionTypeCode = 0x77;
/**
 * The default data transformer that will be used by the Azure SDK.
 * @internal
 */
const defaultDataTransformer = {
    /**
     * A function that takes the body property from an EventData object
     * and returns an encoded body (some form of AMQP type).
     *
     * @param body - The AMQP message body
     * @returns The encoded AMQP message body as an AMQP Data type
     * (data section in rhea terms). Section object with following properties:
     * - typecode: 117 (0x75)
     * - content: The given AMQP message body as a Buffer.
     * - multiple: true | undefined.
     */
    encode(body, bodyType) {
        let result;
        if (bodyType === "value") {
            // TODO: Expose value_section from `rhea` similar to the data_section and sequence_section. Right now there isn't a way to create a value section officially.
            result = rheaPromise.message.data_section(body);
            result.typecode = valueSectionTypeCode;
        }
        else if (bodyType === "sequence") {
            result = rheaPromise.message.sequence_section(body);
        }
        else if (isBuffer(body) || body instanceof Uint8Array) {
            result = rheaPromise.message.data_section(body);
        }
        else {
            // string, undefined, null, boolean, array, object, number should end up here
            // coercing undefined to null as that will ensure that null value will be given to the
            // customer on receive.
            if (body === undefined)
                body = null; // tslint:disable-line
            try {
                const bodyStr = JSON.stringify(body);
                result = rheaPromise.message.data_section(buffer.Buffer.from(bodyStr, "utf8"));
            }
            catch (err) {
                const msg = `An error occurred while executing JSON.stringify() on the given body ` +
                    body +
                    `${err ? err.stack : JSON.stringify(err)}`;
                logger.warning("[encode] " + msg);
                logErrorStackTrace(logger, err);
                throw new Error(msg);
            }
        }
        return result;
    },
    /**
     * A function that takes the body property from an AMQP message
     * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.
     * If it cannot decode the body then it returns the body
     * as-is.
     *
     * NOTE: Use this to decode a message body when you know that the entire contents are _only_ contained
     * in the 'data' section of the message (for instance, messages from the $mgmt link). Otherwise
     * use 'defaultDataTransformer.decodeWithType', which can handle data coming from separate sections
     * of the AMQP mesage.
     *
     * @param body - The AMQP message body
     * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body content.
     * @returns decoded body or the given body as-is.
     */
    decode(body, skipParsingBodyAsJson) {
        let actualContent = body;
        if (isRheaAmqpSection(body)) {
            actualContent = body.content;
        }
        return skipParsingBodyAsJson ? actualContent : tryToJsonDecode(actualContent);
    },
    /**
     * A function that takes the body property from an AMQP message, which can come from either
     * the 'data', 'value' or 'sequence' sections of an AMQP message.
     *
     * If the body is not a JSON string the the raw contents will be returned, along with the bodyType
     * indicating which part of the AMQP message the body was decoded from.
     *
     * @param body - The AMQP message body as received from rhea.
     * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body.
     * @returns The decoded/raw body and the body type.
     */
    decodeWithType(body, skipParsingBodyAsJson) {
        try {
            if (isRheaAmqpSection(body)) {
                switch (body.typecode) {
                    case dataSectionTypeCode:
                        return {
                            body: skipParsingBodyAsJson ? body.content : tryToJsonDecode(body.content),
                            bodyType: "data",
                        };
                    case sequenceSectionTypeCode:
                        // typecode:
                        // handle sequences
                        return { body: body.content, bodyType: "sequence" };
                    case valueSectionTypeCode:
                        // value
                        return { body: body.content, bodyType: "value" };
                }
            }
            else {
                // not sure - we have to try to infer the proper bodyType and content
                if (isBuffer(body)) {
                    // This indicates that we are getting the AMQP described type. Let us try decoding it.
                    return { body: skipParsingBodyAsJson ? body : tryToJsonDecode(body), bodyType: "data" };
                }
                else {
                    return { body: body, bodyType: "value" };
                }
            }
        }
        catch (err) {
            logger.verbose("[decode] An error occurred while decoding the received message body. The error is: %O", err);
            throw err;
        }
    },
};
/** @internal */
function isRheaAmqpSection(possibleSection) {
    return (possibleSection != null &&
        typeof possibleSection.typecode === "number" &&
        (possibleSection.typecode === dataSectionTypeCode ||
            possibleSection.typecode === valueSectionTypeCode ||
            possibleSection.typecode === sequenceSectionTypeCode));
}
/**
 * Attempts to decode 'body' as a JSON string. If it fails it returns body
 * verbatim.
 *
 * @param body - An AMQP message body.
 * @returns A JSON decoded object, or body if body was not a JSON string.
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function tryToJsonDecode(body) {
    let processedBody = body;
    try {
        // Trying to stringify and JSON.parse() anything else will fail flat and we shall return
        // the original type back
        const bodyStr = processedBody.toString("utf8");
        processedBody = JSON.parse(bodyStr);
    }
    catch (err) {
        logger.verbose("[decode] An error occurred while trying JSON.parse() on the received body. " +
            "The error is %O", err);
    }
    return processedBody;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
var DispositionType;
(function (DispositionType) {
    DispositionType["complete"] = "complete";
    DispositionType["deadletter"] = "deadletter";
    DispositionType["abandon"] = "abandon";
    DispositionType["defer"] = "defer";
})(DispositionType || (DispositionType = {}));
/**
 * @internal
 * Gets the error message for when a property on given message is not of expected type
 */
function getMessagePropertyTypeMismatchError(msg) {
    if (msg.contentType != null && typeof msg.contentType !== "string") {
        return new TypeError("The property 'contentType' on the message must be of type 'string'");
    }
    if (msg.subject != null && typeof msg.subject !== "string") {
        return new TypeError("The property 'label' on the message must be of type 'string'");
    }
    if (msg.to != null && typeof msg.to !== "string") {
        return new TypeError("The property 'to' on the message must be of type 'string'");
    }
    if (msg.replyTo != null && typeof msg.replyTo !== "string") {
        return new TypeError("The property 'replyTo' on the message must be of type 'string'");
    }
    if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== "string") {
        return new TypeError("The property 'replyToSessionId' on the message must be of type 'string'");
    }
    if (msg.timeToLive != null && typeof msg.timeToLive !== "number") {
        return new TypeError("The property 'timeToLive' on the message must be of type 'number'");
    }
    if (msg.sessionId != null && typeof msg.sessionId !== "string") {
        return new TypeError("The property 'sessionId' on the message must be of type 'string'");
    }
    if (msg.messageId != null &&
        typeof msg.messageId !== "string" &&
        typeof msg.messageId !== "number" &&
        !buffer.Buffer.isBuffer(msg.messageId)) {
        return new TypeError("The property 'messageId' on the message must be of type string, number or Buffer");
    }
    if (msg.correlationId != null &&
        typeof msg.correlationId !== "string" &&
        typeof msg.correlationId !== "number" &&
        !buffer.Buffer.isBuffer(msg.correlationId)) {
        return new TypeError("The property 'correlationId' on the message must be of type string, number or Buffer");
    }
    return;
}
/**
 * @internal
 * Converts given ServiceBusMessage to RheaMessage
 */
function toRheaMessage(msg, encoder) {
    let amqpMsg;
    if (isAmqpAnnotatedMessage(msg)) {
        amqpMsg = {
            ...coreAmqp.AmqpAnnotatedMessage.toRheaMessage(msg),
            body: encoder.encode(msg.body, msg.bodyType ?? "data"),
        };
    }
    else {
        let bodyType = "data";
        if (isServiceBusReceivedMessage(msg)) {
            /*
             * TODO: this is a bit complicated.
             *
             * It seems reasonable to expect to be able to round-trip a message (ie,
             * receive a message, and then send it again, possibly to another queue / topic).
             * If the user does that we need to make sure to respect their original AMQP
             * type so when the message is re - encoded we don't put 'body' into the wrong spot.
             *
             * The complication is that we need to decide if we're okay with respecting a field
             * from the rawAmqpMessage, which up until now we've treated as just vestigial
             * information on send. My hope is that the use case of "alter the sb message in some
             * incompatible way with the underying _rawAmqpMessage.bodyType" is not common
             * enough for us to try to do anything more than what I'm doing here.
             */
            bodyType = msg._rawAmqpMessage.bodyType ?? "data";
        }
        // TODO: it seems sensible that we'd also do this for AMQPAnnotated message.
        const validationError = getMessagePropertyTypeMismatchError(msg);
        if (validationError) {
            throw validationError;
        }
        amqpMsg = {
            body: encoder.encode(msg.body, bodyType),
            message_annotations: {},
        };
        if (msg.timeToLive) {
            amqpMsg.ttl = Math.min(msg.timeToLive, coreAmqp.Constants.maxUint32Value);
            amqpMsg.creation_time = new Date();
            amqpMsg.absolute_expiry_time = new Date(Math.min(amqpMsg.creation_time.getTime() + amqpMsg.ttl, coreAmqp.Constants.maxAbsoluteExpiryTime));
        }
    }
    if (isAmqpAnnotatedMessage(msg)) {
        return amqpMsg;
    }
    if (msg.applicationProperties != null) {
        amqpMsg.application_properties = msg.applicationProperties;
    }
    if (msg.contentType != null) {
        amqpMsg.content_type = msg.contentType;
    }
    if (msg.sessionId != null) {
        if (msg.sessionId.length > coreAmqp.Constants.maxSessionIdLength) {
            throw new Error("Length of 'sessionId' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.group_id = msg.sessionId;
    }
    if (msg.replyTo != null) {
        amqpMsg.reply_to = msg.replyTo;
    }
    if (msg.to != null) {
        amqpMsg.to = msg.to;
    }
    if (msg.subject != null) {
        amqpMsg.subject = msg.subject;
    }
    updateMessageId(amqpMsg, msg.messageId);
    if (msg.correlationId != null) {
        amqpMsg.correlation_id = msg.correlationId;
    }
    if (msg.replyToSessionId != null) {
        amqpMsg.reply_to_group_id = msg.replyToSessionId;
    }
    if (msg.partitionKey != null) {
        if (msg.partitionKey.length > coreAmqp.Constants.maxPartitionKeyLength) {
            throw new Error("Length of 'partitionKey' property on the message cannot be greater than 128 characters.");
        }
        amqpMsg.message_annotations[coreAmqp.Constants.partitionKey] = msg.partitionKey;
    }
    // Will be required later for implementing Transactions
    // if (msg.viaPartitionKey != null) {
    //   if (msg.viaPartitionKey.length > Constants.maxPartitionKeyLength) {
    //     throw new Error(
    //       "Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters."
    //     );
    //   }
    //   amqpMsg.message_annotations![Constants.viaPartitionKey] = msg.viaPartitionKey;
    // }
    updateScheduledTime(amqpMsg, msg.scheduledEnqueueTimeUtc);
    messageLogger.verbose("SBMessage to RheaMessage: %O", amqpMsg);
    return amqpMsg;
}
/** @internal */
function updateMessageId(rheaMessage, messageId) {
    if (messageId != null) {
        if (typeof messageId === "string" && messageId.length > coreAmqp.Constants.maxMessageIdLength) {
            throw new Error(`Length of 'messageId' property on the message cannot be greater than ${coreAmqp.Constants.maxMessageIdLength} characters.`);
        }
        rheaMessage.message_id = messageId;
    }
}
/** @internal */
function updateScheduledTime(rheaMessage, scheduledEnqueuedTimeUtc) {
    if (scheduledEnqueuedTimeUtc != null) {
        rheaMessage.message_annotations = rheaMessage.message_annotations ?? {};
        rheaMessage.message_annotations[coreAmqp.Constants.scheduledEnqueueTime] = scheduledEnqueuedTimeUtc;
    }
}
/**
 * @internal
 * Converts given RheaMessage to ServiceBusReceivedMessage
 */
function fromRheaMessage(rheaMessage, options) {
    if (!rheaMessage) {
        rheaMessage = {
            body: undefined,
        };
    }
    const { skipParsingBodyAsJson, delivery, shouldReorderLockToken, skipConvertingDate = false, } = options;
    const { body, bodyType } = defaultDataTransformer.decodeWithType(rheaMessage.body, skipParsingBodyAsJson);
    const sbmsg = {
        body: body,
    };
    if (rheaMessage.application_properties != null) {
        sbmsg.applicationProperties = skipConvertingDate
            ? rheaMessage.application_properties
            : convertDatesToNumbers(rheaMessage.application_properties);
    }
    if (rheaMessage.content_type != null) {
        sbmsg.contentType = rheaMessage.content_type;
    }
    if (rheaMessage.group_id != null) {
        sbmsg.sessionId = rheaMessage.group_id;
    }
    if (rheaMessage.reply_to != null) {
        sbmsg.replyTo = rheaMessage.reply_to;
    }
    if (rheaMessage.to != null) {
        sbmsg.to = rheaMessage.to;
    }
    if (rheaMessage.subject != null) {
        sbmsg.subject = rheaMessage.subject;
    }
    if (rheaMessage.message_id != null) {
        sbmsg.messageId = rheaMessage.message_id;
    }
    if (rheaMessage.correlation_id != null) {
        sbmsg.correlationId = rheaMessage.correlation_id;
    }
    if (rheaMessage.reply_to_group_id != null) {
        sbmsg.replyToSessionId = rheaMessage.reply_to_group_id;
    }
    if (rheaMessage.message_annotations != null) {
        if (rheaMessage.message_annotations[coreAmqp.Constants.partitionKey] != null) {
            sbmsg.partitionKey = rheaMessage.message_annotations[coreAmqp.Constants.partitionKey];
        }
        // Will be required later for implementing Transactions
        // if (msg.message_annotations[Constants.viaPartitionKey] != null) {
        //   sbmsg.viaPartitionKey = msg.message_annotations[Constants.viaPartitionKey];
        // }
        if (rheaMessage.message_annotations[coreAmqp.Constants.scheduledEnqueueTime] != null) {
            sbmsg.scheduledEnqueueTimeUtc =
                rheaMessage.message_annotations[coreAmqp.Constants.scheduledEnqueueTime];
        }
    }
    const props = { state: "active" };
    if (rheaMessage.message_annotations != null) {
        if (rheaMessage.message_annotations[coreAmqp.Constants.deadLetterSource] != null) {
            props.deadLetterSource = rheaMessage.message_annotations[coreAmqp.Constants.deadLetterSource];
        }
        const messageState = rheaMessage.message_annotations[coreAmqp.Constants.messageState];
        if (messageState === 1) {
            props.state = "deferred";
        }
        else if (messageState === 2) {
            props.state = "scheduled";
        }
        if (rheaMessage.message_annotations[coreAmqp.Constants.enqueueSequenceNumber] != null) {
            props.enqueuedSequenceNumber =
                rheaMessage.message_annotations[coreAmqp.Constants.enqueueSequenceNumber];
        }
        if (rheaMessage.message_annotations[coreAmqp.Constants.sequenceNumber] != null) {
            if (buffer.Buffer.isBuffer(rheaMessage.message_annotations[coreAmqp.Constants.sequenceNumber])) {
                props.sequenceNumber = Long.fromBytesBE(rheaMessage.message_annotations[coreAmqp.Constants.sequenceNumber]);
            }
            else {
                props.sequenceNumber = Long.fromNumber(rheaMessage.message_annotations[coreAmqp.Constants.sequenceNumber]);
            }
        }
        if (rheaMessage.message_annotations[coreAmqp.Constants.enqueuedTime] != null) {
            props.enqueuedTimeUtc = new Date(rheaMessage.message_annotations[coreAmqp.Constants.enqueuedTime]);
        }
        if (rheaMessage.message_annotations[coreAmqp.Constants.lockedUntil] != null) {
            props.lockedUntilUtc = new Date(rheaMessage.message_annotations[coreAmqp.Constants.lockedUntil]);
        }
    }
    const rawMessage = coreAmqp.AmqpAnnotatedMessage.fromRheaMessage(rheaMessage);
    rawMessage.bodyType = bodyType;
    if (rheaMessage.ttl == null) {
        rheaMessage.ttl = rawMessage.header?.timeToLive ?? coreAmqp.Constants.maxDurationValue;
    }
    if (props.enqueuedTimeUtc) {
        props.expiresAtUtc = new Date(Math.min(props.enqueuedTimeUtc.getTime() + rheaMessage.ttl, coreAmqp.Constants.maxDurationValue));
    }
    if (rawMessage.applicationProperties) {
        rawMessage.applicationProperties = skipConvertingDate
            ? rawMessage.applicationProperties
            : convertDatesToNumbers(rawMessage.applicationProperties);
    }
    if (rawMessage.deliveryAnnotations) {
        rawMessage.deliveryAnnotations = skipConvertingDate
            ? rawMessage.deliveryAnnotations
            : convertDatesToNumbers(rawMessage.deliveryAnnotations);
    }
    if (rawMessage.messageAnnotations) {
        rawMessage.messageAnnotations = skipConvertingDate
            ? rawMessage.messageAnnotations
            : convertDatesToNumbers(rawMessage.messageAnnotations);
    }
    if (rawMessage.header?.timeToLive) {
        sbmsg.timeToLive = rawMessage.header.timeToLive;
    }
    const rcvdsbmsg = {
        _rawAmqpMessage: rawMessage,
        deliveryCount: rheaMessage.delivery_count,
        lockToken: delivery && delivery.tag && delivery.tag.length !== 0
            ? rheaPromise.uuid_to_string(shouldReorderLockToken === true
                ? reorderLockToken(typeof delivery.tag === "string" ? buffer.Buffer.from(delivery.tag) : delivery.tag)
                : typeof delivery.tag === "string"
                    ? buffer.Buffer.from(delivery.tag)
                    : delivery.tag)
            : undefined,
        ...sbmsg,
        ...props,
        deadLetterReason: sbmsg.applicationProperties?.DeadLetterReason,
        deadLetterErrorDescription: sbmsg.applicationProperties?.DeadLetterErrorDescription,
    };
    messageLogger.verbose("AmqpMessage to ServiceBusReceivedMessage: %O", rcvdsbmsg);
    return rcvdsbmsg;
}
/**
 * @internal
 */
function isServiceBusMessage(possible) {
    return coreUtil.isObjectWithProperties(possible, ["body"]);
}
/**
 * @internal
 */
function isAmqpAnnotatedMessage(possible) {
    return (coreUtil.isObjectWithProperties(possible, ["body", "bodyType"]) &&
        possible.constructor.name !== ServiceBusMessageImpl.name);
}
/**
 * @internal
 */
function isServiceBusReceivedMessage(possible) {
    return isServiceBusMessage(possible) && "_rawAmqpMessage" in possible;
}
/**
 * Describes the message received from Service Bus.
 *
 * @internal
 */
class ServiceBusMessageImpl {
    /**
     * @internal
     */
    constructor(msg, delivery, shouldReorderLockToken, receiveMode, skipParsingBodyAsJson, skipConvertingDate) {
        const { _rawAmqpMessage, ...restOfMessageProps } = fromRheaMessage(msg, { skipParsingBodyAsJson, delivery, shouldReorderLockToken, skipConvertingDate });
        this._rawAmqpMessage = _rawAmqpMessage; // need to initialize _rawAmqpMessage property to make compiler happy
        Object.assign(this, restOfMessageProps);
        this.state = restOfMessageProps.state; // to suppress error TS2564: Property 'state' has no initializer and is not definitely assigned in the constructor.
        // Lock on a message is applicable only in peekLock mode, but the service sets
        // the lock token even in receiveAndDelete mode if the entity in question is partitioned.
        if (receiveMode === "receiveAndDelete") {
            this.lockToken = undefined;
        }
        this.delivery = delivery;
    }
    /**
     * Creates a clone of the current message to allow it to be re-sent to the queue
     * @returns ServiceBusMessage
     */
    clone() {
        // We are returning a ServiceBusMessage object because that object can then be sent to Service Bus
        const clone = {
            body: this.body,
            contentType: this.contentType,
            correlationId: this.correlationId,
            subject: this.subject,
            messageId: this.messageId,
            partitionKey: this.partitionKey,
            replyTo: this.replyTo,
            replyToSessionId: this.replyToSessionId,
            scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,
            sessionId: this.sessionId,
            timeToLive: this.timeToLive,
            to: this.to,
            applicationProperties: this.applicationProperties,
            // Will be required later for implementing Transactions
            // viaPartitionKey: this.viaPartitionKey
        };
        return clone;
    }
}
/**
 * Converts any Date objects into a number representing date.getTime().
 * Recursively checks for any Date objects in arrays and objects.
 * @internal
 */
function convertDatesToNumbers(thing) {
    // fast exit
    if (!coreUtil.isDefined(thing))
        return thing;
    // When 'thing' is a Date, return the number representation
    if (typeof thing === "object" &&
        coreUtil.isObjectWithProperties(thing, ["getTime"]) &&
        typeof thing.getTime === "function") {
        return thing.getTime();
    }
    /*
      Examples:
      [0, 'foo', new Date(), { nested: new Date()}]
    */
    if (Array.isArray(thing)) {
        const result = [];
        for (const element of thing) {
            result.push(convertDatesToNumbers(element));
        }
        return result;
    }
    /*
      Examples:
      { foo: new Date(), children: { nested: new Date() }}
    */
    if (typeof thing === "object" && coreUtil.isDefined(thing)) {
        const thingShallowCopy = { ...thing };
        for (const key of Object.keys(thingShallowCopy)) {
            thingShallowCopy[key] = convertDatesToNumbers(thingShallowCopy[key]);
        }
        return thingShallowCopy;
    }
    return thing;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Describes the base class for entities like MessageSender, MessageReceiver and Management client.
 */
class LinkEntity {
    get logPrefix() {
        return this._logPrefix;
    }
    /**
     * Creates a new ClientEntity instance.
     * @param baseName - The base name to use for the link. A unique ID will be appended to this.
     * @param entityPath - The entity path (ex: 'your-queue')
     * @param context - The connection context.
     * @param options - Options that can be provided while creating the LinkEntity.
     */
    constructor(baseName, entityPath, context, _linkType, _logger, options) {
        this.baseName = baseName;
        this.entityPath = entityPath;
        this._linkType = _linkType;
        this._logger = _logger;
        /**
         * Indicates that close() has been called on this link and
         * that it should not be allowed to reopen.
         */
        this._wasClosedPermanently = false;
        /**
         * A lock that ensures that opening and closing this
         * link properly cooperate.
         */
        this._openLock = `linkEntity-${rheaPromise.generate_uuid()}`;
        if (!options)
            options = {};
        this._context = context;
        this.address = options.address || "";
        this.audience = options.audience || "";
        this.name = getUniqueName(baseName);
        this._logPrefix = `[${context.connectionId}|${this._linkType}:${this.name}]`;
    }
    /**
     * Determines whether the AMQP link is open. If open then returns true else returns false.
     */
    isOpen() {
        const result = this._link ? this._link.isOpen() : false;
        this._logger.verbose(`${this._logPrefix} is open? ${result}`);
        return result;
    }
    /**
     * Initializes this LinkEntity, setting this._link with the result of  `createRheaLink`, which
     * is implemented by child classes.
     *
     * @returns A Promise that resolves when the link has been properly initialized
     * @throws `AbortError` if the link has been closed via 'close'
     */
    async initLink(options, abortSignal) {
        // we'll check that the connection isn't in the process of recycling (and if so, wait for it to complete)
        await this._context.readyToOpenLink();
        this._logger.verbose(`${this._logPrefix} Attempting to acquire lock token ${this._openLock} for initializing link`);
        return coreAmqp.defaultCancellableLock.acquire(this._openLock, () => {
            this._logger.verbose(`${this._logPrefix} Lock ${this._openLock} acquired for initializing link`);
            return this._initLinkImpl(options, abortSignal);
        }, {
            abortSignal: abortSignal,
            timeoutInMs: coreAmqp.Constants.defaultOperationTimeoutInMs,
        });
    }
    async _initLinkImpl(options, abortSignal) {
        const checkAborted = () => {
            if (abortSignal?.aborted) {
                this._link?.close();
                throw new abortController.AbortError(coreAmqp.StandardAbortMessage);
            }
        };
        const connectionId = this._context.connectionId;
        checkAborted();
        if (options.name) {
            this.name = options.name;
            this._logPrefix = `[${connectionId}|${this._linkType}:${this.name}]`;
        }
        if (this._wasClosedPermanently) {
            this._logger.verbose(`${this._logPrefix} Link has been permanently closed. Not reopening.`);
            throw new abortController.AbortError(`Link has been permanently closed. Not reopening.`);
        }
        if (this.isOpen()) {
            this._logger.verbose(`${this._logPrefix} Link is already open. Returning.`);
            return;
        }
        this._logger.verbose(`${this._logPrefix} Is not open and is not currently connecting. Opening.`);
        try {
            await this._negotiateClaim({
                abortSignal,
                setTokenRenewal: false,
                timeoutInMs: coreAmqp.Constants.defaultOperationTimeoutInMs,
            });
            checkAborted();
            this.checkIfConnectionReady();
            this._logger.verbose(`${this._logPrefix} Creating with options %O`, options);
            this._link = await this.createRheaLink(options);
            checkAborted();
            this._ensureTokenRenewal();
            this._logger.verbose(`${this._logPrefix} Link has been created.`);
        }
        catch (err) {
            this._logger.logError(err, `${this._logPrefix} Error thrown when creating the link`);
            await this.closeLinkImpl();
            throw err;
        }
    }
    /**
     * Clears token renewal for current link, removes current LinkEntity instance from cache,
     * and closes the underlying AMQP link.
     * Once closed, this instance of LinkEntity is not meant to be re-used.
     */
    async close() {
        // Set the flag to indicate that this instance of LinkEntity is not meant to be re-used.
        this._wasClosedPermanently = true;
        this._logger.verbose(`${this.logPrefix} permanently closing this link.`);
        this.removeLinkFromContext();
        await this.closeLink();
        this._logger.verbose(`${this.logPrefix} permanently closed this link.`);
    }
    /**
     * Closes the internally held rhea link, stops the token renewal timer and sets
     * the this._link field to undefined.
     */
    closeLink() {
        this._logger.verbose(`${this._logPrefix} Attempting to acquire lock token ${this._openLock} for closing link`);
        return coreAmqp.defaultCancellableLock.acquire(this._openLock, () => {
            this._logger.verbose(`${this._logPrefix} Lock ${this._openLock} acquired for closing link`);
            return this.closeLinkImpl();
        }, { abortSignal: undefined, timeoutInMs: undefined });
    }
    async closeLinkImpl() {
        this._logger.verbose(`${this._logPrefix} closeLinkImpl() called`);
        clearTimeout(this._tokenRenewalTimer);
        this._tokenRenewalTimer = undefined;
        if (this._link) {
            try {
                const link = this._link;
                this._link = undefined;
                // This should take care of closing the link and it's underlying session. This should also
                // remove them from the internal map.
                await link.close();
                this._logger.verbose(`${this._logPrefix} closed.`);
            }
            catch (err) {
                this._logger.logError(err, `${this._logPrefix} An error occurred while closing the link`);
            }
        }
    }
    /**
     * Provides the current type of the ClientEntity.
     * @returns The entity type.
     */
    get _type() {
        let result = "LinkEntity";
        if (this.constructor && this.constructor.name) {
            result = this.constructor.name;
        }
        return result;
    }
    get wasClosedPermanently() {
        return this._wasClosedPermanently;
    }
    get link() {
        return this._link;
    }
    /**
     * Negotiates the cbs claim for the ClientEntity.
     * @param setTokenRenewal - Set the token renewal timer. Default false.
     */
    async _negotiateClaim({ abortSignal, setTokenRenewal, timeoutInMs, }) {
        this._logger.verbose(`${this._logPrefix} negotiateclaim() has been called`);
        // Wait for the connectionContext to be ready to open the link.
        this.checkIfConnectionReady();
        // Acquire the lock and establish a cbs session if it does not exist on the connection.
        // Although node.js is single threaded, we need a locking mechanism to ensure that a
        // race condition does not happen while creating a shared resource (in this case the
        // cbs session, since we want to have exactly 1 cbs session per connection).
        this._logger.verbose("%s Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: " +
            "'%s' with address: '%s'.", this.logPrefix, this._context.cbsSession.cbsLock, this._type, this.name, this.address);
        const startTime = Date.now();
        if (!this._context.cbsSession.isOpen()) {
            await coreAmqp.defaultCancellableLock.acquire(this._context.cbsSession.cbsLock, () => {
                this.checkIfConnectionReady();
                return this._context.cbsSession.init({ abortSignal, timeoutInMs });
            }, {
                abortSignal,
                timeoutInMs: timeoutInMs - (Date.now() - startTime),
            });
        }
        let tokenObject;
        let tokenType;
        if (coreAmqp.isSasTokenProvider(this._context.tokenCredential)) {
            tokenObject = await this._context.tokenCredential.getToken(this.audience);
            tokenType = coreAmqp.TokenType.CbsTokenTypeSas;
            // renew sas token in every 45 minutes
            this._tokenTimeout = (3600 - 900) * 1000;
        }
        else {
            const aadToken = await this._context.tokenCredential.getToken(coreAmqp.Constants.aadServiceBusScope);
            if (!aadToken) {
                throw new Error(`Failed to get token from the provided "TokenCredential" object`);
            }
            tokenObject = aadToken;
            tokenType = coreAmqp.TokenType.CbsTokenTypeJwt;
            this._tokenTimeout = tokenObject.expiresOnTimestamp - Date.now() - 2 * 60 * 1000;
        }
        this._logger.verbose("%s %s: calling negotiateClaim for audience '%s'.", this.logPrefix, this._type, this.audience);
        // Acquire the lock to negotiate the CBS claim.
        this._logger.verbose("%s Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this.logPrefix, this._context.negotiateClaimLock, this._type, this.name, this.address);
        if (!tokenObject) {
            throw new Error("Token cannot be null");
        }
        await coreAmqp.defaultCancellableLock.acquire(this._context.negotiateClaimLock, () => {
            this.checkIfConnectionReady();
            return this._context.cbsSession.negotiateClaim(this.audience, tokenObject.token, tokenType, {
                abortSignal,
                timeoutInMs: timeoutInMs - (Date.now() - startTime),
            });
        }, {
            abortSignal,
            timeoutInMs: timeoutInMs - (Date.now() - startTime),
        });
        this._logger.verbose("%s Negotiated claim for %s '%s' with with address: %s", this.logPrefix, this._type, this.name, this.address);
        if (setTokenRenewal) {
            this._ensureTokenRenewal();
        }
    }
    /**
     * Checks to see if the connection is in a "reopening" state. If it is
     * we need to _not_ use it otherwise we'll trigger some race conditions
     * within rhea (for instance, errors about _process not being defined).
     */
    checkIfConnectionReady() {
        if (!this._context.isConnectionClosing()) {
            return;
        }
        this._logger.verbose(`${this._logPrefix} Connection is reopening, aborting link initialization.`);
        const err = new ServiceBusError("Connection is reopening, aborting link initialization.", "GeneralError");
        err.retryable = true;
        throw err;
    }
    /**
     * Ensures that the token is renewed within the predefined renewal margin.
     */
    _ensureTokenRenewal() {
        if (!this._tokenTimeout) {
            return;
        }
        // Clear the existing token renewal timer.
        // This scenario can happen if the connection goes down and is brought back up
        // before the `nextRenewalTimeout` was reached.
        if (this._tokenRenewalTimer) {
            clearTimeout(this._tokenRenewalTimer);
        }
        this._tokenRenewalTimer = setTimeout(async () => {
            try {
                await this._negotiateClaim({
                    setTokenRenewal: true,
                    abortSignal: undefined,
                    timeoutInMs: coreAmqp.Constants.defaultOperationTimeoutInMs,
                });
            }
            catch (err) {
                this._logger.logError(err, "%s %s '%s' with address %s, an error occurred while renewing the token", this.logPrefix, this._type, this.name, this.address);
            }
        }, this._tokenTimeout);
        this._logger.verbose("%s %s '%s' with address %s, has next token renewal in %d milliseconds @(%s).", this.logPrefix, this._type, this.name, this.address, this._tokenTimeout, new Date(Date.now() + this._tokenTimeout).toString());
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Error message to use when EntityPath in connection string does not match the
 * queue or topic name passed to the methods in the ServiceBusClient that create
 * senders and receivers.
 *
 * @internal
 */
const entityPathMisMatchError = "The queue or topic name provided does not match the EntityPath in the connection string passed to the ServiceBusClient constructor.";
/**
 * Error message for when maxMessageCount provided is invalid.
 *
 * @internal
 */
const InvalidMaxMessageCountError = "'maxMessageCount' must be a number greater than 0.";
/**
 * @internal
 * Logs and throws Error if the current AMQP connection is closed.
 * @param context - The ConnectionContext associated with the current AMQP connection.
 */
function throwErrorIfConnectionClosed(context) {
    if (context && context.wasConnectionCloseCalled) {
        const errorMessage = "The underlying AMQP connection is closed.";
        const error = new Error(errorMessage);
        logger.warning(`[${context.connectionId}] %O`, error);
        throw error;
    }
}
/**
 * @internal
 * Gets the error message when a sender is used when its already closed
 * @param entityPath - Value of the `entityPath` property on the client which denotes its name
 */
function getSenderClosedErrorMsg(entityPath) {
    return (`The sender for "${entityPath}" has been closed and can no longer be used. ` +
        `Please create a new sender using the "createSender" method on the ServiceBusClient.`);
}
/**
 * @internal
 * Gets the error message when a receiver is used when its already closed
 * @param entityPath - Value of the `entityPath` property on the client which denotes its name
 * @param sessionId - If using session receiver, then the id of the session
 */
function getReceiverClosedErrorMsg(entityPath, sessionId) {
    if (!coreUtil.isDefined(sessionId)) {
        return (`The receiver for "${entityPath}" has been closed and can no longer be used. ` +
            `Please create a new receiver using the "createReceiver" method on the ServiceBusClient.`);
    }
    return (`The receiver for session "${sessionId}" in "${entityPath}" has been closed and can no ` +
        `longer be used. Please create a new receiver using the "acceptSession" or "acceptNextSession" method on the ServiceBusClient.`);
}
/**
 * @internal
 * @param entityPath - Value of the `entityPath` property on the client which denotes its name
 * @param sessionId - If using session receiver, then the id of the session
 */
function getAlreadyReceivingErrorMsg(entityPath, sessionId) {
    if (!coreUtil.isDefined(sessionId)) {
        return `The receiver for "${entityPath}" is already receiving messages.`;
    }
    return `The receiver for session "${sessionId}" for "${entityPath}" is already receiving messages.`;
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is undefined or null
 * @param connectionId - Id of the underlying AMQP connection used for logging
 * @param parameterName - Name of the parameter to check
 * @param parameterValue - Value of the parameter to check
 */
function throwTypeErrorIfParameterMissing(connectionId, parameterName, parameterValue) {
    if (parameterValue === undefined || parameterValue === null) {
        const error = new TypeError(`Missing parameter "${parameterName}"`);
        logger.warning(`[${connectionId}] %O`, error);
        throw error;
    }
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is not an instance of expected type
 * @param connectionId - Id of the underlying AMQP connection used for logging
 * @param parameterName - Name of the parameter to type check
 * @param parameterValue - Value of the parameter to type check
 * @param constructor - Constructor function of the expected parameter type
 */
function throwTypeErrorIfNotInstanceOfParameterType(connectionId, parameterName, parameterValue, 
// eslint-disable-next-line @typescript-eslint/ban-types
constructor) {
    if (!(parameterValue instanceof constructor)) {
        const error = new TypeError(`The parameter "${parameterName}" should be an instance of "${constructor.name}"`);
        logger.warning(`[${connectionId}] %O`, error);
        throw error;
    }
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is not of expected type
 * @param connectionId - Id of the underlying AMQP connection used for logging
 * @param parameterName - Name of the parameter to type check
 * @param parameterValue - Value of the parameter to type check
 * @param expectedType - Expected type of the parameter
 */
function throwTypeErrorIfParameterTypeMismatch(connectionId, parameterName, parameterValue, expectedType) {
    if (typeof parameterValue !== expectedType) {
        const error = new TypeError(`The parameter "${parameterName}" should be of type "${expectedType}"`);
        logger.warning(`[${connectionId}] %O`, error);
        throw error;
    }
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is not of type `Long` or an array of type `Long`
 * @param connectionId - Id of the underlying AMQP connection used for logging
 * @param parameterName - Name of the parameter to type check
 * @param parameterValue - Value of the parameter to type check
 */
function throwTypeErrorIfParameterNotLong(connectionId, parameterName, parameterValue) {
    if (Array.isArray(parameterValue)) {
        return throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue);
    }
    if (Long.isLong(parameterValue)) {
        return;
    }
    const error = new TypeError(`The parameter "${parameterName}" should be of type "Long"`);
    logger.warning(`[${connectionId}] %O`, error);
    throw error;
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is not an array of type `Long`
 * @param connectionId - Id of the underlying AMQP connection used for logging
 * @param parameterName - Name of the parameter to type check
 * @param parameterValue - Value of the parameter to type check
 */
function throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue) {
    if (parameterValue.every((item) => Long.isLong(item))) {
        return;
    }
    const error = new TypeError(`The parameter "${parameterName}" should be an array of type "Long"`);
    logger.warning(`[${connectionId}] %O`, error);
    throw error;
}
/**
 * @internal
 * Logs and Throws TypeError if given parameter is an empty string
 * @param connectionId - Id of the underlying AMQP connection used for logging
 * @param parameterName - Name of the parameter to type check
 * @param parameterValue - Value of the parameter to type check
 */
function throwTypeErrorIfParameterIsEmptyString(connectionId, parameterName, parameterValue) {
    if (parameterValue !== "") {
        return;
    }
    const error = new TypeError(`Empty string not allowed in parameter "${parameterName}"`);
    logger.warning(`[${connectionId}] %O`, error);
    throw error;
}
/**
 * @internal
 * The error message for operations on the receiver that are invalid for a message received in receiveAndDelete mode.
 */
const InvalidOperationInReceiveAndDeleteMode = "The operation is not supported in 'receiveAndDelete' receive mode.";
/**
 * @internal
 * The error message for operations on the receiver that are invalid for a peeked message.
 */
const InvalidOperationForPeekedMessage = "This operation is not supported for peeked messages. Only messages received using 'receiveMessages()', 'subscribe()' and 'getMessageIterator()' methods on the receiver in 'peekLock' receive mode can be settled.";
/**
 * @internal
 * The error message for when one attempts to settle an already settled message.
 */
const MessageAlreadySettled = "The message has either been deleted or already settled";
/**
 * Throws error if the ServiceBusReceivedMessage cannot be settled.
 * @internal
 */
function throwErrorIfInvalidOperationOnMessage(message, receiveMode, connectionId) {
    let error;
    if (receiveMode === "receiveAndDelete") {
        error = new Error(InvalidOperationInReceiveAndDeleteMode);
    }
    else if (!message.lockToken) {
        error = new Error(InvalidOperationForPeekedMessage);
    }
    if (error) {
        receiverLogger.logError(error, "[%s] An error occurred for message with id '%s'", connectionId, message.messageId);
        throw error;
    }
}
/**
 * Error message for when the ServiceBusMessage provided by the user has different values
 * for partitionKey and sessionId.
 * @internal
 */
const PartitionKeySessionIdMismatchError = "The fields 'partitionKey' and 'sessionId' cannot have different values.";
/**
 * Throws error if the given object is not a valid ServiceBusMessage
 * @internal
 * @param msg - The object that needs to be validated as a ServiceBusMessage
 * @param errorMessageForWrongType - The error message to use when given object is not a ServiceBusMessage
 */
function throwIfNotValidServiceBusMessage(msg, errorMessageForWrongType) {
    if (!isServiceBusMessage(msg) && !isAmqpAnnotatedMessage(msg)) {
        throw new TypeError(errorMessageForWrongType);
    }
    if (isServiceBusMessage(msg)) {
        if (msg.partitionKey && msg.sessionId && msg.partitionKey !== msg.sessionId) {
            throw new TypeError(PartitionKeySessionIdMismatchError);
        }
    }
}
/** @internal */
const errorInvalidMessageTypeSingleOrArray = "Provided value for 'messages' must be of type: ServiceBusMessage, AmqpAnnotatedMessage, ServiceBusMessageBatch or an array of type ServiceBusMessage or AmqpAnnotatedMessage.";
/** @internal */
const errorInvalidMessageTypeSingle = "Provided value for 'message' must be of type: ServiceBusMessage or AmqpAnnotatedMessage.";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
const sqlRuleProperties = ["sqlExpression"];
function isSqlRuleFilter(obj) {
    if (obj) {
        return sqlRuleProperties.some((validProperty) => coreUtil.isObjectWithProperties(obj, [validProperty]));
    }
    return false;
}
/**
 * @internal
 */
const correlationProperties = [
    "correlationId",
    "messageId",
    "to",
    "replyTo",
    "subject",
    "sessionId",
    "replyToSessionId",
    "contentType",
    "applicationProperties",
];
function isCorrelationRuleFilter(obj) {
    if (obj) {
        return correlationProperties.some((validProperty) => coreUtil.isObjectWithProperties(obj, [validProperty]));
    }
    return false;
}
/**
 * @internal
 * Describes the ServiceBus Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
class ManagementClient extends LinkEntity {
    /**
     * Instantiates the management client.
     * @param context - The connection context
     * @param entityPath - The name/path of the entity (queue/topic/subscription name)
     * for which the management request needs to be made.
     * @param options - Options to be provided for creating the
     * "$management" client.
     */
    constructor(context, entityPath, options) {
        super(`${entityPath}/$management`, entityPath, context, "mgmt", managementClientLogger, {
            address: options && options.address ? options.address : coreAmqp.Constants.management,
            audience: options && options.audience
                ? options.audience
                : `${context.config.endpoint}${entityPath}/$management`,
        });
        /**
         * The reply to Guid for the management client.
         */
        this.replyTo = rheaPromise.generate_uuid();
        /**
         * Provides the sequence number of the last peeked message.
         */
        this._lastPeekedSequenceNumber = Long.ZERO;
        /**
         * lock token for init operation
         */
        this._initLock = `initMgmtLink-${rheaPromise.generate_uuid()}`;
        this._context = context;
    }
    /**
     * initialize link with unique this.replyTo address.
     * @param options -
     * @returns updated options bag that has adjusted `timeoutInMs` to account for init time
     */
    async initWithUniqueReplyTo(options = {}) {
        const retryTimeoutInMs = options.timeoutInMs ?? coreAmqp.Constants.defaultOperationTimeoutInMs;
        const initOperationStartTime = Date.now();
        return coreAmqp.defaultCancellableLock.acquire(this._initLock, async () => {
            managementClientLogger.verbose(`${this.logPrefix} lock acquired for initializing replyTo address and link`);
            if (!this.isOpen()) {
                this.replyTo = rheaPromise.generate_uuid();
                managementClientLogger.verbose(`${this.logPrefix} new replyTo address: ${this.replyTo} generated`);
            }
            const { abortSignal } = options ?? {};
            const aborter = new abortController.AbortController();
            const { signal } = new abortController.AbortController([
                aborter.signal,
                ...(abortSignal ? [abortSignal] : []),
            ]);
            if (!this.isOpen()) {
                await Promise.race([
                    this._init(signal),
                    coreUtil.delay(retryTimeoutInMs, { abortSignal: aborter.signal }).then(() => {
                        throw {
                            name: "OperationTimeoutError",
                            message: "The management request timed out. Please try again later.",
                        };
                    }),
                ]).finally(() => aborter.abort());
            }
            // time taken by the init operation
            const timeTakenByInit = Date.now() - initOperationStartTime;
            return {
                ...options,
                // Left over time
                timeoutInMs: retryTimeoutInMs - timeTakenByInit,
            };
        }, {
            abortSignal: options.abortSignal,
            timeoutInMs: retryTimeoutInMs,
        });
    }
    async _init(abortSignal) {
        throwErrorIfConnectionClosed(this._context);
        try {
            const rxopt = {
                source: { address: this.address },
                name: this.replyTo,
                target: { address: this.replyTo },
                onSessionError: (context) => {
                    const sbError = translateServiceBusError(context.session.error);
                    managementClientLogger.logError(sbError, `${this.logPrefix} An error occurred on the session for request/response links for $management`);
                },
            };
            const sropt = {
                target: { address: this.address },
                onError: (context) => {
                    const ehError = translateServiceBusError(context.sender.error);
                    managementClientLogger.logError(ehError, `${this.logPrefix} An error occurred on the $management sender link`);
                },
            };
            // Even if multiple parallel requests reach here, the initLink secures a lock
            // to ensure there won't be multiple initializations
            await this.initLink({
                senderOptions: sropt,
                receiverOptions: rxopt,
            }, abortSignal);
        }
        catch (err) {
            const translatedError = translateServiceBusError(err);
            managementClientLogger.logError(translatedError, `${this.logPrefix} An error occurred while establishing the $management links`);
            throw translatedError;
        }
    }
    async createRheaLink(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        const rheaLink = await coreAmqp.RequestResponseLink.create(this._context.connection, options.senderOptions, options.receiverOptions);
        // Attach listener for the `receiver_error` events to log the errors.
        // "message" event listener is added in core-amqp.
        // "rhea" doesn't allow setting only the "onError" handler in the options if it is not accompanied by an "onMessage" handler.
        // Hence, not passing onError handler in the receiver options, adding a handler below.
        rheaLink.receiver.on(rheaPromise.ReceiverEvents.receiverError, (context) => {
            const ehError = translateServiceBusError(context.receiver.error);
            managementClientLogger.logError(ehError, `${this.logPrefix} An error occurred on the $management receiver link`);
        });
        return rheaLink;
    }
    /**
     * Given array of typed values, returns the element in given index
     */
    _safelyGetTypedValueFromArray(data, index) {
        return Array.isArray(data) && data.length > index && data[index]
            ? data[index].value
            : undefined;
    }
    _decodeApplicationPropertiesMap(obj) {
        if (!rheaPromise.types.is_map(obj)) {
            throw new Error("object to decode is not of Map types");
        }
        const array = obj.value;
        const result = {};
        for (let i = 0; i < array.length; i += 2) {
            const key = array[i].value;
            result[key] = array[i + 1].value;
        }
        return result;
    }
    async _makeManagementRequest(request, internalLogger, sendRequestOptions = {}) {
        if (request.message_id === undefined) {
            request.message_id = rheaPromise.generate_uuid();
        }
        try {
            const { timeoutInMs } = sendRequestOptions;
            await waitForSendable(internalLogger, this.logPrefix, this.name, timeoutInMs ?? coreAmqp.Constants.defaultOperationTimeoutInMs, this.link?.sender, this.link?.session?.outgoing?.available());
            return await this.link.sendRequest(request, sendRequestOptions);
        }
        catch (err) {
            const translatedError = translateServiceBusError(err);
            internalLogger.logError(translatedError, "%s An error occurred during send on management request-response link with address '%s'", this.logPrefix, this.address);
            throw translatedError;
        }
    }
    /**
     * Closes the AMQP management session to the ServiceBus namespace for this client,
     * returning a promise that will be resolved when disconnection is completed.
     */
    async close() {
        try {
            // Always clear the timeout, as the isOpen check may report
            // false without ever having cleared the timeout otherwise.
            // NOTE: management link currently doesn't have a separate concept of "detaching" like
            // the other links do. When we add handling of this (via the onDetached call, like other links)
            // we can change this back to closeLink("permanent").
            await this.closeLink();
            managementClientLogger.verbose("Successfully closed the management session.");
        }
        catch (err) {
            managementClientLogger.logError(err, `${this.logPrefix} An error occurred while closing the management session`);
            throw err;
        }
    }
    /**
     * Fetches the next batch of active messages. The first call to `peek()` fetches the first
     * active message for this client. Each subsequent call fetches the subsequent message in the
     * entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`. This method will
     * also fetch even Deferred messages (but not Deadlettered message).
     *
     * @param messageCount - The number of messages to retrieve. Default value `1`.
     * @param omitMessageBody - Whether to omit message body when peeking. Default value `false`.
     */
    async peek(messageCount, omitMessageBody, options) {
        throwErrorIfConnectionClosed(this._context);
        return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, undefined, omitMessageBody, options);
    }
    /**
     * Fetches the next batch of active messages in the current MessageSession. The first call to
     * `peek()` fetches the first active message for this client. Each subsequent call fetches the
     * subsequent message in the entity.
     *
     * Unlike a `received` message, `peeked` message will not have lock token associated with it,
     * and hence it cannot be `Completed/Abandoned/Deferred/Deadlettered/Renewed`.  This method will
     * also fetch even Deferred messages (but not Deadlettered message).
     *
     * @param sessionId - The sessionId from which messages need to be peeked.
     * @param messageCount - The number of messages to retrieve. Default value `1`.
     * @param omitMessageBody - Whether to omit message body when peeking Default value `false`.
     */
    async peekMessagesBySession(sessionId, messageCount, omitMessageBody, options) {
        throwErrorIfConnectionClosed(this._context);
        return this.peekBySequenceNumber(this._lastPeekedSequenceNumber.add(1), messageCount, sessionId, omitMessageBody, options);
    }
    /**
     * Peeks the desired number of messages from the specified sequence number.
     *
     * @param fromSequenceNumber - The sequence number from where to read the message.
     * @param messageCount - The number of messages to retrieve. Default value `1`.
     * @param sessionId - The sessionId from which messages need to be peeked.
     * @param omitMessageBody - Whether to omit message body when peeking. Default value `false`.
     */
    async peekBySequenceNumber(fromSequenceNumber, maxMessageCount, sessionId, omitMessageBody, options) {
        throwErrorIfConnectionClosed(this._context);
        const connId = this._context.connectionId;
        // Checks for fromSequenceNumber
        throwTypeErrorIfParameterMissing(connId, "fromSequenceNumber", fromSequenceNumber);
        throwTypeErrorIfParameterNotLong(connId, "fromSequenceNumber", fromSequenceNumber);
        // Checks for maxMessageCount
        throwTypeErrorIfParameterMissing(this._context.connectionId, "maxMessageCount", maxMessageCount);
        throwTypeErrorIfParameterTypeMismatch(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
        if (isNaN(maxMessageCount) || maxMessageCount < 1) {
            throw new TypeError(InvalidMaxMessageCountError);
        }
        const messageList = [];
        try {
            const messageBody = {};
            messageBody[coreAmqp.Constants.fromSequenceNumber] = rheaPromise.types.wrap_long(buffer.Buffer.from(fromSequenceNumber.toBytesBE()));
            messageBody[coreAmqp.Constants.messageCount] = rheaPromise.types.wrap_int(maxMessageCount);
            if (coreUtil.isDefined(sessionId)) {
                messageBody[coreAmqp.Constants.sessionIdMapKey] = sessionId;
            }
            if (coreUtil.isDefined(omitMessageBody)) {
                const omitMessageBodyKey = "omit-message-body"; // TODO: Service Bus specific. Put it somewhere
                messageBody[omitMessageBodyKey] = rheaPromise.types.wrap_boolean(omitMessageBody);
            }
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.peekMessage,
                },
            };
            if (updatedOptions?.associatedLinkName) {
                request.application_properties[coreAmqp.Constants.associatedLinkName] =
                    updatedOptions?.associatedLinkName;
            }
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            // TODO: it'd be nice to attribute this peek request to the actual receiver that made it. So have them pass in a
            // log prefix rather than just falling back to the management links.
            receiverLogger.verbose("%s Peek by sequence number request body: %O.", this.logPrefix, request.body);
            const result = await this._makeManagementRequest(request, receiverLogger, updatedOptions);
            if (result.application_properties.statusCode !== 204) {
                const messages = result.body.messages;
                for (const msg of messages) {
                    const decodedMessage = rheaPromise.message.decode(msg.message);
                    const message = fromRheaMessage(decodedMessage, {
                        skipParsingBodyAsJson: updatedOptions?.skipParsingBodyAsJson ?? false,
                        skipConvertingDate: updatedOptions?.skipConvertingDate ?? false,
                    });
                    messageList.push(message);
                    this._lastPeekedSequenceNumber = message.sequenceNumber;
                }
            }
        }
        catch (err) {
            const error = translateServiceBusError(err);
            receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to peek messages to $management endpoint`);
            // statusCode == 404 then do not throw
            if (error.code !== coreAmqp.ConditionErrorNameMapper["com.microsoft:message-not-found"]) {
                throw error;
            }
        }
        return messageList;
    }
    /**
     * Renews the lock on the message. The lock will be renewed based on the setting specified on
     * the queue.
     *
     * When a message is received in `PeekLock` mode, the message is locked on the server for this
     * receiver instance for a duration as specified during the Queue/Subscription creation
     * (LockDuration). If processing of the message requires longer than this duration, the
     * lock needs to be renewed. For each renewal, it resets the time the message is locked by the
     * LockDuration set on the Entity.
     *
     * @param lockToken - Lock token of the message
     * @param options - Options that can be set while sending the request.
     * @returns New lock token expiry date and time in UTC format.
     */
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    async renewLock(lockToken, options) {
        throwErrorIfConnectionClosed(this._context);
        if (!options)
            options = {};
        if (options.timeoutInMs == null)
            options.timeoutInMs = 5000;
        try {
            const messageBody = {};
            messageBody[coreAmqp.Constants.lockTokens] = rheaPromise.types.wrap_array([rheaPromise.string_to_uuid(lockToken)], 0x98, undefined);
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.renewLock,
                },
            };
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            if (updatedOptions.associatedLinkName) {
                request.application_properties[coreAmqp.Constants.associatedLinkName] =
                    updatedOptions.associatedLinkName;
            }
            receiverLogger.verbose("[%s] Renew message Lock request: %O.", this._context.connectionId, request);
            const result = await this._makeManagementRequest(request, receiverLogger, {
                abortSignal: updatedOptions?.abortSignal,
                requestName: "renewLock",
            });
            const lockedUntilUtc = new Date(result.body.expirations[0]);
            return lockedUntilUtc;
        }
        catch (err) {
            const error = translateServiceBusError(err);
            receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Schedules an array of messages to appear on Service Bus at a later time.
     *
     * @param scheduledEnqueueTimeUtc - The UTC time at which the messages should be enqueued.
     * @param messages - An array of messages that needs to be scheduled.
     * @returns The sequence numbers of messages that were scheduled.
     */
    async scheduleMessages(scheduledEnqueueTimeUtc, messages, options) {
        throwErrorIfConnectionClosed(this._context);
        if (!messages.length) {
            return [];
        }
        const messageBody = [];
        for (let i = 0; i < messages.length; i++) {
            const item = messages[i];
            try {
                const rheaMessage = toRheaMessage(item, defaultDataTransformer);
                updateMessageId(rheaMessage, rheaMessage.message_id || rheaPromise.generate_uuid());
                updateScheduledTime(rheaMessage, scheduledEnqueueTimeUtc);
                const entry = {
                    message: rheaPromise.message.encode(rheaMessage),
                    "message-id": rheaMessage.message_id,
                };
                if (rheaMessage.group_id) {
                    entry[coreAmqp.Constants.sessionIdMapKey] = rheaMessage.group_id;
                }
                if (rheaMessage.message_annotations?.[coreAmqp.Constants.partitionKey]) {
                    entry["partition-key"] = rheaMessage.message_annotations[coreAmqp.Constants.partitionKey];
                }
                // Will be required later for implementing Transactions
                // if (item.viaPartitionKey) {
                //   entry["via-partition-key"] = item.viaPartitionKey;
                // }
                const wrappedEntry = rheaPromise.types.wrap_map(entry);
                messageBody.push(wrappedEntry);
            }
            catch (err) {
                const error = translateServiceBusError(err);
                senderLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the messages array`);
                throw error;
            }
        }
        const updatedOptions = await this.initWithUniqueReplyTo(options);
        try {
            const request = {
                body: { messages: messageBody },
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.scheduleMessage,
                },
            };
            if (updatedOptions?.associatedLinkName) {
                request.application_properties[coreAmqp.Constants.associatedLinkName] =
                    updatedOptions?.associatedLinkName;
            }
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            senderLogger.verbose("%s Schedule messages request body: %O.", this.logPrefix, request.body);
            const result = await this._makeManagementRequest(request, senderLogger, updatedOptions);
            const sequenceNumbers = result.body[coreAmqp.Constants.sequenceNumbers];
            const sequenceNumbersAsLong = [];
            for (let i = 0; i < sequenceNumbers.length; i++) {
                if (typeof sequenceNumbers[i] === "number") {
                    sequenceNumbersAsLong.push(Long.fromNumber(sequenceNumbers[i]));
                }
                else {
                    sequenceNumbersAsLong.push(Long.fromBytesBE(sequenceNumbers[i]));
                }
            }
            return sequenceNumbersAsLong;
        }
        catch (err) {
            const error = translateServiceBusError(err);
            senderLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to schedule messages to $management endpoint`);
            throw error;
        }
    }
    /**
     * Cancels an array of messages that were scheduled.
     * @param sequenceNumbers - An Array of sequence numbers of the message to be cancelled.
     */
    async cancelScheduledMessages(sequenceNumbers, options) {
        throwErrorIfConnectionClosed(this._context);
        if (!sequenceNumbers.length) {
            return;
        }
        const messageBody = {};
        messageBody[coreAmqp.Constants.sequenceNumbers] = [];
        for (let i = 0; i < sequenceNumbers.length; i++) {
            const sequenceNumber = sequenceNumbers[i];
            try {
                messageBody[coreAmqp.Constants.sequenceNumbers].push(buffer.Buffer.from(sequenceNumber.toBytesBE()));
            }
            catch (err) {
                const error = translateServiceBusError(err);
                senderLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`);
                throw error;
            }
        }
        try {
            messageBody[coreAmqp.Constants.sequenceNumbers] = rheaPromise.types.wrap_array(messageBody[coreAmqp.Constants.sequenceNumbers], 0x81, undefined);
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.cancelScheduledMessage,
                },
            };
            if (updatedOptions?.associatedLinkName) {
                request.application_properties[coreAmqp.Constants.associatedLinkName] =
                    updatedOptions?.associatedLinkName;
            }
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            senderLogger.verbose("%s Cancel scheduled messages request body: %O.", this.logPrefix, request.body);
            await this._makeManagementRequest(request, senderLogger, updatedOptions);
            return;
        }
        catch (err) {
            const error = translateServiceBusError(err);
            senderLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to cancel the scheduled message to $management endpoint`);
            throw error;
        }
    }
    /**
     * Receives a list of deferred messages identified by `sequenceNumbers`.
     *
     * @param sequenceNumbers - A list containing the sequence numbers to receive.
     * @param receiveMode - The mode in which the receiver was created.
     * @returns a list of messages identified by the given sequenceNumbers or an empty list if no messages are found.
     * - Throws an error if the messages have not been deferred.
     */
    async receiveDeferredMessages(sequenceNumbers, receiveMode, sessionId, options) {
        throwErrorIfConnectionClosed(this._context);
        if (!sequenceNumbers.length) {
            return [];
        }
        const messageList = [];
        const messageBody = {};
        messageBody[coreAmqp.Constants.sequenceNumbers] = [];
        for (let i = 0; i < sequenceNumbers.length; i++) {
            const sequenceNumber = sequenceNumbers[i];
            try {
                messageBody[coreAmqp.Constants.sequenceNumbers].push(buffer.Buffer.from(sequenceNumber.toBytesBE()));
            }
            catch (err) {
                const error = translateServiceBusError(err);
                receiverLogger.logError(error, `${this.logPrefix} An error occurred while encoding the item at position ${i} in the sequenceNumbers array`);
                throw error;
            }
        }
        try {
            messageBody[coreAmqp.Constants.sequenceNumbers] = rheaPromise.types.wrap_array(messageBody[coreAmqp.Constants.sequenceNumbers], 0x81, undefined);
            const receiverSettleMode = receiveMode === "receiveAndDelete" ? 0 : 1;
            messageBody[coreAmqp.Constants.receiverSettleMode] = rheaPromise.types.wrap_uint(receiverSettleMode);
            if (sessionId != null) {
                messageBody[coreAmqp.Constants.sessionIdMapKey] = sessionId;
            }
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.receiveBySequenceNumber,
                },
            };
            if (updatedOptions?.associatedLinkName) {
                request.application_properties[coreAmqp.Constants.associatedLinkName] =
                    updatedOptions?.associatedLinkName;
            }
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            receiverLogger.verbose("%s Receive deferred messages request body: %O.", this.logPrefix, request.body);
            const result = await this._makeManagementRequest(request, receiverLogger, updatedOptions);
            const messages = result.body.messages;
            for (const msg of messages) {
                const decodedMessage = rheaPromise.message.decode(msg.message);
                const message = new ServiceBusMessageImpl(decodedMessage, { tag: msg["lock-token"] }, false, receiveMode, updatedOptions?.skipParsingBodyAsJson ?? false, false);
                messageList.push(message);
            }
            return messageList;
        }
        catch (err) {
            const error = translateServiceBusError(err);
            receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to receive deferred messages to $management endpoint`);
            throw error;
        }
    }
    /**
     * Updates the disposition status of deferred messages.
     *
     * @param lockTokens - Message lock tokens to update disposition status.
     * @param dispositionStatus - The disposition status to be set
     * @param options - Optional parameters that can be provided while updating the disposition status.
     */
    async updateDispositionStatus(lockToken, dispositionType, 
    // TODO: mgmt link retry<> will come in the next PR.
    options) {
        throwErrorIfConnectionClosed(this._context);
        if (!options)
            options = {};
        try {
            let dispositionStatus;
            if (dispositionType === DispositionType.abandon)
                dispositionStatus = "abandoned";
            else if (dispositionType === DispositionType.complete)
                dispositionStatus = "completed";
            else if (dispositionType === DispositionType.defer)
                dispositionStatus = "defered";
            else if (dispositionType === DispositionType.deadletter)
                dispositionStatus = "suspended";
            else
                throw new Error(`Provided "dispositionType" - ${dispositionType} is invalid`);
            const messageBody = {};
            const lockTokenBuffer = [];
            lockTokenBuffer.push(rheaPromise.string_to_uuid(lockToken));
            messageBody[coreAmqp.Constants.lockTokens] = rheaPromise.types.wrap_array(lockTokenBuffer, 0x98, undefined);
            messageBody[coreAmqp.Constants.dispositionStatus] = dispositionStatus;
            if (options.deadLetterDescription != null) {
                messageBody[coreAmqp.Constants.deadLetterDescription] = options.deadLetterDescription;
            }
            if (options.deadLetterReason != null) {
                messageBody[coreAmqp.Constants.deadLetterReason] = options.deadLetterReason;
            }
            if (options.propertiesToModify != null) {
                messageBody[coreAmqp.Constants.propertiesToModify] = options.propertiesToModify;
            }
            if (options.sessionId != null) {
                messageBody[coreAmqp.Constants.sessionIdMapKey] = options.sessionId;
            }
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.updateDisposition,
                },
            };
            if (updatedOptions.associatedLinkName) {
                request.application_properties[coreAmqp.Constants.associatedLinkName] =
                    updatedOptions.associatedLinkName;
            }
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            receiverLogger.verbose("%s Update disposition status request body: %O.", this.logPrefix, request.body);
            await this._makeManagementRequest(request, receiverLogger, updatedOptions);
        }
        catch (err) {
            const error = translateServiceBusError(err);
            receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the request to update disposition status to $management endpoint`);
            throw error;
        }
    }
    /**
     * Renews the lock for the specified session.
     *
     * @param sessionId - Id of the session for which the lock needs to be renewed
     * @param options - Options that can be set while sending the request.
     * @returns New lock token expiry date and time in UTC format.
     */
    async renewSessionLock(sessionId, options) {
        throwErrorIfConnectionClosed(this._context);
        try {
            const messageBody = {};
            messageBody[coreAmqp.Constants.sessionIdMapKey] = sessionId;
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.renewSessionLock,
                },
            };
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            if (updatedOptions?.associatedLinkName) {
                request.application_properties[coreAmqp.Constants.associatedLinkName] =
                    updatedOptions?.associatedLinkName;
            }
            receiverLogger.verbose("%s Renew Session Lock request body: %O.", this.logPrefix, request.body);
            const result = await this._makeManagementRequest(request, receiverLogger, updatedOptions);
            const lockedUntilUtc = new Date(result.body.expiration);
            receiverLogger.verbose("%s Lock for session '%s' will expire at %s.", this.logPrefix, sessionId, lockedUntilUtc.toString());
            return lockedUntilUtc;
        }
        catch (err) {
            const error = translateServiceBusError(err);
            receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Sets the state of the specified session.
     *
     * @param sessionId - The session for which the state needs to be set
     * @param state - The state that needs to be set.
     */
    async setSessionState(sessionId, state, options) {
        throwErrorIfConnectionClosed(this._context);
        try {
            const messageBody = {};
            messageBody[coreAmqp.Constants.sessionIdMapKey] = sessionId;
            messageBody["session-state"] = toBuffer(state);
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.setSessionState,
                },
            };
            if (updatedOptions?.associatedLinkName) {
                request.application_properties[coreAmqp.Constants.associatedLinkName] =
                    updatedOptions?.associatedLinkName;
            }
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            receiverLogger.verbose("%s Set Session state request body: %O.", this.logPrefix, request.body);
            await this._makeManagementRequest(request, receiverLogger, updatedOptions);
        }
        catch (err) {
            const error = translateServiceBusError(err);
            receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Gets the state of the specified session.
     *
     * @param sessionId - The session for which the state needs to be retrieved.
     * @returns The state of that session
     */
    async getSessionState(sessionId, options) {
        throwErrorIfConnectionClosed(this._context);
        try {
            const messageBody = {};
            messageBody[coreAmqp.Constants.sessionIdMapKey] = sessionId;
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.getSessionState,
                },
            };
            if (updatedOptions?.associatedLinkName) {
                request.application_properties[coreAmqp.Constants.associatedLinkName] =
                    updatedOptions?.associatedLinkName;
            }
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            receiverLogger.verbose("%s Get session state request body: %O.", this.logPrefix, request.body);
            const result = await this._makeManagementRequest(request, receiverLogger, updatedOptions);
            return result.body["session-state"]
                ? tryToJsonDecode(result.body["session-state"])
                : result.body["session-state"];
        }
        catch (err) {
            const error = translateServiceBusError(err);
            receiverLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Lists the sessions on the ServiceBus Queue/Topic.
     * @param lastUpdateTime - Filter to include only sessions updated after a given time.
     * @param skip - The number of sessions to skip
     * @param top - Maximum numer of sessions.
     * @returns A list of session ids.
     */
    async listMessageSessions(skip, top, lastUpdatedTime, options) {
        throwErrorIfConnectionClosed(this._context);
        const defaultLastUpdatedTimeForListingSessions = 259200000; // 3 * 24 * 3600 * 1000
        if (typeof skip !== "number") {
            throw new Error("'skip' is a required parameter and must be of type 'number'.");
        }
        if (typeof top !== "number") {
            throw new Error("'top' is a required parameter and must be of type 'number'.");
        }
        if (lastUpdatedTime && !(lastUpdatedTime instanceof Date)) {
            throw new Error("'lastUpdatedTime' must be of type 'Date'.");
        }
        if (!lastUpdatedTime) {
            lastUpdatedTime = new Date(Date.now() - defaultLastUpdatedTimeForListingSessions);
        }
        try {
            const messageBody = {};
            messageBody["last-updated-time"] = lastUpdatedTime;
            messageBody["skip"] = rheaPromise.types.wrap_int(skip);
            messageBody["top"] = rheaPromise.types.wrap_int(top);
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: messageBody,
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.enumerateSessions,
                },
            };
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            managementClientLogger.verbose("%s List sessions request body: %O.", this.logPrefix, request.body);
            const response = await this._makeManagementRequest(request, managementClientLogger, updatedOptions);
            return (response && response.body && response.body["sessions-ids"]) || [];
        }
        catch (err) {
            const error = translateServiceBusError(err);
            managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the renew lock request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Get all the rules on the Subscription.
     * @returns A list of rules.
     */
    async getRules(options) {
        throwErrorIfConnectionClosed(this._context);
        try {
            const updatedOptions = (await this.initWithUniqueReplyTo(options));
            const request = {
                body: {
                    top: updatedOptions?.maxCount
                        ? rheaPromise.types.wrap_int(updatedOptions.maxCount)
                        : rheaPromise.types.wrap_int(max32BitNumber),
                    skip: updatedOptions?.skip ? rheaPromise.types.wrap_int(updatedOptions.skip) : rheaPromise.types.wrap_int(0),
                },
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.enumerateRules,
                },
            };
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            managementClientLogger.verbose("%s Get rules request body: %O.", this.logPrefix, request.body);
            const response = await this._makeManagementRequest(request, managementClientLogger, updatedOptions);
            if (response.application_properties.statusCode === 204 ||
                !response.body ||
                !Array.isArray(response.body.rules)) {
                return [];
            }
            // Reference: https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-request-response#response-11
            const result = response.body.rules || [];
            const rules = [];
            result.forEach((x) => {
                const ruleDescriptor = x["rule-description"];
                let filter;
                // We use the first three elements of the `ruleDescriptor.value` to get filter, action, name
                if (!ruleDescriptor ||
                    !ruleDescriptor.descriptor ||
                    ruleDescriptor.descriptor.value !== coreAmqp.Constants.descriptorCodes.ruleDescriptionList ||
                    !Array.isArray(ruleDescriptor.value) ||
                    ruleDescriptor.value.length < 3) {
                    return;
                }
                const filtersRawData = ruleDescriptor.value[0];
                const actionsRawData = ruleDescriptor.value[1];
                let sqlRuleAction;
                if (actionsRawData.descriptor.value === coreAmqp.Constants.descriptorCodes.sqlRuleActionList &&
                    Array.isArray(actionsRawData.value) &&
                    actionsRawData.value.length) {
                    sqlRuleAction = {
                        sqlExpression: this._safelyGetTypedValueFromArray(actionsRawData.value, 0),
                    };
                }
                else {
                    sqlRuleAction = {};
                }
                switch (filtersRawData.descriptor.value) {
                    case coreAmqp.Constants.descriptorCodes.trueFilterList:
                        filter = {
                            sqlExpression: "1=1",
                        };
                        break;
                    case coreAmqp.Constants.descriptorCodes.falseFilterList:
                        filter = {
                            sqlExpression: "1=0",
                        };
                        break;
                    case coreAmqp.Constants.descriptorCodes.sqlFilterList:
                        filter = {
                            sqlExpression: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),
                        };
                        break;
                    case coreAmqp.Constants.descriptorCodes.correlationFilterList:
                        filter = {
                            correlationId: this._safelyGetTypedValueFromArray(filtersRawData.value, 0),
                            messageId: this._safelyGetTypedValueFromArray(filtersRawData.value, 1),
                            to: this._safelyGetTypedValueFromArray(filtersRawData.value, 2),
                            replyTo: this._safelyGetTypedValueFromArray(filtersRawData.value, 3),
                            subject: this._safelyGetTypedValueFromArray(filtersRawData.value, 4),
                            sessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 5),
                            replyToSessionId: this._safelyGetTypedValueFromArray(filtersRawData.value, 6),
                            contentType: this._safelyGetTypedValueFromArray(filtersRawData.value, 7),
                            applicationProperties: Array.isArray(filtersRawData.value) &&
                                filtersRawData.value.length > 8 &&
                                filtersRawData.value[8]
                                ? this._decodeApplicationPropertiesMap(filtersRawData.value[8])
                                : undefined,
                        };
                        break;
                    default:
                        throw new Error(`${this.logPrefix} Found unexpected descriptor code for the filter: ${filtersRawData.descriptor.value}`);
                }
                const rule = {
                    name: ruleDescriptor.value[2].value,
                    filter,
                    action: sqlRuleAction,
                };
                rules.push(rule);
            });
            return rules;
        }
        catch (err) {
            const error = translateServiceBusError(err);
            managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the get rules request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Removes the rule on the Subscription identified by the given rule name.
     */
    async removeRule(ruleName, options) {
        throwErrorIfConnectionClosed(this._context);
        throwTypeErrorIfParameterMissing(this._context.connectionId, "ruleName", ruleName);
        ruleName = String(ruleName);
        throwTypeErrorIfParameterIsEmptyString(this._context.connectionId, "ruleName", ruleName);
        try {
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: {
                    "rule-name": rheaPromise.types.wrap_string(ruleName),
                },
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.removeRule,
                },
            };
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            managementClientLogger.verbose("%s Remove Rule request body: %O.", this.logPrefix, request.body);
            await this._makeManagementRequest(request, managementClientLogger, updatedOptions);
        }
        catch (err) {
            const error = translateServiceBusError(err);
            managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the remove rule request to $management endpoint`);
            throw error;
        }
    }
    /**
     * Adds a rule on the subscription as defined by the given rule name, filter and action
     * @param ruleName - Name of the rule
     * @param filter - A Boolean, SQL expression or a Correlation filter
     * @param sqlRuleActionExpression - Action to perform if the message satisfies the filtering expression
     */
    async addRule(ruleName, filter, sqlRuleActionExpression, options) {
        throwErrorIfConnectionClosed(this._context);
        throwTypeErrorIfParameterMissing(this._context.connectionId, "ruleName", ruleName);
        ruleName = String(ruleName);
        throwTypeErrorIfParameterIsEmptyString(this._context.connectionId, "ruleName", ruleName);
        throwTypeErrorIfParameterMissing(this._context.connectionId, "filter", filter);
        if (!isSqlRuleFilter(filter) && !isCorrelationRuleFilter(filter)) {
            throw new TypeError(`The parameter "filter" should implement either the SqlRuleFilter or the CorrelationRuleFilter interface.`);
        }
        try {
            const ruleDescription = {};
            if (isSqlRuleFilter(filter)) {
                ruleDescription["sql-filter"] = {
                    expression: filter.sqlExpression,
                };
            }
            else {
                ruleDescription["correlation-filter"] = {
                    "correlation-id": filter.correlationId,
                    "message-id": filter.messageId,
                    to: filter.to,
                    "reply-to": filter.replyTo,
                    label: filter.subject,
                    "session-id": filter.sessionId,
                    "reply-to-session-id": filter.replyToSessionId,
                    "content-type": filter.contentType,
                    properties: filter.applicationProperties,
                };
            }
            if (sqlRuleActionExpression !== undefined) {
                ruleDescription["sql-rule-action"] = {
                    expression: String(sqlRuleActionExpression),
                };
            }
            const updatedOptions = await this.initWithUniqueReplyTo(options);
            const request = {
                body: {
                    "rule-name": rheaPromise.types.wrap_string(ruleName),
                    "rule-description": rheaPromise.types.wrap_map(ruleDescription),
                },
                reply_to: this.replyTo,
                application_properties: {
                    operation: coreAmqp.Constants.operations.addRule,
                },
            };
            request.application_properties[coreAmqp.Constants.trackingId] = rheaPromise.generate_uuid();
            managementClientLogger.verbose("%s Add Rule request body: %O.", this.logPrefix, request.body);
            await this._makeManagementRequest(request, managementClientLogger, updatedOptions);
        }
        catch (err) {
            const error = translateServiceBusError(err);
            managementClientLogger.logError(error, `${this.logPrefix} An error occurred while sending the Add rule request to $management endpoint`);
            throw error;
        }
    }
    removeLinkFromContext() {
        delete this._context.managementClients[this.name];
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Returns information about the platform this function is being run on.
 * @hidden
 * @internal
 */
function getRuntimeInfo() {
    const runtimeInfo = {
        key: "Node",
        value: process.version,
    };
    const osInfo = {
        key: "OS",
        value: `(${os__namespace.arch()}-${os__namespace.type()}-${os__namespace.release()})`,
    };
    return `${runtimeInfo.key}/${runtimeInfo.value} ${osInfo.key}/${osInfo.value}`;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Helper method to call onDetached on the non-sessions batching and streaming receivers from the connection context upon seeing an error.
 */
async function callOnDetachedOnReceivers(connectionContext, contextOrConnectionError, receiverType) {
    const detachCalls = [];
    // Iterating over non-sessions batching and streaming receivers
    for (const receiverName of Object.keys(connectionContext.messageReceivers)) {
        const receiver = connectionContext.messageReceivers[receiverName];
        if (receiver && receiver.receiverType === receiverType) {
            connectionLogger.verbose("[%s] calling detached on %s receiver '%s'.", connectionContext.connection.id, receiver.receiverType, receiver.name);
            detachCalls.push(receiver.onDetached(contextOrConnectionError).catch((err) => {
                connectionLogger.logError(err, "[%s] An error occurred while calling onDetached() on the %s receiver '%s'", connectionContext.connection.id, receiver.receiverType, receiver.name);
            }));
        }
    }
    return Promise.all(detachCalls);
}
/**
 * @internal
 * Helper method to call onDetached on the session receivers from the connection context upon seeing an error.
 */
async function callOnDetachedOnSessionReceivers(connectionContext, contextOrConnectionError) {
    const getSessionError = (sessionId, entityPath) => {
        const sessionInfo = `The receiver for session "${sessionId}" in "${entityPath}" has been closed and can no longer be used. ` +
            `Please create a new receiver using the "acceptSession" or "acceptNextSession" method on the ServiceBusClient.`;
        const errorMessage = contextOrConnectionError == null
            ? `Unknown error occurred on the AMQP connection while receiving messages. ` + sessionInfo
            : `Error occurred on the AMQP connection while receiving messages. ` +
                sessionInfo +
                `\nMore info - \n${contextOrConnectionError}`;
        const error = new ServiceBusError(errorMessage, "SessionLockLost");
        error.retryable = false;
        return error;
    };
    const detachCalls = [];
    for (const receiverName of Object.keys(connectionContext.messageSessions)) {
        const receiver = connectionContext.messageSessions[receiverName];
        connectionLogger.verbose("[%s] calling detached on %s receiver(sessions).", connectionContext.connection.id, receiver.name);
        detachCalls.push(receiver.onDetached(getSessionError(receiver.sessionId, receiver.entityPath)).catch((err) => {
            connectionLogger.logError(err, "[%s] An error occurred while calling onDetached() on the session receiver(sessions) '%s'", connectionContext.connection.id, receiver.name);
        }));
    }
    return Promise.all(detachCalls);
}
/**
 * @internal
 * Helper method to get the number of receivers of specified type from the connectionContext.
 */
function getNumberOfReceivers(connectionContext, receiverType) {
    if (receiverType === "session") {
        const receivers = connectionContext.messageSessions;
        return Object.keys(receivers).length;
    }
    const receivers = connectionContext.messageReceivers;
    const receiverNames = Object.keys(receivers);
    const count = receiverNames.reduce((acc, name) => (receivers[name].receiverType === receiverType ? ++acc : acc), 0);
    return count;
}
/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var ConnectionContext;
(function (ConnectionContext) {
    function create(config, tokenCredential, options) {
        if (!options)
            options = {};
        const userAgent = `${formatUserAgentPrefix(options.userAgentOptions?.userAgentPrefix)} ${getRuntimeInfo()}`;
        const parameters = {
            config: config,
            // re-enabling this will be a post-GA discussion similar to event-hubs.
            // dataTransformer: options.dataTransformer,
            isEntityPathRequired: false,
            connectionProperties: {
                product: "MSJSClient",
                userAgent,
                version: packageJsonInfo.version,
            },
        };
        // Let us create the base context and then add ServiceBus specific ConnectionContext properties.
        const connectionContext = coreAmqp.ConnectionContextBase.create(parameters);
        connectionContext.tokenCredential = tokenCredential;
        connectionContext.senders = {};
        connectionContext.messageReceivers = {};
        connectionContext.messageSessions = {};
        connectionContext.managementClients = {};
        let waitForConnectionRefreshResolve;
        let waitForConnectionRefreshPromise;
        Object.assign(connectionContext, {
            isConnectionClosing() {
                // When the connection is not open, but the remote end is open,
                // then the rhea connection is in the process of terminating.
                return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());
            },
            async readyToOpenLink() {
                connectionLogger.verbose(`[${this.connectionId}] Waiting until the connection is ready to open link.`);
                // Check that the connection isn't in the process of closing.
                // This can happen when the idle timeout has been reached but
                // the underlying socket is waiting to be destroyed.
                if (this.isConnectionClosing()) {
                    connectionLogger.verbose(`[${this.connectionId}] Connection is closing, waiting for disconnected event`);
                    // Wait for the disconnected event that indicates the underlying socket has closed.
                    await this.waitForDisconnectedEvent();
                }
                // Wait for the connection to be reset.
                await this.waitForConnectionReset();
                connectionLogger.verbose(`[${this.connectionId}] Connection is ready to open link.`);
            },
            waitForDisconnectedEvent() {
                return new Promise((resolve) => {
                    connectionLogger.verbose(`[${this.connectionId}] Attempting to reinitialize connection` +
                        ` but the connection is in the process of closing.` +
                        ` Waiting for the disconnect event before continuing.`);
                    this.connection.once(rheaPromise.ConnectionEvents.disconnected, resolve);
                });
            },
            waitForConnectionReset() {
                // Check if the connection is currently in the process of disconnecting.
                if (waitForConnectionRefreshPromise) {
                    connectionLogger.verbose(`[${this.connectionId}] Waiting for connection reset`);
                    return waitForConnectionRefreshPromise;
                }
                connectionLogger.verbose(`[${this.connectionId}] Connection not waiting to be reset. Resolving immediately.`);
                return Promise.resolve();
            },
            getReceiverFromCache(receiverName, sessionId) {
                if (sessionId != null && this.messageSessions[receiverName]) {
                    return this.messageSessions[receiverName];
                }
                if (this.messageReceivers[receiverName]) {
                    return this.messageReceivers[receiverName];
                }
                let existingReceivers = "";
                if (sessionId != null) {
                    for (const messageSessionName of Object.keys(this.messageSessions)) {
                        if (this.messageSessions[messageSessionName].sessionId === sessionId) {
                            existingReceivers = this.messageSessions[messageSessionName].name;
                            break;
                        }
                    }
                }
                else {
                    existingReceivers +=
                        (existingReceivers ? ", " : "") + Object.keys(this.messageReceivers).join(",");
                }
                connectionLogger.verbose("[%s] Failed to find receiver '%s' among existing receivers: %s", this.connectionId, receiverName, existingReceivers);
                return;
            },
            getManagementClient(entityPath) {
                if (!this.managementClients[entityPath]) {
                    this.managementClients[entityPath] = new ManagementClient(this, entityPath, {
                        address: `${entityPath}/$management`,
                    });
                }
                return this.managementClients[entityPath];
            },
        });
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = () => {
            connectionContext.wasConnectionCloseCalled = false;
            connectionLogger.verbose("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = async (context) => {
            if (waitForConnectionRefreshPromise) {
                return;
            }
            waitForConnectionRefreshPromise = new Promise((resolve) => {
                waitForConnectionRefreshResolve = resolve;
            });
            const connectionError = context.connection && context.connection.error ? context.connection.error : undefined;
            if (connectionError) {
                connectionLogger.logError(connectionError, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
            }
            const contextError = context.error;
            if (contextError) {
                connectionLogger.logError(contextError, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
            }
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numSenders: Object.keys(connectionContext.senders).length,
                numReceivers: Object.keys(connectionContext.messageReceivers).length +
                    Object.keys(connectionContext.messageSessions).length,
            };
            // Clear internal map maintained by rhea to avoid reconnecting of old links once the
            // connection is back up.
            connectionContext.connection.removeAllSessions();
            // Close the cbs session to ensure all the event handlers are released.
            await connectionContext.cbsSession.close();
            // Close the management sessions to ensure all the event handlers are released.
            for (const entityPath of Object.keys(connectionContext.managementClients)) {
                await connectionContext.managementClients[entityPath].close();
            }
            if (state.wasConnectionCloseCalled) ;
            else {
                // Calling onDetached on sender
                if (state.numSenders) {
                    // We don't do recovery for the sender:
                    //   Because we don't want to keep the sender active all the time
                    //   and the "next" send call would bear the burden of creating the link.
                    // Call onDetached() on sender so that it can gracefully shutdown
                    //   by cleaning up the timers and closing the links.
                    // We don't call onDetached for sender after `refreshConnection()`
                    //   because any new send calls that potentially initialize links would also get affected if called later.
                    connectionLogger.verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${state.numSenders} ` +
                        `senders. We should not reconnect.`);
                    const detachCalls = [];
                    for (const senderName of Object.keys(connectionContext.senders)) {
                        const sender = connectionContext.senders[senderName];
                        if (sender) {
                            connectionLogger.verbose("[%s] calling detached on sender '%s'.", connectionContext.connection.id, sender.name);
                            detachCalls.push(sender.onDetached().catch((err) => {
                                connectionLogger.logError(err, "[%s] An error occurred while calling onDetached() the sender '%s'", connectionContext.connection.id, sender.name);
                            }));
                        }
                    }
                    await Promise.all(detachCalls);
                }
                // Calling onDetached on batching receivers for the same reasons as sender
                const numBatchingReceivers = getNumberOfReceivers(connectionContext, "batching");
                if (numBatchingReceivers) {
                    connectionLogger.verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numBatchingReceivers} ` +
                        `batching receivers. We should not reconnect.`);
                    // Call onDetached() on receivers so that batching receivers it can gracefully close any ongoing batch operation
                    await callOnDetachedOnReceivers(connectionContext, connectionError || contextError, "batching");
                }
                // Calling onDetached on session receivers
                const numSessionReceivers = getNumberOfReceivers(connectionContext, "session");
                if (numSessionReceivers) {
                    connectionLogger.verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numSessionReceivers} ` +
                        `session receivers. We should close them.`);
                    await callOnDetachedOnSessionReceivers(connectionContext, connectionError || contextError);
                }
            }
            await refreshConnection();
            waitForConnectionRefreshResolve();
            waitForConnectionRefreshPromise = undefined;
            // The connection should always be brought back up if the sdk did not call connection.close()
            // and there was at least one receiver link on the connection before it went down.
            connectionLogger.verbose("[%s] state: %O", connectionContext.connectionId, state);
            // Calling onDetached on streaming receivers
            const numStreamingReceivers = getNumberOfReceivers(connectionContext, "streaming");
            if (!state.wasConnectionCloseCalled && numStreamingReceivers) {
                connectionLogger.verbose(`[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numStreamingReceivers} ` +
                    `streaming receivers. We should reconnect.`);
                // Calling `onDetached()` on streaming receivers after the refreshConnection() since `onDetached()` would
                // recover the streaming receivers and that would only be possible after the connection is refreshed.
                //
                // This is different from the batching receiver since `onDetached()` for the batching receiver would
                // return the outstanding messages and close the receive link.
                await callOnDetachedOnReceivers(connectionContext, connectionError || contextError, "streaming");
            }
        };
        const protocolError = async (context) => {
            if (context.connection && context.connection.error) {
                connectionLogger.logError(context.connection.error, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
            }
            if (context.error) {
                connectionLogger.logError(context.error, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
            }
        };
        const error = async (context) => {
            if (context.connection && context.connection.error) {
                connectionLogger.logError(context.connection.error, "[%s] Error (context.connection.error) occurred on the amqp connection", connectionContext.connection.id);
            }
            if (context.error) {
                connectionLogger.logError(context.error, "[%s] Error (context.error) occurred on the amqp connection", connectionContext.connection.id);
            }
        };
        async function refreshConnection() {
            const originalConnectionId = connectionContext.connectionId;
            try {
                await cleanConnectionContext();
            }
            catch (err) {
                connectionLogger.logError(err, `[${connectionContext.connectionId}] There was an error closing the connection before reconnecting`);
            }
            // Create a new connection, id, locks, and cbs client.
            connectionContext.refreshConnection();
            addConnectionListeners(connectionContext.connection);
            connectionLogger.verbose(`The connection "${originalConnectionId}" has been updated to "${connectionContext.connectionId}".`);
        }
        function addConnectionListeners(connection) {
            // Add listeners on the connection object.
            connection.on(rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
            connection.on(rheaPromise.ConnectionEvents.disconnected, disconnected);
            connection.on(rheaPromise.ConnectionEvents.protocolError, protocolError);
            connection.on(rheaPromise.ConnectionEvents.error, error);
        }
        async function cleanConnectionContext() {
            // Remove listeners from the connection object.
            connectionContext.connection.removeListener(rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
            connectionContext.connection.removeListener(rheaPromise.ConnectionEvents.disconnected, disconnected);
            connectionContext.connection.removeListener(rheaPromise.ConnectionEvents.protocolError, protocolError);
            connectionContext.connection.removeListener(rheaPromise.ConnectionEvents.error, error);
            // Close the connection
            await connectionContext.connection.close();
        }
        addConnectionListeners(connectionContext.connection);
        connectionLogger.verbose("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
    /**
     * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for
     * sender/receivers created by the queue/topic/subscription clients created by this
     * ServiceBusClient.
     * Once closed,
     * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.
     * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.
     */
    async function close(context) {
        const logPrefix = `[${context.connectionId}]`;
        try {
            connectionLogger.verbose(`${logPrefix} Permanently closing the amqp connection on the client.`);
            const senderNames = Object.keys(context.senders);
            const messageReceiverNames = Object.keys(context.messageReceivers);
            const messageSessionNames = Object.keys(context.messageSessions);
            const managementClientsEntityPaths = Object.keys(context.managementClients);
            connectionLogger.verbose(`${logPrefix} Permanently closing all the senders(${senderNames.length}), MessageReceivers(${messageReceiverNames.length}), MessageSessions(${messageSessionNames.length}), and ManagementClients(${managementClientsEntityPaths.length}).`);
            await Promise.all([
                ...senderNames.map((n) => context.senders[n].close()),
                ...messageReceiverNames.map((n) => context.messageReceivers[n].close()),
                ...messageSessionNames.map((n) => context.messageSessions[n].close()),
                ...managementClientsEntityPaths.map((p) => context.managementClients[p].close()),
            ]);
            connectionLogger.verbose(`${logPrefix} Permanently closing cbsSession`);
            await context.cbsSession.close();
            connectionLogger.verbose(`${logPrefix} Permanently closing internal connection`);
            await context.connection.close();
            context.wasConnectionCloseCalled = true;
            connectionLogger.verbose(`[${logPrefix} Permanently closed the amqp connection on the client.`);
        }
        catch (err) {
            const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));
            connectionLogger.logError(err, `${logPrefix} An error occurred while closing the connection`);
            throw errObj;
        }
    }
    ConnectionContext.close = close;
})(ConnectionContext || (ConnectionContext = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Parses given connection string into the different properties applicable to Azure Service Bus.
 * The properties are useful to then construct a ServiceBusClient.
 * @param connectionString - The connection string associated with the Shared Access Policy created
 * for the Service Bus namespace, queue or topic.
 */
function parseServiceBusConnectionString(connectionString) {
    const parsedResult = coreAmqp.parseConnectionString(connectionString);
    if (!parsedResult.Endpoint) {
        throw new Error("Connection string should have an Endpoint key.");
    }
    if (parsedResult.SharedAccessSignature) {
        if (parsedResult.SharedAccessKey || parsedResult.SharedAccessKeyName) {
            throw new Error("Connection string cannot have both SharedAccessSignature and SharedAccessKey keys.");
        }
    }
    else if (parsedResult.SharedAccessKey && !parsedResult.SharedAccessKeyName) {
        throw new Error("Connection string with SharedAccessKey should have SharedAccessKeyName.");
    }
    else if (!parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {
        throw new Error("Connection string with SharedAccessKeyName should have SharedAccessKey as well.");
    }
    const output = {
        fullyQualifiedNamespace: (parsedResult.Endpoint.match(".*://([^/]*)") || [])[1],
        endpoint: parsedResult.Endpoint,
    };
    if (parsedResult.EntityPath) {
        output.entityPath = parsedResult.EntityPath;
    }
    if (parsedResult.SharedAccessSignature) {
        output.sharedAccessSignature = parsedResult.SharedAccessSignature;
    }
    if (parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {
        output.sharedAccessKey = parsedResult.SharedAccessKey;
        output.sharedAccessKeyName = parsedResult.SharedAccessKeyName;
    }
    return output;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// TODO: extract parseEndpoint and setCustomEndpointAddress into core-amqp
// ConnectionConfig so that it can be shared between Event Hubs and Service Bus
/**
 * Parses the host, hostname, and port from an endpoint.
 * @param endpoint - And endpoint to parse.
 * @internal
 */
function parseEndpoint(endpoint) {
    const hostMatch = endpoint.match(/.*:\/\/([^/]*)/);
    if (!hostMatch) {
        throw new TypeError(`Invalid endpoint missing host: ${endpoint}`);
    }
    const [, host] = hostMatch;
    const [hostname, port] = host.split(":");
    return { host, hostname, port };
}
/**
 * Updates the provided ConnectionConfig to use the custom endpoint address.
 * @param config - An existing connection configuration to be updated.
 * @param customEndpointAddress - The custom endpoint address to use.
 */
function setCustomEndpointAddress(config, customEndpointAddress) {
    // The amqpHostname should match the host prior to using the custom endpoint.
    config.amqpHostname = config.host;
    const { hostname, port } = parseEndpoint(customEndpointAddress);
    // Since we specify the port separately, set host to the customEndpointAddress hostname.
    config.host = hostname;
    if (port) {
        config.port = parseInt(port, 10);
    }
}
/**
 * @internal
 *
 */
function createConnectionContext(connectionString, credential, options) {
    const config = coreAmqp.ConnectionConfig.create(connectionString);
    config.webSocket = options?.webSocketOptions?.webSocket;
    config.webSocketEndpointPath = "$servicebus/websocket";
    config.webSocketConstructorOptions = options?.webSocketOptions?.webSocketConstructorOptions;
    if (options?.customEndpointAddress) {
        setCustomEndpointAddress(config, options.customEndpointAddress);
    }
    return ConnectionContext.create(config, credential, options);
}
/**
 * @internal
 */
function createConnectionContextForConnectionString(connectionString, options = {}) {
    const parsed = parseServiceBusConnectionString(connectionString);
    const sasTokenProvider = coreAmqp.createSasTokenProvider(parsed);
    return createConnectionContext(connectionString, sasTokenProvider, options);
}
/**
 *
 * @internal
 */
function createConnectionContextForCredential(credential, host, options = {}) {
    if (typeof host !== "string") {
        throw new TypeError("`host` parameter is not a string");
    }
    let tokenProvider;
    // host, credential and options based constructor was invoked
    if (!host.endsWith("/")) {
        host += "/";
    }
    if (coreAuth.isNamedKeyCredential(credential) || coreAuth.isSASCredential(credential)) {
        tokenProvider = coreAmqp.createSasTokenProvider(credential);
    }
    else {
        tokenProvider = credential;
    }
    const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;
    return createConnectionContext(connectionString, tokenProvider, options);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * This is the shared onSettled handler for all of the receiver implementations.
 *
 * The sequence is basically:
 * 1. User calls `await <ServiceBusMessage instance>.complete()`     (or other settlement methods)
 * 2. This creates a `Promise` that gets stored in the _deliveryDispositionMap
 * 3. When the service acknowledges the settlement this method gets called for that message.
 * 4. We resolve() the promise from the _deliveryDispositionMap.
 * 5. User's code after the settlement continues.
 *
 * @internal
 */
function onMessageSettled(logPrefix, delivery, deliveryDispositionMap) {
    if (delivery) {
        const id = delivery.id;
        const state = delivery.remote_state;
        const settled = delivery.remote_settled;
        receiverLogger.verbose("%s Delivery with id %d, remote_settled: %s, remote_state: %o has been " + "received.", logPrefix, id, settled, state && state.error ? state.error : state);
        if (settled && deliveryDispositionMap.has(id)) {
            const promise = deliveryDispositionMap.get(id);
            clearTimeout(promise.timer);
            receiverLogger.verbose("%s Found the delivery with id %d in the map and cleared the timer.", logPrefix, id);
            const deleteResult = deliveryDispositionMap.delete(id);
            receiverLogger.verbose("%s Successfully deleted the delivery with id %d from the map.", logPrefix, id, deleteResult);
            if (state && state.error && (state.error.condition || state.error.description)) {
                const error = translateServiceBusError(state.error);
                return promise.reject(error);
            }
            return promise.resolve();
        }
    }
}
// Placed in Service Bus for now and can be promoted to core-amqp if also useful for Event Hubs in the future.
const timeoutName = `${coreAmqp.Constants.vendorString}:timeout`;
/**
 * Creates the options that need to be specified while creating an AMQP receiver link.
 *
 * @internal
 */
function createReceiverOptions(name, receiveMode, source, clientId, handlers, timeoutInMs) {
    const properties = timeoutInMs !== undefined
        ? { [coreAmqp.Constants.receiverIdentifierName]: clientId, [timeoutName]: timeoutInMs }
        : { [coreAmqp.Constants.receiverIdentifierName]: clientId };
    const rcvrOptions = {
        name,
        // "autoaccept" being true in the "receiveAndDelete" mode sets the "settled" flag to true on the deliveries
        // which helps in clearing the circular buffer(size=2048) as it is needed to receive messages after 2048 of them are received.
        autoaccept: receiveMode === "receiveAndDelete" ? true : false,
        // receiveAndDelete -> first(0), peekLock -> second (1)
        rcv_settle_mode: receiveMode === "receiveAndDelete" ? 0 : 1,
        // receiveAndDelete -> settled (1), peekLock -> unsettled (0)
        snd_settle_mode: receiveMode === "receiveAndDelete" ? 1 : 0,
        source,
        target: clientId,
        credit_window: 0,
        properties,
        ...handlers,
    };
    return rcvrOptions;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Describes the MessageReceiver that will receive messages from ServiceBus.
 */
class MessageReceiver extends LinkEntity {
    constructor(identifier, context, entityPath, receiverType, options) {
        super(entityPath, entityPath, context, receiverType, receiverLogger, {
            address: entityPath,
            audience: `${context.config.endpoint}${entityPath}`,
        });
        this.identifier = identifier;
        /**
         * Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */
        this._deliveryDispositionMap = new Map();
        this.receiverType = receiverType;
        this.receiveMode = options.receiveMode || "peekLock";
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete =
            options.autoCompleteMessages === false ? options.autoCompleteMessages : true;
        this._lockRenewer = options.lockRenewer;
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */
    _createReceiverOptions(useNewName, handlers) {
        const rcvrOptions = createReceiverOptions(useNewName ? getUniqueName(this.baseName) : this.name, this.receiveMode, {
            address: this.address,
        }, this.identifier, {
            onSettled: (context) => {
                return onMessageSettled(this.logPrefix, context.delivery, this._deliveryDispositionMap);
            },
            ...handlers,
        });
        return rcvrOptions;
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     */
    async _init(options, abortSignal) {
        try {
            await this.initLink(options, abortSignal);
            // It is possible for someone to close the receiver and then start it again.
            // Thus make sure that the receiver is present in the client cache.
            this._context.messageReceivers[this.name] = this;
        }
        catch (err) {
            const translatedError = translateServiceBusError(err);
            receiverLogger.logError(translatedError, "%s An error occured while creating the receiver", this.logPrefix);
            // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.
            if (translatedError.code === "OperationTimeoutError") {
                translatedError.message =
                    "Failed to create a receiver within allocated time and retry attempts.";
            }
            throw translatedError;
        }
    }
    createRheaLink(options, _abortSignal) {
        return this._context.connection.createReceiver(options);
    }
    /**
     * Clears lock renewal timers on all active messages, clears token remewal for current receiver,
     * removes current MessageReceiver instance from cache, and closes the underlying AMQP receiver.
     * @returns Promise<void>.
     */
    async close() {
        this._lockRenewer?.stopAll(this);
        await super.close();
    }
    /**
     * Settles the message with the specified disposition.
     * @param message - The ServiceBus Message that needs to be settled.
     * @param operation - The disposition type.
     * @param options - Optional parameters that can be provided while disposing the message.
     */
    async settleMessage(message, operation, options) {
        return new Promise((resolve, reject) => {
            if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
                return reject(new Error(`operation: '${operation}' is not a valid operation.`));
            }
            this._lockRenewer?.stop(this, message);
            const delivery = message.delivery;
            const timer = setTimeout(() => {
                this._deliveryDispositionMap.delete(delivery.id);
                receiverLogger.verbose("%s Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                    "Hence rejecting the promise with timeout error.", this.logPrefix, delivery.id, coreAmqp.Constants.defaultOperationTimeoutInMs);
                const e = {
                    condition: coreAmqp.ErrorNameConditionMapper.ServiceUnavailableError,
                    description: "Operation to settle the message has timed out. The disposition of the " +
                        "message may or may not be successful",
                };
                return reject(translateServiceBusError(e));
            }, options.retryOptions?.timeoutInMs ?? coreAmqp.Constants.defaultOperationTimeoutInMs);
            this._deliveryDispositionMap.set(delivery.id, {
                resolve: resolve,
                reject: reject,
                timer: timer,
            });
            if (operation === DispositionType.complete) {
                delivery.accept();
            }
            else if (operation === DispositionType.abandon) {
                const params = {
                    undeliverable_here: false,
                };
                if (options.propertiesToModify)
                    params.message_annotations = options.propertiesToModify;
                delivery.modified(params);
            }
            else if (operation === DispositionType.defer) {
                const params = {
                    undeliverable_here: true,
                };
                if (options.propertiesToModify)
                    params.message_annotations = options.propertiesToModify;
                delivery.modified(params);
            }
            else if (operation === DispositionType.deadletter) {
                const error = {
                    condition: coreAmqp.Constants.deadLetterName,
                    info: {
                        ...options.propertiesToModify,
                        DeadLetterReason: options.deadLetterReason,
                        DeadLetterErrorDescription: options.deadLetterDescription,
                    },
                };
                delivery.reject(error);
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Wraps the receiver with some higher level operations for managing state
 * like credits, draining, etc...
 *
 * @internal
 */
class ReceiverHelper {
    constructor(_getCurrentReceiver) {
        this._getCurrentReceiver = _getCurrentReceiver;
        this._isSuspended = true;
    }
    _getCurrentReceiverOrError() {
        const currentReceiverData = this._getCurrentReceiver();
        if (currentReceiverData.receiver == null) {
            return "is undefined";
        }
        if (!currentReceiverData.receiver.isOpen()) {
            return "is not open";
        }
        if (this._isSuspended) {
            return "is suspended";
        }
        return currentReceiverData;
    }
    /**
     * Adds credits to the receiver, respecting any state that
     * indicates the receiver is closed or should not continue
     * to receive more messages.
     *
     * @param credits - Number of credits to add.
     * or `stopReceivingMessages` has been called.
     */
    addCredit(credits) {
        const currentReceiverOrError = this._getCurrentReceiverOrError();
        if (typeof currentReceiverOrError === "string") {
            const errorMessage = `Cannot request messages on the receiver since it ${currentReceiverOrError}.`;
            if (currentReceiverOrError === "is suspended") {
                // if a user has suspended the receiver we should consider this a non-retryable
                // error since it absolutely requires user intervention.
                throw new abortController.AbortError(errorMessage);
            }
            throw new ServiceBusError(errorMessage, "GeneralError");
        }
        if (currentReceiverOrError.receiver != null) {
            receiverLogger.verbose(`${currentReceiverOrError.logPrefix} Adding ${credits} credits`);
            currentReceiverOrError.receiver.addCredit(credits);
        }
    }
    /**
     * Drains the credits for the receiver and prevents the `receiverHelper.addCredit()` method from adding credits.
     * Call `resume()` to enable the `addCredit()` method.
     */
    async suspend() {
        const { receiver, logPrefix } = this._getCurrentReceiver();
        this._isSuspended = true;
        if (!this._isValidReceiver(receiver)) {
            return;
        }
        receiverLogger.verbose(`${logPrefix} User has requested to stop receiving new messages, attempting to drain.`);
        return this.drain();
    }
    /**
     * Resets tracking so `addCredit` works again by toggling the `_isSuspended` flag.
     */
    resume() {
        this._isSuspended = false;
    }
    isSuspended() {
        return this._isSuspended;
    }
    /**
     * Initiates a drain for the current receiver and resolves when
     * the drain has completed.
     *
     * NOTE: This method returns immediately if the receiver is not valid or if there
     * are no pending credits on the receiver (ie: `receiver.credit === 0`).
     */
    async drain() {
        const { receiver, logPrefix } = this._getCurrentReceiver();
        if (!this._isValidReceiver(receiver)) {
            // TODO: should we throw?
            return;
        }
        if (receiver.credit === 0) {
            // nothing to drain
            return;
        }
        receiverLogger.verbose(`${logPrefix} Receiver is starting drain. Remaining credits; ${receiver.credit}`);
        const drainPromise = new Promise((resolve) => {
            const timer = setTimeout(async () => {
                receiverLogger.warning(`${logPrefix} Time out when draining credits in suspend().`);
                // Close the receiver link since we have not received the receiver_drained event
                // to prevent out-of-sync link state between local and remote
                await receiver?.close();
                resolve();
            }, receiveDrainTimeoutInMs);
            receiver.once(rheaPromise.ReceiverEvents.receiverDrained, () => {
                receiverLogger.verbose(`${logPrefix} Receiver has been drained.`);
                receiver.drain = false;
                clearTimeout(timer);
                resolve();
            });
            receiver.drainCredit();
        });
        return drainPromise;
    }
    _isValidReceiver(receiver) {
        return receiver != null && receiver.isOpen();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
const TRACEPARENT_PROPERTY = "Diagnostic-Id";
/**
 * Instruments an AMQP message with a proper `Diagnostic-Id` for tracing.
 *
 * @hidden
 */
function instrumentMessage(message, options, entityPath, host, operation) {
    // check if the event has already been instrumented
    const previouslyInstrumented = Boolean(message.applicationProperties?.[TRACEPARENT_PROPERTY]);
    if (previouslyInstrumented) {
        return {
            message,
            spanContext: undefined,
        };
    }
    const { span: messageSpan, updatedOptions } = tracingClient.startSpan("message", options, toSpanOptions({ entityPath, host }, operation, "producer"));
    try {
        if (!messageSpan.isRecording()) {
            return {
                message,
                spanContext: undefined,
            };
        }
        const traceParent = tracingClient.createRequestHeaders(updatedOptions.tracingOptions?.tracingContext)["traceparent"];
        if (traceParent) {
            // create a copy so the original isn't modified
            message = {
                ...message,
                applicationProperties: {
                    ...message.applicationProperties,
                    [TRACEPARENT_PROPERTY]: traceParent,
                },
            };
        }
        return {
            message,
            spanContext: updatedOptions.tracingOptions?.tracingContext,
        };
    }
    finally {
        messageSpan.end();
    }
}
/**
 * Extracts the `SpanContext` from an `ServiceBusMessage` if the context exists.
 * @param message - An individual `ServiceBusMessage` object.
 * @internal
 */
function extractSpanContextFromServiceBusMessage(message) {
    if (!message.applicationProperties || !message.applicationProperties[TRACEPARENT_PROPERTY]) {
        return;
    }
    const diagnosticId = message.applicationProperties[TRACEPARENT_PROPERTY];
    return tracingClient.parseTraceparentHeader(diagnosticId);
}
/**
 * Provides an iterable over messages, whether it is a single message or multiple
 * messages.
 *
 * @param receivedMessages - A single message or a set of messages
 * @internal
 */
function* getReceivedMessages(receivedMessages) {
    if (!Array.isArray(receivedMessages)) {
        yield receivedMessages;
    }
    else {
        for (const message of receivedMessages) {
            yield message;
        }
    }
}
/**
 * @internal
 */
function toProcessingSpanOptions(receivedMessages, receiver, connectionConfig, operation) {
    const spanLinks = [];
    for (const receivedMessage of getReceivedMessages(receivedMessages)) {
        const tracingContext = extractSpanContextFromServiceBusMessage(receivedMessage);
        if (tracingContext) {
            spanLinks.push({
                tracingContext,
                attributes: {
                    enqueuedTime: receivedMessage.enqueuedTimeUtc?.getTime(),
                },
            });
        }
    }
    return {
        spanLinks,
        spanKind: "consumer",
        ...toSpanOptions({ host: connectionConfig.host, entityPath: receiver.entityPath }, operation),
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
function assertValidMessageHandlers(handlers) {
    if (handlers &&
        handlers.processMessage instanceof Function &&
        handlers.processError instanceof Function) {
        return;
    }
    throw new TypeError('Invalid "MessageHandlers" provided.');
}
/**
 * @internal
 */
async function* getMessageIterator(receiver, options) {
    while (true) {
        const messages = await receiver.receiveMessages(1, options);
        if (messages.length === 0) {
            continue;
        }
        yield messages[0];
    }
}
/**
 * @internal
 */
function wrapProcessErrorHandler(handlers, loggerParam = receiverLogger) {
    return async (args) => {
        try {
            args.error = translateServiceBusError(args.error);
            await handlers.processError(args);
        }
        catch (err) {
            loggerParam.logError(err, `An error was thrown from the user's processError handler`);
        }
    };
}
/**
 * @internal
 *
 */
function completeMessage(message, context, entityPath, retryOptions) {
    receiverLogger.verbose("[%s] Completing the message with id '%s'.", context.connectionId, message.messageId);
    const tracingContext = extractSpanContextFromServiceBusMessage(message);
    const spanLinks = tracingContext ? [{ tracingContext }] : [];
    return tracingClient.withSpan("ServicebusReceiver.complete", {}, () => settleMessage(message, DispositionType.complete, context, entityPath, {
        retryOptions,
    }), {
        spanLinks,
        ...toSpanOptions({ entityPath, host: context.config.host }, "settle", "client"),
    });
}
/**
 * @internal
 *
 */
function abandonMessage(message, context, entityPath, propertiesToModify, retryOptions) {
    receiverLogger.verbose("[%s] Abandoning the message with id '%s'.", context.connectionId, message.messageId);
    const tracingContext = extractSpanContextFromServiceBusMessage(message);
    const spanLinks = tracingContext ? [{ tracingContext }] : [];
    return tracingClient.withSpan("ServicebusReceiver.abandon", {}, () => settleMessage(message, DispositionType.abandon, context, entityPath, {
        propertiesToModify,
        retryOptions,
    }), {
        spanLinks,
        ...toSpanOptions({ entityPath, host: context.config.host }, "settle", "client"),
    });
}
/**
 * @internal
 *
 */
function deferMessage(message, context, entityPath, propertiesToModify, retryOptions) {
    receiverLogger.verbose("[%s] Deferring the message with id '%s'.", context.connectionId, message.messageId);
    const tracingContext = extractSpanContextFromServiceBusMessage(message);
    const spanLinks = tracingContext ? [{ tracingContext }] : [];
    return tracingClient.withSpan("ServiceBusReceiver.defer", {}, () => settleMessage(message, DispositionType.defer, context, entityPath, {
        retryOptions,
        propertiesToModify,
    }), {
        spanLinks,
        ...toSpanOptions({ entityPath, host: context.config.host }, "settle", "client"),
    });
}
/**
 * @internal
 *
 */
function deadLetterMessage(message, context, entityPath, propertiesToModify, retryOptions) {
    receiverLogger.verbose("[%s] Deadlettering the message with id '%s'.", context.connectionId, message.messageId);
    const actualPropertiesToModify = {
        ...propertiesToModify,
    };
    // these two fields are handled specially and don't need to be in here.
    delete actualPropertiesToModify.deadLetterErrorDescription;
    delete actualPropertiesToModify.deadLetterReason;
    const dispositionStatusOptions = {
        propertiesToModify: actualPropertiesToModify,
        deadLetterReason: propertiesToModify?.deadLetterReason,
        deadLetterDescription: propertiesToModify?.deadLetterErrorDescription,
        retryOptions,
    };
    const tracingContext = extractSpanContextFromServiceBusMessage(message);
    const spanLinks = tracingContext ? [{ tracingContext }] : [];
    return tracingClient.withSpan("ServiceBusReceiver.deadLetter", {}, () => settleMessage(message, DispositionType.deadletter, context, entityPath, dispositionStatusOptions), {
        spanLinks,
        ...toSpanOptions({ entityPath, host: context.config.host }, "settle", "client"),
    });
}
/**
 * @internal
 */
function settleMessage(message, operation, context, entityPath, options, _settleMessageOperation = settleMessageOperation) {
    return coreAmqp.retry({
        connectionId: context.connectionId,
        operation: () => {
            return _settleMessageOperation(message, operation, context, entityPath, options);
        },
        operationType: coreAmqp.RetryOperationType.messageSettlement,
        abortSignal: options?.abortSignal,
        retryOptions: options?.retryOptions,
    });
}
/**
 * @internal
 *
 * NOTE: it's tempting to make this method non-async. However, doing so makes it too easy
 * to throw exceptions that will not be "catchable" by people chaining to the returned Promise
 * since we can throw exceptions outside of the Promise's scope.
 */
async function settleMessageOperation(message, operation, context, entityPath, options) {
    const isDeferredMessage = !message.delivery.link;
    const receiver = isDeferredMessage
        ? undefined
        : context.getReceiverFromCache(message.delivery.link.name, message.sessionId);
    const associatedLinkName = receiver?.name;
    let error;
    if (message.delivery.remote_settled) {
        error = new Error(MessageAlreadySettled);
    }
    else if (!isDeferredMessage &&
        (!receiver || !receiver.isOpen()) &&
        coreUtil.isDefined(message.sessionId)) {
        error = translateServiceBusError({
            description: `Failed to ${operation} the message as the AMQP link with which the message was ` +
                `received is no longer alive.`,
            condition: coreAmqp.ErrorNameConditionMapper.SessionLockLostError,
        });
    }
    if (error) {
        receiverLogger.logError(error, "[%s] An error occurred when settling a message with id '%s'", context.connectionId, message.messageId);
        throw error;
    }
    // Message Settlement with managementLink
    // 1. If the received message is deferred as such messages can only be settled using managementLink
    // 2. If the associated receiver link is not available. This does not apply to messages from sessions as we need a lock on the session to do so.
    if (isDeferredMessage || ((!receiver || !receiver.isOpen()) && !coreUtil.isDefined(message.sessionId))) {
        return context
            .getManagementClient(entityPath)
            .updateDispositionStatus(message.lockToken, operation, {
            ...options,
            associatedLinkName,
            sessionId: message.sessionId,
        })
            .catch((err) => {
            throw translateServiceBusError(err);
        });
    }
    return receiver.settleMessage(message, operation, options).catch((err) => {
        throw translateServiceBusError(err);
    });
}
/**
 * Calculates delay between retries, in milliseconds.
 */
function calculateDelay(attemptCount, retryDelayInMs, maxRetryDelayInMs, mode) {
    if (mode === coreAmqp.RetryMode.Exponential) {
        const boundedRandDelta = retryDelayInMs * 0.8 +
            Math.floor(Math.random() * (retryDelayInMs * 1.2 - retryDelayInMs * 0.8));
        const incrementDelta = boundedRandDelta * (Math.pow(2, attemptCount) - 1);
        return Math.min(incrementDelta, maxRetryDelayInMs);
    }
    return retryDelayInMs;
}
/**
 * Retry infinitely until success, reporting in between retry attempts.
 *
 * This function will only stop retrying if:
 * - args.retryConfig.operation resolves successfully
 * - args.retryConfig.operation rejects with an `AbortError`
 *
 * @internal
 */
async function retryForever(args, retryFn = coreAmqp.retry) {
    let numRetryCycles = 0;
    const config = args.retryConfig;
    if (!config.retryOptions) {
        config.retryOptions = {};
    }
    // eslint-disable-next-line eqeqeq
    if (config.retryOptions.retryDelayInMs == undefined || config.retryOptions.retryDelayInMs < 0) {
        config.retryOptions.retryDelayInMs = coreAmqp.Constants.defaultDelayBetweenOperationRetriesInMs;
    }
    if (
    // eslint-disable-next-line eqeqeq
    config.retryOptions.maxRetryDelayInMs == undefined ||
        config.retryOptions.maxRetryDelayInMs < 0) {
        config.retryOptions.maxRetryDelayInMs = coreAmqp.Constants.defaultMaxDelayForExponentialRetryInMs;
    }
    if (!config.retryOptions.mode) {
        config.retryOptions.mode = coreAmqp.RetryMode.Fixed;
    }
    // The retries are broken up into cycles, giving the user some control over how often
    // we actually attempt to retry.
    // eslint-disable-next-line no-constant-condition
    while (true) {
        ++numRetryCycles;
        try {
            return await retryFn(args.retryConfig);
        }
        catch (err) {
            // if the user aborts the operation we're immediately done.
            // AbortError is also thrown by linkEntity.init() if the connection has been
            // permanently closed.
            if (err.name === "AbortError") {
                logger.warning(`${args.logPrefix} AbortError caught, ending retries.`);
                throw err;
            }
            // we only report the error here - this avoids spamming the user with too many
            // redundant reports of errors while still providing them incremental status on failures.
            try {
                args.onError(err);
            }
            catch (error) {
                logger.error("args.onerror has thrown", error);
            }
            args.logger.logError(err, `${args.logPrefix} Error thrown in retry cycle ${numRetryCycles}, restarting retry cycle with retry options`, args.retryConfig);
            const delayInMs = calculateDelay(numRetryCycles, config.retryOptions.retryDelayInMs, config.retryOptions.maxRetryDelayInMs, config.retryOptions.mode);
            logger.verbose("[%s] Sleeping for %d milliseconds for '%s'.", config.connectionId, delayInMs, config.operationType);
            await coreUtil.delay(delayInMs, {
                abortSignal: config.abortSignal,
                abortErrorMsg: "Retry cycle has been cancelled by the user.",
            });
            continue;
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Describes the streaming receiver where the user can receive the message
 * by providing handler functions.
 */
class StreamingReceiver extends MessageReceiver {
    /**
     * Whether we are currently subscribed (or subscribing) for receiving messages.
     * (this is irrespective of receiver state, etc... - it's just a simple flag to prevent
     * multiple subscribe() calls from happening on this instance)
     */
    get isSubscribeActive() {
        return !this._receiverHelper.isSuspended();
    }
    /**
     * Instantiate a new Streaming receiver for receiving messages with handlers.
     *
     * @param identifier - the name used to identifier the receiver
     * @param connectionContext - The client entity context.
     * @param options - Options for how you'd like to connect.
     */
    constructor(identifier, connectionContext, entityPath, options) {
        super(identifier, connectionContext, entityPath, "streaming", options);
        /**
         * The maximum number of messages that should be
         * processed concurrently while in streaming mode. Once this limit has been reached, more
         * messages will not be received until the user's message handler has completed processing current message.
         * Default: 1
         */
        this.maxConcurrentCalls = 1;
        /**
         * Indicates whether the receiver is already actively
         * running `onDetached`.
         * This is expected to be true while the receiver attempts
         * to bring its link back up due to a retryable issue.
         */
        this._isDetaching = false;
        /**
         * The user's message handlers, wrapped so any thrown exceptions are properly logged
         * or forwarded to the user's processError handler.
         */
        this._messageHandlers = () => {
            throw new Error("messageHandlers are not set.");
        };
        /**
         * Used so we can stub out retry in tests.
         */
        this._retryForeverFn = retryForever;
        if (typeof options?.maxConcurrentCalls === "number" && options?.maxConcurrentCalls > 0) {
            this.maxConcurrentCalls = options.maxConcurrentCalls;
        }
        this._retryOptions = options?.retryOptions || {};
        this._receiverHelper = new ReceiverHelper(() => ({
            receiver: this.link,
            logPrefix: this.logPrefix,
        }));
        this._onAmqpClose = async (context) => {
            const receiverError = context.receiver && context.receiver.error;
            const receiver = this.link || context.receiver;
            receiverLogger.logError(receiverError, `${this.logPrefix} 'receiver_close' event occurred. The associated error is`);
            this._lockRenewer?.stopAll(this);
            if (receiver && !receiver.isItselfClosed()) {
                await this.onDetached(receiverError);
            }
            else {
                receiverLogger.verbose("%s 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", this.logPrefix, this.name, this.address);
            }
        };
        this._onSessionClose = async (context) => {
            const receiver = this.link || context.receiver;
            const sessionError = context.session && context.session.error;
            receiverLogger.logError(sessionError, `${this.logPrefix} 'session_close' event occurred. The associated error is`);
            this._lockRenewer?.stopAll(this);
            if (receiver && !receiver.isSessionItselfClosed()) {
                await this.onDetached(sessionError);
            }
            else {
                receiverLogger.verbose("%s 'session_close' event occurred on the session of receiver '%s' with address " +
                    "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                    "() handler.", this.logPrefix, this.name, this.address);
            }
        };
        this._onAmqpError = (context) => {
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = translateServiceBusError(receiverError);
                receiverLogger.logError(sbError, `${this.logPrefix} 'receiver_error' event occurred. The associated error is`);
                this._messageHandlers().processError({
                    error: sbError,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier,
                });
            }
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = translateServiceBusError(sessionError);
                receiverLogger.logError(sbError, `${this.logPrefix} 'session_error' event occurred. The associated error is`);
                this._messageHandlers().processError({
                    error: sbError,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier,
                });
            }
        };
        this._onAmqpMessage = async (context) => {
            // If the receiver got closed in PeekLock mode, avoid processing the message as we
            // cannot settle the message.
            if (this.receiveMode === "peekLock" && (!this.link || !this.link.isOpen())) {
                receiverLogger.verbose("%s Not calling the user's message handler for the current message " +
                    "as the receiver is closed", this.logPrefix);
                return;
            }
            const bMessage = new ServiceBusMessageImpl(context.message, context.delivery, true, this.receiveMode, options.skipParsingBodyAsJson ?? false, options.skipConvertingDate ?? false);
            this._lockRenewer?.start(this, bMessage, (err) => {
                this._messageHandlers().processError({
                    error: err,
                    errorSource: "renewLock",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier,
                });
            });
            try {
                await this._messageHandlers().processMessage(bMessage);
            }
            catch (err) {
                receiverLogger.logError(err, "%s An error occurred while running user's message handler for the message " +
                    "with id '%s' on the receiver '%s'", this.logPrefix, bMessage.messageId, this.name);
                // Do not want renewLock to happen unnecessarily, while abandoning the message. Hence,
                // doing this here. Otherwise, this should be done in finally.
                this._lockRenewer?.stop(this, bMessage);
                const error = translateServiceBusError(err);
                // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                if (!bMessage.delivery.remote_settled &&
                    error.code !== coreAmqp.ConditionErrorNameMapper["com.microsoft:message-lock-lost"] &&
                    this.receiveMode === "peekLock" &&
                    this.isOpen() // only try to abandon the messages if the connection is still open
                ) {
                    try {
                        receiverLogger.logError(error, "%s Abandoning the message with id '%s' on the receiver '%s' since " +
                            "an error occured: %O.", this.logPrefix, bMessage.messageId, this.name, error);
                        await abandonMessage(bMessage, this._context, entityPath, undefined, this._retryOptions);
                    }
                    catch (abandonError) {
                        const translatedError = translateServiceBusError(abandonError);
                        receiverLogger.logError(translatedError, "%s An error occurred while abandoning the message with id '%s' on the " +
                            "receiver '%s'", this.logPrefix, bMessage.messageId, this.name);
                        this._messageHandlers().processError({
                            error: translatedError,
                            errorSource: "abandon",
                            entityPath: this.entityPath,
                            fullyQualifiedNamespace: this._context.config.host,
                            identifier,
                        });
                    }
                }
                return;
            }
            finally {
                try {
                    this._receiverHelper.addCredit(1);
                }
                catch (err) {
                    // if we're aborting out of the receive operation we don't need to report it (the user already
                    // knows the link is being torn down or stopped)
                    if (err.name !== "AbortError") {
                        receiverLogger.logError(err, `[${this.logPrefix}] Failed to add credit after receiving message`);
                        await this._reportInternalError(err);
                    }
                }
            }
            // If we've made it this far, then user's message handler completed fine. Let us try
            // completing the message.
            if (this.autoComplete &&
                this.receiveMode === "peekLock" &&
                !bMessage.delivery.remote_settled) {
                try {
                    receiverLogger.verbose("%s Auto completing the message with id '%s' on " + "the receiver.", this.logPrefix, bMessage.messageId);
                    await completeMessage(bMessage, this._context, entityPath, this._retryOptions);
                }
                catch (completeError) {
                    const translatedError = translateServiceBusError(completeError);
                    receiverLogger.logError(translatedError, "%s An error occurred while completing the message with id '%s' on the " +
                        "receiver '%s'", this.logPrefix, bMessage.messageId, this.name);
                    this._messageHandlers().processError({
                        error: translatedError,
                        errorSource: "complete",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        identifier,
                    });
                }
            }
        };
    }
    _reportInternalError(error) {
        const messageHandlers = this._messageHandlers();
        if (messageHandlers.forwardInternalErrors) {
            const errorArgs = {
                error,
                entityPath: this.entityPath,
                errorSource: "internal",
                fullyQualifiedNamespace: this._context.config.host,
                identifier: this.identifier,
            };
            return messageHandlers.processError(errorArgs);
        }
        return Promise.resolve();
    }
    _getHandlers() {
        return {
            onMessage: (context) => this._onAmqpMessage(context).catch((err) => this._reportInternalError(err)),
            onClose: (context) => this._onAmqpClose(context).catch((err) => this._reportInternalError(err)),
            onSessionClose: (context) => this._onSessionClose(context).catch((err) => this._reportInternalError(err)),
            onError: this._onAmqpError,
            onSessionError: this._onSessionError,
        };
    }
    async stopReceivingMessages() {
        await this._receiverHelper.suspend();
        if (this._subscribeCallPromise) {
            await this._subscribeCallPromise;
        }
    }
    async close() {
        await this._receiverHelper.suspend();
        return super.close();
    }
    /**
     * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.
     *
     * Any errors thrown by this function will also be sent to the messageHandlers.processError function
     * _and_ thrown, ultimately from this method.
     *
     * NOTE: This function retries _infinitely_ until success! It is completely up to the user to break
     * out of this retry cycle otherwise by:
     * 1. closing the receiver
     * 2. Calling `close` on the subscription instance they received when they initially called subscribe().
     * 3. aborting the abortSignal they passed in when calling subscribe (this also applies to initialization calls in onDetach)
     *
     * @param onMessage - The message handler to receive servicebus messages.
     * @param onError - The error handler to receive an error that occurs while receivin messages.
     */
    async subscribe(messageHandlers, subscribeOptions) {
        // these options and message handlers will be re-used if/when onDetach is called.
        this._subscribeOptions = subscribeOptions;
        this._setMessageHandlers(messageHandlers, subscribeOptions);
        let promiseResolve;
        this._subscribeCallPromise = new Promise((resolve) => {
            promiseResolve = resolve;
        });
        try {
            this._receiverHelper.resume();
            return await this._subscribeImpl("subscribe");
        }
        catch (err) {
            // callers aren't going to be in a good position to forward this error properly
            // so we do it here.
            await this._messageHandlers().processError({
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host,
                errorSource: "receive",
                error: err,
                identifier: this.identifier,
            });
            throw err;
        }
        finally {
            promiseResolve?.();
            this._subscribeCallPromise = undefined;
        }
    }
    /**
     * Wraps the individual message handlers with tracing and proper error handling
     * and assigns them to `this._messageHandlers`
     *
     * @param userHandlers - The user's message handlers
     * @param operationOptions - The subscribe(options)
     */
    _setMessageHandlers(userHandlers, operationOptions) {
        const messageHandlers = {
            processError: async (args) => {
                try {
                    args.error = translateServiceBusError(args.error);
                    await userHandlers.processError(args);
                }
                catch (err) {
                    await this._reportInternalError(err);
                    receiverLogger.logError(err, `An error was thrown from the user's processError handler`);
                }
            },
            processMessage: async (message) => {
                try {
                    await tracingClient.withSpan("StreamReceiver.process", operationOptions ?? {}, () => userHandlers.processMessage(message), toProcessingSpanOptions(message, this, this._context.config, "process"));
                }
                catch (err) {
                    this._messageHandlers().processError({
                        error: err,
                        errorSource: "processMessageCallback",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        identifier: this.identifier,
                    });
                    throw err;
                }
            },
            postInitialize: async () => {
                if (!userHandlers.postInitialize) {
                    return;
                }
                return userHandlers.postInitialize().catch((err) => this._messageHandlers().processError({
                    error: err,
                    errorSource: "processMessageCallback",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: this.identifier,
                }));
            },
            preInitialize: async () => {
                if (!userHandlers.preInitialize) {
                    return;
                }
                return userHandlers.preInitialize().catch((err) => this._messageHandlers().processError({
                    error: err,
                    errorSource: "processMessageCallback",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: this.identifier,
                }));
            },
            forwardInternalErrors: userHandlers.forwardInternalErrors ?? false,
        };
        this._messageHandlers = () => messageHandlers;
    }
    /**
     * Subscribes using the already assigned `this._messageHandlers` and `this._subscribeOptions`
     *
     * @returns A promise that will resolve when a link is created and we successfully add credits to it.
     */
    async _subscribeImpl(caller) {
        try {
            // we don't expect to ever get an error from retryForever but bugs
            // do happen.
            return await this._retryForeverFn({
                retryConfig: {
                    connectionId: this._context.connection.id,
                    operationType: coreAmqp.RetryOperationType.receiverLink,
                    abortSignal: this._subscribeOptions?.abortSignal,
                    retryOptions: this._retryOptions,
                    operation: () => this._initAndAddCreditOperation(caller),
                },
                onError: (err) => this._messageHandlers().processError({
                    error: err,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: this.identifier,
                }),
                logPrefix: this.logPrefix,
                logger: receiverLogger,
            });
        }
        catch (err) {
            try {
                await this._receiverHelper.suspend();
            }
            catch (error) {
                receiverLogger.logError(error, `${this.logPrefix} receiver.suspend threw an error`);
            }
            throw err;
        }
    }
    /**
     * Initializes the link and adds credits. If any of these operations fail any created link will
     * be closed.
     *
     * @param caller - The caller which dictates whether or not we create a new name for our created link.
     * @param catchAndReportError - A function and reports an error but does not throw it.
     */
    async _initAndAddCreditOperation(caller) {
        if (this._receiverHelper.isSuspended()) {
            // user has suspended us while we were initializing
            // the connection. Abort this attempt - if they attempt
            // resubscribe we'll just reinitialize.
            // This checks should happen before throwErrorIfConnectionClosed(); otherwise
            // we won't be able to break out of the retry-for-ever loops when user suspend us.
            throw new abortController.AbortError("Receiver was suspended during initialization.");
        }
        throwErrorIfConnectionClosed(this._context);
        await this._messageHandlers().preInitialize();
        if (this._receiverHelper.isSuspended()) {
            // Need to check again as user can suspend us in preInitialize()
            throw new abortController.AbortError("Receiver was suspended during initialization.");
        }
        await this._init(this._createReceiverOptions(caller === "detach", this._getHandlers()), this._subscribeOptions?.abortSignal);
        try {
            await this._messageHandlers().postInitialize();
            this._receiverHelper.addCredit(this.maxConcurrentCalls);
        }
        catch (err) {
            try {
                await this.closeLink();
            }
            catch (error) {
                await this._messageHandlers().processError({
                    error,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: this.identifier,
                });
            }
            throw err;
        }
    }
    /**
     * Will reconnect the receiver link if necessary.
     * @param receiverError - The receiver error or connection error, if any.
     */
    async onDetached(receiverError) {
        try {
            receiverLogger.verbose(`${this.logPrefix} onDetached: reinitializing link.`);
            // User explicitly called `close` on the receiver, so link is already closed
            // and we can exit early.
            if (this.wasClosedPermanently) {
                receiverLogger.verbose(`${this.logPrefix} onDetached: link has been closed permanently, not reinitializing. `);
                return;
            }
            // Prevent multiple onDetached invocations from running concurrently.
            if (this._isDetaching) {
                // This can happen when the network connection goes down for some amount of time.
                // The first connection `disconnect` will trigger `onDetached` and attempt to retry
                // creating the connection/receiver link.
                // While those retry attempts fail (until the network connection comes back up),
                // we'll continue to see connection `disconnect` errors.
                // These should be ignored until the already running `onDetached` completes
                // its retry attempts or errors.
                receiverLogger.verbose(`${this.logPrefix} onDetached: Call to detached on streaming receiver '${this.name}' is already in progress.`);
                return;
            }
            this._isDetaching = true;
            const translatedError = receiverError
                ? translateServiceBusError(receiverError)
                : receiverError;
            receiverLogger.logError(translatedError, `${this.logPrefix} onDetached: Reinitializing receiver because of error`);
            // Clears the token renewal timer. Closes the link and its session if they are open.
            // Removes the link and its session if they are present in rhea's cache.
            await this.closeLink();
        }
        catch (err) {
            receiverLogger.verbose(`${this.logPrefix} onDetached: Encountered an error when closing the previous link: `, err);
        }
        try {
            await this._subscribeImpl("detach");
        }
        finally {
            this._isDetaching = false;
        }
    }
    removeLinkFromContext() {
        delete this._context.messageReceivers[this.name];
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Describes the batching receiver where the user can receive a specified number of messages for
 * a predefined time.
 * @internal
 */
class BatchingReceiver extends MessageReceiver {
    /**
     * Instantiate a new BatchingReceiver.
     *
     * @param identifier - name to identify this receiver.
     * @param connectionContext - The client entity context.
     * @param options - Options for how you'd like to connect.
     */
    constructor(identifier, connectionContext, entityPath, options) {
        super(identifier, connectionContext, entityPath, "batching", options);
        this._batchingReceiverLite = new BatchingReceiverLite(connectionContext, entityPath, async (abortSignal) => {
            let lastError;
            const rcvrOptions = this._createReceiverOptions(false, {
                onError: (context) => {
                    lastError = context?.receiver?.error;
                },
                onSessionError: (context) => {
                    lastError = context?.session?.error;
                },
                onClose: async () => {
                    /** Nothing to do here - the next call will just fail so they'll get an appropriate error from somewhere else. */
                },
                onSessionClose: async () => {
                    /** Nothing to do here - the next call will just fail so they'll get an appropriate error from somewhere else. */
                },
                onMessage: async () => {
                    /** Nothing to do here -  we don't add credits initially so we don't need to worry about handling any messages.*/
                },
            });
            await this._init(rcvrOptions, abortSignal);
            if (lastError != null) {
                throw lastError;
            }
            return this.link;
        }, this.receiveMode, options.skipParsingBodyAsJson ?? false, options.skipConvertingDate ?? false);
    }
    get isReceivingMessages() {
        return this._batchingReceiverLite.isReceivingMessages;
    }
    /**
     * To be called when connection is disconnected to gracefully close ongoing receive request.
     * @param connectionError - The connection error if any.
     */
    async onDetached(connectionError) {
        await this.closeLink();
        if (connectionError == null) {
            connectionError = new Error("Unknown error occurred on the AMQP connection while receiving messages.");
        }
        this._batchingReceiverLite.terminate(connectionError);
    }
    /**
     * Receives a batch of messages from a ServiceBus Queue/Topic.
     * @param maxMessageCount - The maximum number of messages to receive.
     * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.
     * @param maxWaitTimeInMs - The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.
     * @param maxTimeAfterFirstMessageInMs - The total amount of time to wait after the first message
     * has been received. Defaults to 1 second.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * @returns A promise that resolves with an array of Message objects.
     */
    async receive(maxMessageCount, maxWaitTimeInMs, maxTimeAfterFirstMessageInMs, options) {
        throwErrorIfConnectionClosed(this._context);
        try {
            const messages = await this._batchingReceiverLite.receiveMessages({
                maxMessageCount,
                maxWaitTimeInMs,
                maxTimeAfterFirstMessageInMs,
                ...options,
            });
            if (this._lockRenewer) {
                for (const message of messages) {
                    this._lockRenewer.start(this, message, (_error) => {
                        // the auto lock renewer already logs this in a detailed way. So this hook is mainly here
                        // to potentially forward the error to the user (which we're not doing yet)
                    });
                }
            }
            return messages;
        }
        catch (error) {
            receiverLogger.logError(error, "[%s] Rejecting receiveMessages()", this.logPrefix);
            throw error;
        }
    }
    static create(clientId, context, entityPath, options) {
        throwErrorIfConnectionClosed(context);
        const bReceiver = new BatchingReceiver(clientId, context, entityPath, options);
        context.messageReceivers[bReceiver.name] = bReceiver;
        return bReceiver;
    }
    removeLinkFromContext() {
        delete this._context.messageReceivers[this.name];
    }
}
/**
 * Gets a function that returns the smaller of the two timeouts,
 * taking into account elapsed time from when getRemainingWaitTimeInMsFn
 * was called.
 *
 * @param maxWaitTimeInMs - Maximum time to wait for the first message
 * @param maxTimeAfterFirstMessageInMs - Maximum time to wait after the first message before completing the receive.
 *
 * @internal
 */
function getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs) {
    const startTimeMs = Date.now();
    return () => {
        const remainingTimeMs = maxWaitTimeInMs - (Date.now() - startTimeMs);
        if (remainingTimeMs < 0) {
            return 0;
        }
        return Math.min(remainingTimeMs, maxTimeAfterFirstMessageInMs);
    };
}
/**
 * The internals of a batching receiver minus anything that would require us to hold onto a client entity context
 * or a receiver on a permanent basis.
 *
 * Usable with both session and non-session receivers.
 *
 * @internal
 */
class BatchingReceiverLite {
    constructor(_connectionContext, entityPath, _getCurrentReceiver, _receiveMode, _skipParsingBodyAsJson, _skipConvertingDate) {
        this._connectionContext = _connectionContext;
        this.entityPath = entityPath;
        this._getCurrentReceiver = _getCurrentReceiver;
        this._receiveMode = _receiveMode;
        // testing hook
        this._drainTimeoutInMs = receiveDrainTimeoutInMs;
        this._createServiceBusMessage = (context) => {
            return new ServiceBusMessageImpl(context.message, context.delivery, true, this._receiveMode, _skipParsingBodyAsJson, _skipConvertingDate);
        };
        this._getRemainingWaitTimeInMsFn = (maxWaitTimeInMs, maxTimeAfterFirstMessageInMs) => getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs);
        this.isReceivingMessages = false;
    }
    /**
     * Receives a set of messages,
     *
     * @internal
     * @hidden
     */
    async receiveMessages(args) {
        try {
            this.isReceivingMessages = true;
            const receiver = await this._getCurrentReceiver(args.abortSignal);
            if (receiver == null) {
                // (was somehow closed in between the init() and the return)
                throw new ServiceBusError("Link closed before receiving messages.", "GeneralError");
            }
            const messages = await new Promise((resolve, reject) => this._receiveMessagesImpl(receiver, args, resolve, reject));
            return tracingClient.withSpan("BatchingReceiverLite.process", args, () => messages, toProcessingSpanOptions(messages, this, this._connectionContext.config, "process"));
        }
        finally {
            this._closeHandler = undefined;
            this.isReceivingMessages = false;
        }
    }
    /**
     * Closes the receiver (optionally with an error), cancelling any current operations.
     *
     * @param connectionError - An optional error (rhea doesn't always deliver one for certain disconnection events)
     */
    terminate(connectionError) {
        if (this._closeHandler) {
            this._closeHandler(connectionError);
            this._closeHandler = undefined;
        }
    }
    async tryDrainReceiver(receiver, loggingPrefix, remainingWaitTimeInMs, abortSignal) {
        if (!receiver.isOpen() || receiver.credit <= 0) {
            return;
        }
        let drainTimedout = false;
        let drainTimer;
        const timeToWaitInMs = Math.max(this._drainTimeoutInMs, remainingWaitTimeInMs);
        const drainPromise = new Promise((resolve) => {
            function drainListener() {
                receiverLogger.verbose(`${loggingPrefix} Receiver has been drained.`);
                clearTimeout(drainTimer);
                resolve();
            }
            function removeListeners() {
                abortSignal?.removeEventListener("abort", onAbort);
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverDrained, drainListener);
            }
            function onAbort() {
                removeListeners();
                clearTimeout(drainTimer);
                resolve();
            }
            drainTimer = setTimeout(() => {
                drainTimedout = true;
                removeListeners();
                resolve();
            }, timeToWaitInMs);
            receiver.once(rheaPromise.ReceiverEvents.receiverDrained, drainListener);
            abortSignal?.addEventListener("abort", onAbort);
        });
        receiver.drainCredit();
        receiverLogger.verbose(`${loggingPrefix} Draining leftover credits(${receiver.credit}), waiting for event_drained event, or timing out after ${timeToWaitInMs} milliseconds...`);
        await drainPromise;
        if (drainTimedout) {
            receiverLogger.warning(`${loggingPrefix} Time out after ${timeToWaitInMs} milliseconds when draining credits. Closing receiver...`);
            // Close the receiver link since we have not received the receiver drain event
            // to prevent out-of-sync state between local and remote
            await receiver.close();
        }
        // Turn off draining.
        receiver.drain = false;
    }
    _receiveMessagesImpl(receiver, args, origResolve, origReject) {
        const getRemainingWaitTimeInMs = this._getRemainingWaitTimeInMsFn(args.maxWaitTimeInMs, args.maxTimeAfterFirstMessageInMs);
        const brokeredMessages = [];
        const loggingPrefix = `[${receiver.connection.id}|r:${receiver.name}]`;
        let totalWaitTimer;
        // eslint-disable-next-line prefer-const
        let cleanupBeforeResolveOrReject;
        const rejectAfterCleanup = (err) => {
            cleanupBeforeResolveOrReject();
            origReject(err);
        };
        const resolveImmediately = (result) => {
            cleanupBeforeResolveOrReject();
            origResolve(result);
        };
        const resolveAfterPendingMessageCallbacks = (result) => {
            // NOTE: through rhea-promise, most of our event handlers are made asynchronous by calling setTimeout(emit).
            // However, a small set (*error and drain) execute immediately. This can lead to a situation where the logical
            // ordering of events is correct but the execution order is incorrect because the events are not all getting
            // put into the task queue the same way.
            // setTimeout() ensures that we resolve _after_ any already-queued onMessage handlers that may
            // be waiting in the task queue.
            setTimeout(() => {
                cleanupBeforeResolveOrReject();
                origResolve(result);
            });
        };
        const onError = (context) => {
            const eventType = context.session?.error != null ? "session_error" : "receiver_error";
            let error = context.session?.error || context.receiver?.error;
            if (error) {
                error = translateServiceBusError(error);
                receiverLogger.logError(error, `${loggingPrefix} '${eventType}' event occurred. Received an error`);
            }
            else {
                error = new ServiceBusError("An error occurred while receiving messages.", "GeneralError");
            }
            rejectAfterCleanup(error);
        };
        this._closeHandler = (error) => {
            if (
            // no error, just closing. Go ahead and return what we have.
            error == null ||
                // Return the collected messages if in ReceiveAndDelete mode because otherwise they are lost forever
                (this._receiveMode === "receiveAndDelete" && brokeredMessages.length)) {
                receiverLogger.verbose(`${loggingPrefix} Closing. Resolving with ${brokeredMessages.length} messages.`);
                return resolveAfterPendingMessageCallbacks(brokeredMessages);
            }
            rejectAfterCleanup(translateServiceBusError(error));
        };
        let abortSignalCleanupFunction = undefined;
        // Final action to be performed after
        // - maxMessageCount is reached or
        // - maxWaitTime is passed or
        // - newMessageWaitTimeoutInSeconds is passed since the last message was received
        this._finalAction = async () => {
            if (receiver.drain) {
                // If a drain is already in process then we should let it complete. Some messages might still be in flight, but they will
                // arrive before the drain completes.
                receiverLogger.verbose(`${loggingPrefix} Already draining.`);
                return;
            }
            const remainingWaitTimeInMs = getRemainingWaitTimeInMs();
            await this.tryDrainReceiver(receiver, loggingPrefix, remainingWaitTimeInMs, args.abortSignal);
            receiverLogger.verbose(`${loggingPrefix} Resolving receiveMessages() with ${brokeredMessages.length} messages.`);
            resolveImmediately(brokeredMessages);
        };
        // Action to be performed on the "message" event.
        const onReceiveMessage = async (context) => {
            // TODO: this appears to be aggravating a bug that we need to look into more deeply.
            // The same timeout+drain sequence should work fine for receiveAndDelete but it appears
            // to cause problems.
            if (this._receiveMode === "peekLock") {
                if (brokeredMessages.length === 0) {
                    // We'll now remove the old timer (which was the overall `maxWaitTimeMs` timer)
                    // and replace it with another timer that is a (probably) much shorter interval.
                    //
                    // This allows the user to get access to received messages earlier and also gives us
                    // a chance to have fewer messages internally that could get lost if the user's
                    // app crashes.
                    if (totalWaitTimer)
                        clearTimeout(totalWaitTimer);
                    const remainingWaitTimeInMs = getRemainingWaitTimeInMs();
                    totalWaitTimer = setTimeout(() => {
                        receiverLogger.verbose(`${loggingPrefix} Batching, waited for ${remainingWaitTimeInMs} milliseconds after receiving the first message.`);
                        this._finalAction();
                    }, remainingWaitTimeInMs);
                }
            }
            try {
                const data = this._createServiceBusMessage(context);
                brokeredMessages.push(data);
                // NOTE: we used to actually "lose" any extra messages. At this point I've fixed the areas that were causing us to receive
                // extra messages but if this bug arises in some other way it's better to return the message than it would be to let it be
                // silently dropped on the floor.
                if (brokeredMessages.length > args.maxMessageCount) {
                    receiverLogger.warning(`More messages arrived than expected: ${args.maxMessageCount} vs ${brokeredMessages.length}`);
                }
            }
            catch (err) {
                const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));
                receiverLogger.logError(err, `${loggingPrefix} Received an error while converting AmqpMessage to ServiceBusMessage`);
                rejectAfterCleanup(errObj);
            }
            if (brokeredMessages.length >= args.maxMessageCount) {
                this._finalAction();
            }
        };
        const onClose = async (context) => {
            const type = context.session?.error != null ? "session_closed" : "receiver_closed";
            const error = context.session?.error || context.receiver?.error;
            if (error) {
                receiverLogger.logError(error, `${loggingPrefix} '${type}' event occurred. The associated error`);
            }
        };
        cleanupBeforeResolveOrReject = () => {
            if (receiver != null) {
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverError, onError);
                receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                receiver.session.removeListener(rheaPromise.SessionEvents.sessionError, onError);
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverClose, onClose);
                receiver.session.removeListener(rheaPromise.SessionEvents.sessionClose, onClose);
            }
            if (totalWaitTimer) {
                clearTimeout(totalWaitTimer);
            }
            if (abortSignalCleanupFunction) {
                abortSignalCleanupFunction();
            }
            abortSignalCleanupFunction = undefined;
        };
        abortSignalCleanupFunction = checkAndRegisterWithAbortSignal((err) => {
            if (receiver.drain) {
                // If a drain is already in process and we cancel, the link state may be out of sync
                // with remote. Reset the link so that we will have fresh start.
                receiver.close();
            }
            rejectAfterCleanup(err);
        }, args.abortSignal);
        // By adding credit here, we let the service know that at max we can handle `maxMessageCount`
        // number of messages concurrently. We will return the user an array of messages that can
        // be of size upto maxMessageCount. Then the user needs to accordingly dispose
        // (complete/abandon/defer/deadletter) the messages from the array.
        const creditToAdd = args.maxMessageCount - receiver.credit;
        receiverLogger.verbose(`${loggingPrefix} Ensure enough credit for receiving ${args.maxMessageCount} messages. Current: ${receiver.credit}.  To add: ${creditToAdd}.`);
        if (creditToAdd > 0) {
            receiver.addCredit(creditToAdd);
        }
        receiverLogger.verbose(`${loggingPrefix} Setting the wait timer for ${args.maxWaitTimeInMs} milliseconds.`);
        totalWaitTimer = setTimeout(() => {
            receiverLogger.verbose(`${loggingPrefix} Batching, waited for max wait time ${args.maxWaitTimeInMs} milliseconds.`);
            this._finalAction();
        }, args.maxWaitTimeInMs);
        receiver.on(rheaPromise.ReceiverEvents.message, onReceiveMessage);
        receiver.on(rheaPromise.ReceiverEvents.receiverError, onError);
        receiver.on(rheaPromise.ReceiverEvents.receiverClose, onClose);
        receiver.session.on(rheaPromise.SessionEvents.sessionError, onError);
        receiver.session.on(rheaPromise.SessionEvents.sessionClose, onClose);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Tracks locks for messages, renewing until a configurable duration.
 *
 * @internal
 */
class LockRenewer {
    constructor(_context, _maxAutoRenewDurationInMs) {
        this._context = _context;
        this._maxAutoRenewDurationInMs = _maxAutoRenewDurationInMs;
        /**
         * A map of link names to individual maps for each
         * link that map a message ID to its auto-renewal timer.
         */
        this._messageRenewLockTimers = new Map();
        this._calculateRenewAfterDuration = calculateRenewAfterDuration;
    }
    /**
     * Creates an AutoLockRenewer.
     *
     * @param linkEntity - Your link entity instance (probably 'this')
     * @param context - The connection context for your link entity (probably 'this._context')
     * @param options - The ReceiveOptions passed through to your message receiver.
     * @returns if the lock mode is peek lock (or if is unspecified, thus defaulting to peekLock)
     * and the options.maxAutoLockRenewalDurationInMs is greater than 0..Otherwise, returns undefined.
     */
    static create(context, maxAutoRenewLockDurationInMs, receiveMode) {
        if (receiveMode !== "peekLock") {
            return undefined;
        }
        if (maxAutoRenewLockDurationInMs <= 0) {
            return undefined;
        }
        return new LockRenewer(context, maxAutoRenewLockDurationInMs);
    }
    /**
     * Cancels all pending lock renewals for messages on given link and removes all entries from our internal cache.
     */
    stopAll(linkEntity) {
        receiverLogger.verbose(`${linkEntity.logPrefix} Clearing message renew lock timers for all the active messages.`);
        const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);
        if (messagesForLink == null) {
            return;
        }
        for (const messageId of messagesForLink.keys()) {
            this._stopAndRemoveById(linkEntity, messagesForLink, messageId);
        }
        this._messageRenewLockTimers.delete(linkEntity.name);
    }
    /**
     * Stops lock renewal for a single message.
     *
     * @param bMessage - The message whose lock renewal we will stop.
     */
    stop(linkEntity, bMessage) {
        const messageId = bMessage.messageId;
        const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);
        if (messagesForLink == null) {
            return;
        }
        this._stopAndRemoveById(linkEntity, messagesForLink, messageId);
    }
    /**
     * Starts lock renewal for a single message.
     *
     * @param bMessage - The message whose lock renewal we will start.
     */
    start(linkEntity, bMessage, onError) {
        try {
            const logPrefix = linkEntity.logPrefix;
            if (bMessage.lockToken == null) {
                throw new Error(`Can't start auto lock renewal for message with message id '${bMessage.messageId}' since it does not have a lock token.`);
            }
            const lockToken = bMessage.lockToken;
            const linkMessageMap = this._getOrCreateMapForLink(linkEntity);
            // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.
            // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInMs
            // - We should be able to clear the renewal timer when the user's message handler
            // is done (whether it succeeds or fails).
            // Setting the messageId with undefined value in the linkMessageMap because we
            // track state by checking the presence of messageId in the map. It is removed from the map
            // when an attempt is made to settle the message (either by the user or by the sdk) OR
            // when the execution of user's message handler completes.
            linkMessageMap.set(bMessage.messageId, undefined);
            receiverLogger.verbose(`${logPrefix} message with id '${bMessage.messageId}' is locked until ${bMessage.lockedUntilUtc.toString()}.`);
            const totalAutoLockRenewDuration = Date.now() + this._maxAutoRenewDurationInMs;
            const totalAutoLockRenewDurationDate = new Date(totalAutoLockRenewDuration);
            receiverLogger.verbose(`${logPrefix} Total autolockrenew duration for message with id '${bMessage.messageId}' is: ${totalAutoLockRenewDurationDate.toString()}`);
            const autoRenewLockTask = () => {
                const renewalNeededToMaintainLock = 
                // if the lock expires _after_ our max auto-renew duration there's no reason to
                // spin up an auto-renewer - it's already held for the duration.
                totalAutoLockRenewDurationDate > bMessage.lockedUntilUtc;
                if (!renewalNeededToMaintainLock) {
                    receiverLogger.verbose(`${logPrefix} Autolockrenew not needed as message's lockedUntilUtc ${bMessage.lockedUntilUtc} is after the total autolockrenew duration ${totalAutoLockRenewDurationDate} for message with messageId '${bMessage.messageId}'. Hence we will stop the autoLockRenewTask.`);
                    this.stop(linkEntity, bMessage);
                }
                else if (Date.now() >= totalAutoLockRenewDuration) {
                    // once we've exceeded the max amount of time we'll renew we can stop.
                    receiverLogger.verbose(`${logPrefix} Current time ${new Date()} exceeds the total autolockrenew duration ${totalAutoLockRenewDurationDate} for message with messageId '${bMessage.messageId}'. Hence we will stop the autoLockRenewTask.`);
                    this.stop(linkEntity, bMessage);
                }
                else {
                    if (linkMessageMap.has(bMessage.messageId)) {
                        // TODO: We can run into problems with clock skew between the client and the server.
                        // It would be better to calculate the duration based on the "lockDuration" property
                        // of the queue. However, we do not have the management plane of the client ready for
                        // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.
                        const amount = this._calculateRenewAfterDuration(bMessage.lockedUntilUtc);
                        receiverLogger.verbose(`${logPrefix} Sleeping for ${amount} milliseconds while renewing the lock for message with id '${bMessage.messageId}'`);
                        // Setting the value of the messageId to the actual timer. This will be cleared when
                        // an attempt is made to settle the message (either by the user or by the sdk) OR
                        // when the execution of user's message handler completes.
                        const autoRenewTimer = setTimeout(async () => {
                            try {
                                receiverLogger.verbose(`${logPrefix} Attempting to renew the lock for message with id '${bMessage.messageId}'.`);
                                bMessage.lockedUntilUtc = await this._context
                                    .getManagementClient(linkEntity.entityPath)
                                    .renewLock(lockToken, {
                                    associatedLinkName: linkEntity.name,
                                });
                                receiverLogger.verbose(`${logPrefix} Successfully renewed the lock for message with id '${bMessage.messageId}'. Starting next auto-lock-renew cycle for message.`);
                                autoRenewLockTask();
                            }
                            catch (err) {
                                receiverLogger.logError(err, `${logPrefix} An error occurred while auto renewing the message lock '${bMessage.lockToken}' for message with id '${bMessage.messageId}'`);
                                onError(err);
                            }
                        }, amount);
                        // Prevent the active Timer from keeping the Node.js event loop active.
                        if (typeof autoRenewTimer.unref === "function") {
                            autoRenewTimer.unref();
                        }
                        linkMessageMap.set(bMessage.messageId, autoRenewTimer);
                    }
                    else {
                        receiverLogger.verbose(`${logPrefix} Looks like the message lock renew timer has already been cleared for message with id '${bMessage.messageId}'.`);
                    }
                }
            };
            // start
            autoRenewLockTask();
        }
        catch (err) {
            onError(err);
        }
    }
    _getOrCreateMapForLink(linkEntity) {
        if (!this._messageRenewLockTimers.has(linkEntity.name)) {
            this._messageRenewLockTimers.set(linkEntity.name, new Map());
        }
        return this._messageRenewLockTimers.get(linkEntity.name);
    }
    _stopAndRemoveById(linkEntity, linkMessageMap, messageId) {
        if (messageId == null) {
            throw new Error("Failed to stop auto lock renewal - no message ID");
        }
        // TODO: messageId doesn't actually need to be unique. Perhaps we should use lockToken
        // instead?
        if (linkMessageMap.has(messageId)) {
            clearTimeout(linkMessageMap.get(messageId));
            receiverLogger.verbose(`${linkEntity.logPrefix} Cleared the message renew lock timer for message with id '${messageId}'.`);
            linkMessageMap.delete(messageId);
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The default time to wait for messages _after_ the first message
 * has been received.
 *
 * This timeout only applies to receiveMessages()
 *
 * @internal
 */
const defaultMaxTimeAfterFirstMessageForBatchingMs = 1000;
/**
 * @internal
 */
class ServiceBusReceiverImpl {
    get logPrefix() {
        return `[${this._context.connectionId}|receiver:${this.entityPath}]`;
    }
    /**
     * @throws Error if the underlying connection is closed.
     */
    constructor(_context, entityPath, receiveMode, maxAutoRenewLockDurationInMs, skipParsingBodyAsJson, skipConvertingDate = false, retryOptions = {}, identifier) {
        this._context = _context;
        this.entityPath = entityPath;
        this.receiveMode = receiveMode;
        this.skipParsingBodyAsJson = skipParsingBodyAsJson;
        this.skipConvertingDate = skipConvertingDate;
        /**
         * Denotes if close() was called on this receiver
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this._retryOptions = retryOptions;
        this._lockRenewer = LockRenewer.create(this._context, maxAutoRenewLockDurationInMs, receiveMode);
        this.identifier = ensureValidIdentifier(this.entityPath, identifier);
    }
    _throwIfAlreadyReceiving() {
        if (this._isReceivingMessages()) {
            const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath);
            const error = new Error(errorMessage);
            receiverLogger.logError(error, `${this.logPrefix} is already receiving`);
            throw error;
        }
    }
    _throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (this.isClosed) {
            const errorMessage = getReceiverClosedErrorMsg(this.entityPath);
            const error = new Error(errorMessage);
            receiverLogger.logError(error, `${this.logPrefix} is closed`);
            throw error;
        }
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    async receiveMessages(maxMessageCount, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        throwTypeErrorIfParameterMissing(this._context.connectionId, "maxMessageCount", maxMessageCount);
        throwTypeErrorIfParameterTypeMismatch(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
        if (isNaN(maxMessageCount) || maxMessageCount < 1) {
            throw new TypeError(InvalidMaxMessageCountError);
        }
        const receiveMessages = async () => {
            if (!this._batchingReceiver || !this._context.messageReceivers[this._batchingReceiver.name]) {
                const receiveOptions = {
                    maxConcurrentCalls: 0,
                    receiveMode: this.receiveMode,
                    lockRenewer: this._lockRenewer,
                    skipParsingBodyAsJson: this.skipParsingBodyAsJson,
                    skipConvertingDate: this.skipConvertingDate,
                };
                this._batchingReceiver = this._createBatchingReceiver(this._context, this.entityPath, receiveOptions);
            }
            const receivedMessages = await this._batchingReceiver.receive(maxMessageCount, options?.maxWaitTimeInMs ?? coreAmqp.Constants.defaultOperationTimeoutInMs, defaultMaxTimeAfterFirstMessageForBatchingMs, options ?? {});
            return receivedMessages;
        };
        const config = {
            connectionHost: this._context.config.host,
            connectionId: this._context.connectionId,
            operation: receiveMessages,
            operationType: coreAmqp.RetryOperationType.receiveMessage,
            abortSignal: options?.abortSignal,
            retryOptions: this._retryOptions,
        };
        return coreAmqp.retry(config).catch((err) => {
            throw translateServiceBusError(err);
        });
    }
    getMessageIterator(options) {
        return getMessageIterator(this, options);
    }
    async receiveDeferredMessages(sequenceNumbers, options = {}) {
        this._throwIfReceiverOrConnectionClosed();
        throwTypeErrorIfParameterMissing(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        throwTypeErrorIfParameterNotLong(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        const deferredSequenceNumbers = Array.isArray(sequenceNumbers)
            ? sequenceNumbers
            : [sequenceNumbers];
        const receiveDeferredMessagesOperationPromise = async () => {
            const deferredMessages = await this._context
                .getManagementClient(this.entityPath)
                .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, undefined, {
                ...options,
                associatedLinkName: this._getAssociatedReceiverName(),
                requestName: "receiveDeferredMessages",
                timeoutInMs: this._retryOptions.timeoutInMs,
                skipParsingBodyAsJson: this.skipParsingBodyAsJson,
                skipConvertingDate: this.skipConvertingDate,
            });
            return deferredMessages;
        };
        const config = {
            operation: receiveDeferredMessagesOperationPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.management,
            retryOptions: this._retryOptions,
            abortSignal: options?.abortSignal,
        };
        return coreAmqp.retry(config);
    }
    // ManagementClient methods # Begin
    async peekMessages(maxMessageCount, options = {}) {
        this._throwIfReceiverOrConnectionClosed();
        const managementRequestOptions = {
            ...options,
            associatedLinkName: this._getAssociatedReceiverName(),
            requestName: "peekMessages",
            timeoutInMs: this._retryOptions?.timeoutInMs,
            skipParsingBodyAsJson: this.skipParsingBodyAsJson,
            skipConvertingDate: this.skipConvertingDate,
        };
        const peekOperationPromise = async () => {
            if (options.fromSequenceNumber !== undefined) {
                return this._context
                    .getManagementClient(this.entityPath)
                    .peekBySequenceNumber(options.fromSequenceNumber, maxMessageCount, undefined, options.omitMessageBody, managementRequestOptions);
            }
            else {
                return this._context
                    .getManagementClient(this.entityPath)
                    .peek(maxMessageCount, options.omitMessageBody, managementRequestOptions);
            }
        };
        const config = {
            operation: peekOperationPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.management,
            retryOptions: this._retryOptions,
            abortSignal: options?.abortSignal,
        };
        return coreAmqp.retry(config);
    }
    subscribe(handlers, options) {
        assertValidMessageHandlers(handlers);
        throwErrorIfConnectionClosed(this._context);
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        options = {
            ...(options ?? {}),
            autoCompleteMessages: options?.autoCompleteMessages ?? true,
        };
        // When the user "stops" a streaming receiver (via the returned instance from 'subscribe' we just suspend
        // it, leaving the link open). This allows users to stop the flow of messages but still be able to settle messages
        // since the link itself hasn't been shut down.
        //
        // Users can, if they want, restart their subscription (since we've got a link already established).
        // So you'll have an instance here if the user has done:
        // 1. const subscription = receiver.subscribe()
        // 2. subscription.stop()
        // 3. receiver.subscribe()
        this._streamingReceiver =
            this._streamingReceiver ??
                new StreamingReceiver(this.identifier, this._context, this.entityPath, {
                    ...options,
                    receiveMode: this.receiveMode,
                    retryOptions: this._retryOptions,
                    lockRenewer: this._lockRenewer,
                    skipParsingBodyAsJson: this.skipParsingBodyAsJson,
                    skipConvertingDate: this.skipConvertingDate,
                });
        // this ensures that if the outer service bus client is closed that  this receiver is cleaned up.
        // this mostly affects us if we're in the middle of init() - the connection (and receiver) are not yet
        // open but we do need to close the receiver to exit the init() loop.
        this._context.messageReceivers[this._streamingReceiver.name] = this._streamingReceiver;
        this._streamingReceiver.subscribe(handlers, options).catch((_) => {
            // (the error will already have been reported to the user)
            if (this._streamingReceiver) {
                delete this._context.messageReceivers[this._streamingReceiver.name];
            }
        });
        return {
            close: async () => {
                return this._streamingReceiver?.stopReceivingMessages();
            },
        };
    }
    async completeMessage(message) {
        this._throwIfReceiverOrConnectionClosed();
        throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return completeMessage(msgImpl, this._context, this.entityPath, this._retryOptions);
    }
    async abandonMessage(message, propertiesToModify) {
        this._throwIfReceiverOrConnectionClosed();
        throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return abandonMessage(msgImpl, this._context, this.entityPath, propertiesToModify, this._retryOptions);
    }
    async deferMessage(message, propertiesToModify) {
        this._throwIfReceiverOrConnectionClosed();
        throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return deferMessage(msgImpl, this._context, this.entityPath, propertiesToModify, this._retryOptions);
    }
    async deadLetterMessage(message, options) {
        this._throwIfReceiverOrConnectionClosed();
        throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return deadLetterMessage(msgImpl, this._context, this.entityPath, options, this._retryOptions);
    }
    async renewMessageLock(message) {
        this._throwIfReceiverOrConnectionClosed();
        throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
        const tracingContext = extractSpanContextFromServiceBusMessage(message);
        const spanLinks = tracingContext ? [{ tracingContext }] : [];
        return tracingClient.withSpan("ServiceBusReceiver.renewMessageLock", {}, () => {
            const msgImpl = message;
            let associatedLinkName;
            if (msgImpl.delivery.link) {
                const associatedReceiver = this._context.getReceiverFromCache(msgImpl.delivery.link.name);
                associatedLinkName = associatedReceiver?.name;
            }
            return this._context
                .getManagementClient(this.entityPath)
                .renewLock(message.lockToken, { associatedLinkName })
                .then((lockedUntil) => {
                message.lockedUntilUtc = lockedUntil;
                return lockedUntil;
            });
        }, {
            spanLinks,
            ...toSpanOptions({ entityPath: this.entityPath, host: this._context.config.host }, "receive", "client"),
        });
    }
    async close() {
        try {
            this._isClosed = true;
            if (this._context.connection && this._context.connection.isOpen()) {
                // Close the streaming receiver.
                if (this._streamingReceiver) {
                    await this._streamingReceiver.close();
                }
                // Close the batching receiver.
                if (this._batchingReceiver) {
                    await this._batchingReceiver.close();
                }
            }
        }
        catch (err) {
            receiverLogger.logError(err, `${this.logPrefix} An error occurred while closing the Receiver`);
            throw err;
        }
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */
    _isReceivingMessages() {
        if (this._streamingReceiver &&
            this._streamingReceiver.isOpen() &&
            this._streamingReceiver.isSubscribeActive) {
            return true;
        }
        if (this._batchingReceiver &&
            this._batchingReceiver.isOpen() &&
            this._batchingReceiver.isReceivingMessages) {
            return true;
        }
        return false;
    }
    _createBatchingReceiver(context, entityPath, options) {
        const receiver = BatchingReceiver.create(this.identifier, context, entityPath, options);
        receiverLogger.verbose(`[${this.logPrefix}] receiver '${receiver.name}' created, with maxConcurrentCalls set to ${options.maxConcurrentCalls}.`);
        return receiver;
    }
    /**
     * Helper function to retrieve any active receiver name, regardless of streaming or
     * batching if it exists. This is used for optimization on the service side
     */
    _getAssociatedReceiverName() {
        if (this._streamingReceiver && this._streamingReceiver.isOpen()) {
            return this._streamingReceiver.name;
        }
        if (this._batchingReceiver &&
            this._batchingReceiver.isOpen() &&
            this._batchingReceiver.isReceivingMessages) {
            return this._batchingReceiver.name;
        }
        return;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
class ServiceBusSessionReceiverImpl {
    get logPrefix() {
        return `[${this._context.connectionId}|session:${this.entityPath}]`;
    }
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     * @throws Error if an open receiver is already existing for given sessionId.
     */
    constructor(_messageSession, _context, entityPath, receiveMode, _skipParsingBodyAsJson, _skipConvertingDate, _retryOptions = {}) {
        this._messageSession = _messageSession;
        this._context = _context;
        this.entityPath = entityPath;
        this.receiveMode = receiveMode;
        this._skipParsingBodyAsJson = _skipParsingBodyAsJson;
        this._skipConvertingDate = _skipConvertingDate;
        this._retryOptions = _retryOptions;
        /**
         * Denotes if close() was called on this receiver
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this.sessionId = _messageSession.sessionId;
        this.identifier = _messageSession.identifier;
    }
    _throwIfReceiverOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (this.isClosed) {
            if (this._isClosed) {
                const errorMessage = getReceiverClosedErrorMsg(this.entityPath, this.sessionId);
                const error = new Error(errorMessage);
                receiverLogger.logError(error, `${this.logPrefix} already closed`);
                throw error;
            }
            const amqpError = {
                condition: coreAmqp.ErrorNameConditionMapper.SessionLockLostError,
                description: `The session lock has expired on the session with id ${this.sessionId}`,
            };
            throw translateServiceBusError(amqpError);
        }
    }
    _throwIfAlreadyReceiving() {
        if (this._isReceivingMessages()) {
            const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath, this.sessionId);
            const error = new Error(errorMessage);
            receiverLogger.logError(error, `${this.logPrefix} is already receiving.`);
            throw error;
        }
    }
    get isClosed() {
        return (this._isClosed ||
            !this._context.messageSessions[this._messageSession.name] ||
            !this._messageSession.isOpen());
    }
    /**
     * The time in UTC until which the session is locked.
     * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock
     * duration as specified during the Queue/Subscription creation.
     *
     * When the lock on the session expires
     * - The current receiver can no longer be used to receive more messages.
     * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.
     * - Messages that were received in `peekLock` mode with this receiver but not yet settled
     * will land back in the Queue/Subscription with their delivery count incremented.
     *
     * @readonly
     */
    get sessionLockedUntilUtc() {
        return this._messageSession.sessionLockedUntilUtc;
    }
    /**
     * Renews the lock on the session for the duration as specified during the Queue/Subscription
     * creation. You can check the `sessionLockedUntilUtc` property for the time when the lock expires.
     *
     * When the lock on the session expires
     * - The current receiver can no longer be used to receive mode messages.
     * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.
     * - Messages that were received in `peekLock` mode with this receiver but not yet settled
     * will land back in the Queue/Subscription with their delivery count incremented.
     *
     * @param options - Options bag to pass an abort signal or tracing options.
     * @returns New lock token expiry date and time in UTC format.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while renewing session lock.
     */
    async renewSessionLock(options) {
        this._throwIfReceiverOrConnectionClosed();
        return tracingClient.withSpan("ServiceBusSessionReceiver.renewSessionLock", options ?? {}, (updatedOptions) => {
            const renewSessionLockOperationPromise = async () => {
                this._messageSession.sessionLockedUntilUtc = await this._context
                    .getManagementClient(this.entityPath)
                    .renewSessionLock(this.sessionId, {
                    ...updatedOptions,
                    associatedLinkName: this._messageSession.name,
                    requestName: "renewSessionLock",
                    timeoutInMs: this._retryOptions.timeoutInMs,
                });
                return this._messageSession.sessionLockedUntilUtc;
            };
            const config = {
                operation: renewSessionLockOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options?.abortSignal,
            };
            return coreAmqp.retry(config);
        });
    }
    /**
     * Sets the state on the Session. For more on session states, see
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}
     * @param state - The state that needs to be set.
     * @param options - Options bag to pass an abort signal or tracing options.
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while setting the session state.
     */
    async setSessionState(state, options = {}) {
        this._throwIfReceiverOrConnectionClosed();
        return tracingClient.withSpan("ServiceBusSessionReceiver.setSessionState", options ?? {}, (updatedOptions) => {
            const setSessionStateOperationPromise = async () => {
                await this._context
                    .getManagementClient(this.entityPath)
                    .setSessionState(this.sessionId, state, {
                    ...updatedOptions,
                    associatedLinkName: this._messageSession.name,
                    requestName: "setState",
                    timeoutInMs: this._retryOptions.timeoutInMs,
                });
                return;
            };
            const config = {
                operation: setSessionStateOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options?.abortSignal,
            };
            return coreAmqp.retry(config);
        });
    }
    /**
     * Gets the state of the Session. For more on session states, see
     * {@link https://docs.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}
     * @param options - Options bag to pass an abort signal or tracing options.
     * @returns The state of that session
     * @throws Error if the underlying connection or receiver is closed.
     * @throws `ServiceBusError` if the service returns an error while retrieving session state.
     */
    async getSessionState(options = {}) {
        this._throwIfReceiverOrConnectionClosed();
        return tracingClient.withSpan("ServiceBusSessionReceiver.getSessionState", options ?? {}, (updatedOptions) => {
            const getSessionStateOperationPromise = async () => {
                return this._context
                    .getManagementClient(this.entityPath)
                    .getSessionState(this.sessionId, {
                    ...updatedOptions,
                    associatedLinkName: this._messageSession.name,
                    requestName: "getState",
                    timeoutInMs: this._retryOptions.timeoutInMs,
                });
            };
            const config = {
                operation: getSessionStateOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options?.abortSignal,
            };
            return coreAmqp.retry(config);
        });
    }
    async peekMessages(maxMessageCount, options = {}) {
        this._throwIfReceiverOrConnectionClosed();
        const managementRequestOptions = {
            ...options,
            associatedLinkName: this._messageSession.name,
            requestName: "peekMessages",
            timeoutInMs: this._retryOptions?.timeoutInMs,
            skipParsingBodyAsJson: this._skipParsingBodyAsJson,
            skipConvertingDate: this._skipConvertingDate,
        };
        const peekOperationPromise = async () => {
            if (options.fromSequenceNumber !== undefined) {
                return this._context
                    .getManagementClient(this.entityPath)
                    .peekBySequenceNumber(options.fromSequenceNumber, maxMessageCount, this.sessionId, options.omitMessageBody, managementRequestOptions);
            }
            else {
                return this._context
                    .getManagementClient(this.entityPath)
                    .peekMessagesBySession(this.sessionId, maxMessageCount, options.omitMessageBody, managementRequestOptions);
            }
        };
        const config = {
            operation: peekOperationPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.management,
            retryOptions: this._retryOptions,
            abortSignal: options?.abortSignal,
        };
        return coreAmqp.retry(config);
    }
    async receiveDeferredMessages(sequenceNumbers, options = {}) {
        this._throwIfReceiverOrConnectionClosed();
        throwTypeErrorIfParameterMissing(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        throwTypeErrorIfParameterNotLong(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        const deferredSequenceNumbers = Array.isArray(sequenceNumbers)
            ? sequenceNumbers
            : [sequenceNumbers];
        const receiveDeferredMessagesOperationPromise = async () => {
            const deferredMessages = await this._context
                .getManagementClient(this.entityPath)
                .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, this.sessionId, {
                ...options,
                associatedLinkName: this._messageSession.name,
                requestName: "receiveDeferredMessages",
                timeoutInMs: this._retryOptions.timeoutInMs,
                skipParsingBodyAsJson: this._skipParsingBodyAsJson,
                skipConvertingDate: this._skipConvertingDate,
            });
            return deferredMessages;
        };
        const config = {
            operation: receiveDeferredMessagesOperationPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.management,
            retryOptions: this._retryOptions,
            abortSignal: options?.abortSignal,
        };
        return coreAmqp.retry(config);
    }
    async receiveMessages(maxMessageCount, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        throwTypeErrorIfParameterMissing(this._context.connectionId, "maxMessageCount", maxMessageCount);
        throwTypeErrorIfParameterTypeMismatch(this._context.connectionId, "maxMessageCount", maxMessageCount, "number");
        if (isNaN(maxMessageCount) || maxMessageCount < 1) {
            throw new TypeError(InvalidMaxMessageCountError);
        }
        const receiveBatchOperationPromise = async () => {
            const receivedMessages = await this._messageSession.receiveMessages(maxMessageCount, options?.maxWaitTimeInMs ?? coreAmqp.Constants.defaultOperationTimeoutInMs, defaultMaxTimeAfterFirstMessageForBatchingMs, options ?? {});
            return receivedMessages;
        };
        const config = {
            operation: receiveBatchOperationPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.receiveMessage,
            retryOptions: this._retryOptions,
            abortSignal: options?.abortSignal,
        };
        return coreAmqp.retry(config).catch((err) => {
            throw translateServiceBusError(err);
        });
    }
    subscribe(handlers, options) {
        // TODO - receiverOptions for subscribe??
        assertValidMessageHandlers(handlers);
        options = options ?? {};
        const processError = wrapProcessErrorHandler(handlers);
        this._registerMessageHandler(async (message) => {
            return tracingClient.withSpan("SessionReceiver.process", options ?? {}, () => handlers.processMessage(message), toProcessingSpanOptions(message, this, this._context.config, "process"));
        }, processError, options);
        return {
            close: async () => {
                return this._messageSession?.receiverHelper.suspend();
            },
        };
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver.
     *
     * Throws an error if there is another receive operation in progress on the same receiver. If you
     * are not sure whether there is another receive operation running, check the `isReceivingMessages`
     * property on the receiver.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed
     * or if the lock on the session should be automatically renewed. You can control the
     * maximum number of messages that should be concurrently processed. You can
     * also provide a timeout in milliseconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     *
     * @throws Error if the underlying connection or receiver is closed.
     * @throws Error if the receiver is already in state of receiving messages.
     * @throws `ServiceBusError` if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.
     */
    _registerMessageHandler(onMessage, onError, options) {
        this._throwIfReceiverOrConnectionClosed();
        this._throwIfAlreadyReceiving();
        const connId = this._context.connectionId;
        throwTypeErrorIfParameterMissing(connId, "onMessage", onMessage);
        throwTypeErrorIfParameterMissing(connId, "onError", onError);
        if (typeof onMessage !== "function") {
            throw new TypeError("The parameter 'onMessage' must be of type 'function'.");
        }
        if (typeof onError !== "function") {
            throw new TypeError("The parameter 'onError' must be of type 'function'.");
        }
        try {
            this._messageSession.subscribe(onMessage, onError, options);
        }
        catch (err) {
            onError({
                error: err,
                errorSource: "receive",
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host,
                identifier: this.identifier,
            });
        }
    }
    getMessageIterator(options) {
        return getMessageIterator(this, options);
    }
    async completeMessage(message) {
        this._throwIfReceiverOrConnectionClosed();
        throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return completeMessage(msgImpl, this._context, this.entityPath, this._retryOptions);
    }
    async abandonMessage(message, propertiesToModify) {
        this._throwIfReceiverOrConnectionClosed();
        throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return abandonMessage(msgImpl, this._context, this.entityPath, propertiesToModify, this._retryOptions);
    }
    async deferMessage(message, propertiesToModify) {
        this._throwIfReceiverOrConnectionClosed();
        throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return deferMessage(msgImpl, this._context, this.entityPath, propertiesToModify, this._retryOptions);
    }
    async deadLetterMessage(message, options) {
        this._throwIfReceiverOrConnectionClosed();
        throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);
        const msgImpl = message;
        return deadLetterMessage(msgImpl, this._context, this.entityPath, options, this._retryOptions);
    }
    async renewMessageLock() {
        throw new Error("Renewing message lock is an invalid operation when working with sessions.");
    }
    async close() {
        try {
            await this._messageSession.close();
        }
        catch (err) {
            receiverLogger.logError(err, "%s An error occurred while closing the SessionReceiver for session %s", this.logPrefix, this.sessionId);
            throw err;
        }
        finally {
            this._isClosed = true;
        }
    }
    /**
     * Indicates whether the receiver is currently receiving messages or not.
     * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.
     */
    _isReceivingMessages() {
        return this._messageSession ? this._messageSession.isReceivingMessages : false;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
class ServiceBusRuleManagerImpl {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     */
    constructor(_context, _entityPath, _retryOptions = {}) {
        this._context = _context;
        this._entityPath = _entityPath;
        this._retryOptions = _retryOptions;
        /**
         * Denotes if close() was called on this sender
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this.entityPath = _entityPath;
        this.name = getUniqueName("ruleManager");
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    async createRule(ruleName, filter, ruleActionOrOperationOptions, options = {}) {
        let sqlRuleAction = undefined;
        let operOptions;
        if (ruleActionOrOperationOptions) {
            if (isSqlRuleAction(ruleActionOrOperationOptions)) {
                // Overload#2 - where the sqlExpression in the ruleAction is defined
                sqlRuleAction = ruleActionOrOperationOptions;
                operOptions = options;
            }
            else {
                // Overload#1 - where the sqlExpression in the ruleAction is undefined
                operOptions = { ...ruleActionOrOperationOptions, ...options };
            }
        }
        return tracingClient.withSpan("ServiceBusRuleManager.createRule", operOptions ?? {}, async (updatedOptions) => {
            const addRuleOperationPromise = async () => {
                return this._context
                    .getManagementClient(this._entityPath)
                    .addRule(ruleName, filter, sqlRuleAction?.sqlExpression, {
                    ...updatedOptions,
                    associatedLinkName: this.name,
                    requestName: "addRule",
                    timeoutInMs: this._retryOptions.timeoutInMs,
                });
            };
            const config = {
                operation: addRuleOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: updatedOptions?.abortSignal,
            };
            return coreAmqp.retry(config);
        });
    }
    /**
     * Get all rules associated with the subscription.
     */
    async getRules(options) {
        return tracingClient.withSpan("ServiceBusRuleManager.getRules", options ?? {}, async (updatedOptions) => {
            const getRulesOperationPromise = async () => {
                return this._context.getManagementClient(this._entityPath).getRules({
                    ...updatedOptions,
                    associatedLinkName: this.name,
                    requestName: "getRules",
                    timeoutInMs: this._retryOptions.timeoutInMs,
                });
            };
            const config = {
                operation: getRulesOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: updatedOptions?.abortSignal,
            };
            return coreAmqp.retry(config);
        });
    }
    /**
     * Returns an async iterable iterator to list all the rules
     * under the specified subscription.
     *
     * .byPage() returns an async iterable iterator to list the rules in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listRules(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        ruleManagerLogger.verbose(`Performing operation - listRules() with options: %j`, options);
        const pagedResult = {
            firstPageLink: 0,
            getPage: async (pageLink, maxPageSize) => {
                const top = maxPageSize ?? 100;
                const rules = await this.getRules({
                    skip: pageLink,
                    maxCount: top,
                    ...options,
                });
                return rules.length
                    ? {
                        page: rules,
                        nextPageLink: rules.length > 0 ? pageLink + rules.length : undefined,
                    }
                    : undefined;
            },
        };
        return corePaging.getPagedAsyncIterator(pagedResult);
    }
    /**
     * Deletes a rule.
     */
    async deleteRule(ruleName, options = {}) {
        return tracingClient.withSpan("ServiceBusRuleManager.deleteRule", options, async (updatedOptions) => {
            const removeRuleOperationPromise = async () => {
                return this._context.getManagementClient(this._entityPath).removeRule(ruleName, {
                    ...updatedOptions,
                    associatedLinkName: this.name,
                    requestName: "removeRule",
                    timeoutInMs: this._retryOptions.timeoutInMs,
                });
            };
            const config = {
                operation: removeRuleOperationPromise,
                connectionId: this._context.connectionId,
                operationType: coreAmqp.RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: updatedOptions?.abortSignal,
            };
            return coreAmqp.retry(config);
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * The amount of bytes to reserve as overhead for a small message.
 */
const smallMessageOverhead = 5;
/**
 * @internal
 * The amount of bytes to reserve as overhead for a large message.
 */
const largeMessageOverhead = 8;
/**
 * @internal
 * The maximum number of bytes that a message may be to be considered small.
 */
const smallMessageMaxBytes = 255;
/**
 * An internal class representing a batch of messages which can be used to send messages to Service Bus.
 *
 * @internal
 */
class ServiceBusMessageBatchImpl {
    /**
     * ServiceBusMessageBatch should not be constructed using `new ServiceBusMessageBatch()`
     * Use the `createBatch()` method on your `Sender` instead.
     * @internal
     * @hidden
     */
    constructor(_context, _maxSizeInBytes) {
        this._context = _context;
        this._maxSizeInBytes = _maxSizeInBytes;
        /**
         * Encoded amqp messages.
         */
        this._encodedMessages = [];
        /**
         * List of 'message' span contexts.
         */
        this._spanContexts = [];
        this._sizeInBytes = 0;
        this._batchMessageProperties = {};
    }
    /**
     * The maximum size of the batch, in bytes.
     * @readonly
     */
    get maxSizeInBytes() {
        return this._maxSizeInBytes;
    }
    /**
     * Size of the `ServiceBusMessageBatch` instance after the messages added to it have been
     * encoded into a single AMQP message.
     * @readonly
     */
    get sizeInBytes() {
        return this._sizeInBytes;
    }
    /**
     * Number of messages in the `ServiceBusMessageBatch` instance.
     * @readonly
     */
    get count() {
        return this._encodedMessages.length;
    }
    /**
     * Gets the "message" span contexts that were created when adding messages to the batch.
     * @internal
     * @hidden
     */
    get _messageSpanContexts() {
        return this._spanContexts;
    }
    /**
     * Generates an AMQP message that contains the provided encoded messages and annotations.
     *
     * @param encodedMessages - The already encoded messages to include in the AMQP batch.
     * @param annotations - The message annotations to set on the batch.
     * @param applicationProperties - The application properties to set on the batch.
     * @param messageProperties - The message properties to set on the batch.
     */
    _generateBatch(encodedMessages, annotations, applicationProperties, messageProperties) {
        const batchEnvelope = {
            body: rheaPromise.message.data_sections(encodedMessages),
            message_annotations: annotations,
            application_properties: applicationProperties,
        };
        if (messageProperties) {
            for (const prop of rheaPromise.messageProperties) {
                if (messageProperties[prop]) {
                    batchEnvelope[prop] = messageProperties[prop];
                }
            }
        }
        return rheaPromise.message.encode(batchEnvelope);
    }
    /**
     * Represents the single AMQP message which is the result of encoding all the events
     * added into the `ServiceBusMessageBatch` instance.
     *
     * This is not meant for the user to use directly.
     *
     * When the `ServiceBusMessageBatch` instance is passed to the `sendBatch()` method on the `Sender`,
     * this single batched AMQP message is what gets sent over the wire to the service.
     * @readonly
     */
    _generateMessage() {
        return this._generateBatch(this._encodedMessages, this._batchAnnotations, this._batchApplicationProperties, this._batchMessageProperties);
    }
    /**
     * Tries to add a message to the batch if permitted by the batch's size limit.
     * **NOTE**: Always remember to check the return value of this method, before calling it again
     * for the next message.
     *
     * @param originalMessage - An individual service bus message.
     * @returns A boolean value indicating if the message has been added to the batch or not.
     */
    tryAddMessage(originalMessage, options = {}) {
        throwTypeErrorIfParameterMissing(this._context.connectionId, "message", originalMessage);
        throwIfNotValidServiceBusMessage(originalMessage, errorInvalidMessageTypeSingle);
        const { message, spanContext } = instrumentMessage(originalMessage, options, this._context.config.entityPath, this._context.config.host, "publish");
        // Convert ServiceBusMessage to AmqpMessage.
        const amqpMessage = toRheaMessage(message, defaultDataTransformer);
        const encodedMessage = rheaPromise.message.encode(amqpMessage);
        let currentSize = this._sizeInBytes;
        // The first time an event is added, we need to calculate
        // the overhead of creating an AMQP batch, including the
        // message_annotations, application_properties and message_properties
        // that are taken from the 1st message.
        if (this.count === 0) {
            if (amqpMessage.message_annotations) {
                this._batchAnnotations = amqpMessage.message_annotations;
            }
            if (amqpMessage.application_properties) {
                this._batchApplicationProperties = amqpMessage.application_properties;
            }
            for (const prop of rheaPromise.messageProperties) {
                if (amqpMessage[prop]) {
                    this._batchMessageProperties[prop] = amqpMessage[prop];
                }
            }
            // Figure out the overhead of creating a batch by generating an empty batch
            // with the expected batch annotations.
            currentSize += this._generateBatch([], this._batchAnnotations, this._batchApplicationProperties, this._batchMessageProperties).length;
        }
        const messageSize = encodedMessage.length;
        const messageOverhead = messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;
        currentSize += messageSize + messageOverhead;
        // Check if the size of the batch exceeds the maximum allowed size
        // once we add the new event to it.
        if (currentSize > this._maxSizeInBytes) {
            return false;
        }
        // The message will fit in the batch, so it is now safe to store it.
        this._encodedMessages.push(encodedMessage);
        if (spanContext) {
            this._spanContexts.push(spanContext);
        }
        this._sizeInBytes = currentSize;
        return true;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Describes the MessageSender that will send messages to ServiceBus.
 */
class MessageSender extends LinkEntity {
    constructor(identifier, connectionContext, entityPath, retryOptions) {
        super(entityPath, entityPath, connectionContext, "sender", senderLogger, {
            address: entityPath,
            audience: `${connectionContext.config.endpoint}${entityPath}`,
        });
        this.identifier = identifier;
        this._retryOptions = retryOptions;
        this._onAmqpError = (context) => {
            const senderError = context.sender && context.sender.error;
            senderLogger.logError(senderError, "%s 'sender_error' event occurred on the sender '%s' with address '%s'. " +
                "The associated error", this.logPrefix, this.name, this.address);
            // TODO: Consider rejecting promise in trySendBatch() or createBatch()
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            senderLogger.logError(sessionError, "%s 'session_error' event occurred on the session of sender '%s' with address '%s'. " +
                "The associated error", this.logPrefix, this.name, this.address);
            // TODO: Consider rejecting promise in trySendBatch() or createBatch()
        };
        this._onAmqpClose = async (context) => {
            const senderError = context.sender && context.sender.error;
            senderLogger.logError(senderError, `${this.logPrefix} 'sender_close' event occurred. The associated error is`);
            await this.onDetached().catch((err) => {
                senderLogger.logError(err, `${this.logPrefix} error when closing sender after 'sender_close' event`);
            });
        };
        this._onSessionClose = async (context) => {
            const sessionError = context.session && context.session.error;
            senderLogger.logError(sessionError, `${this.logPrefix} 'session_close' event occurred. The associated error is`);
            await this.onDetached().catch((err) => {
                senderLogger.logError(err, `${this.logPrefix} error when closing sender after 'session_close' event`);
            });
        };
    }
    _createSenderOptions(newName) {
        if (newName)
            this.name = getUniqueName(this.baseName);
        const srOptions = {
            name: this.name,
            target: {
                address: this.address,
            },
            source: this.identifier,
            onError: this._onAmqpError,
            onClose: this._onAmqpClose,
            onSessionError: this._onSessionError,
            onSessionClose: this._onSessionClose,
        };
        senderLogger.verbose(`${this.logPrefix} Creating sender with options: %O`, srOptions);
        return srOptions;
    }
    /**
     * Tries to send the message to ServiceBus if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     *
     * @param encodedMessage - The encoded message to be sent to ServiceBus.
     * @param sendBatch - Boolean indicating whether the encoded message represents a batch of messages or not
     */
    _trySend(encodedMessage, sendBatch, options) {
        const abortSignal = options?.abortSignal;
        const timeoutInMs = !coreUtil.isDefined(this._retryOptions.timeoutInMs)
            ? coreAmqp.Constants.defaultOperationTimeoutInMs
            : this._retryOptions.timeoutInMs;
        const sendEventPromise = async () => {
            const initStartTime = Date.now();
            if (!this.isOpen()) {
                try {
                    await waitForTimeoutOrAbortOrResolve({
                        actionFn: () => this.open(undefined, options?.abortSignal),
                        abortSignal: options?.abortSignal,
                        timeoutMs: timeoutInMs,
                        timeoutMessage: `[${this._context.connectionId}] Sender "${this.name}" ` +
                            `with address "${this.address}", was not able to send the message right now, due ` +
                            `to operation timeout.`,
                    });
                }
                catch (err) {
                    const translatedError = translateServiceBusError(err);
                    senderLogger.logError(translatedError, "%s An error occurred while creating the sender", this.logPrefix, this.name);
                    throw translatedError;
                }
            }
            const timeTakenByInit = Date.now() - initStartTime;
            senderLogger.verbose("%s Sender '%s', credit: %d available: %d", this.logPrefix, this.name, this.link?.credit, this.link?.session?.outgoing?.available());
            const waitingTime = await waitForSendable(senderLogger, this.logPrefix, this.name, timeoutInMs - timeTakenByInit, this.link, this.link?.session?.outgoing?.available());
            if (timeoutInMs <= timeTakenByInit + waitingTime) {
                const desc = `${this.logPrefix} Sender "${this.name}" ` +
                    `with address "${this.address}", was not able to send the message right now, due ` +
                    `to operation timeout.`;
                senderLogger.warning(desc);
                const e = {
                    condition: coreAmqp.ErrorNameConditionMapper.ServiceUnavailableError,
                    description: desc,
                };
                throw translateServiceBusError(e);
            }
            if (!this.link) {
                const msg = `[${this.logPrefix}] Cannot send the message. Link is not ready.`;
                senderLogger.warning(msg);
                const amqpError = {
                    condition: coreAmqp.ErrorNameConditionMapper.SenderNotReadyError,
                    description: msg,
                };
                throw translateServiceBusError(amqpError);
            }
            try {
                const delivery = await this.link.send(encodedMessage, {
                    format: sendBatch ? 0x80013700 : 0,
                    timeoutInSeconds: (timeoutInMs - timeTakenByInit - waitingTime) / 1000,
                    abortSignal,
                });
                senderLogger.verbose("%s Sender '%s', sent message with delivery id: %d", this.logPrefix, this.name, delivery.id);
            }
            catch (error) {
                const translatedError = translateServiceBusError(error.innerError || error);
                senderLogger.logError(translatedError, `${this.logPrefix} An error occurred while sending the message`);
                throw translatedError;
            }
        };
        const config = {
            operation: sendEventPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.sendMessage,
            retryOptions: this._retryOptions,
            abortSignal: abortSignal,
        };
        return coreAmqp.retry(config);
    }
    createRheaLink(options) {
        return this._context.connection.createAwaitableSender(options);
    }
    /**
     * Initializes the sender session on the connection.
     */
    async open(options, abortSignal) {
        try {
            if (!options) {
                options = this._createSenderOptions();
            }
            await this.initLink(options, abortSignal);
        }
        catch (err) {
            const translatedError = translateServiceBusError(err);
            senderLogger.logError(translatedError, `${this.logPrefix} An error occurred while creating the sender`);
            // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.
            if (translatedError.code === "OperationTimeoutError") {
                translatedError.message =
                    "Failed to create a sender within allocated time and retry attempts.";
            }
            throw translatedError;
        }
    }
    /**
     * Closes the rhea link.
     * To be called when connection is disconnected, onAmqpClose and onSessionClose events.
     */
    async onDetached() {
        // Clears the token renewal timer. Closes the link and its session if they are open.
        // Removes the link and its session if they are present in rhea's cache.
        await this.closeLink();
    }
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     */
    isOpen() {
        const result = this.link == null ? false : this.link.isOpen();
        senderLogger.verbose("%s Sender '%s' with address '%s' is open? -> %s", this.logPrefix, this.name, this.address, result);
        return result;
    }
    /**
     * Sends the given message, with the given options on this link
     *
     * @param data - Message to send. Will be sent as UTF8-encoded JSON string.
     */
    async send(data, options) {
        throwErrorIfConnectionClosed(this._context);
        try {
            const amqpMessage = toRheaMessage(data, defaultDataTransformer);
            // TODO: this body of logic is really similar to what's in sendMessages. Unify what we can.
            const encodedMessage = rheaPromise.message.encode(amqpMessage);
            senderLogger.verbose("%s Sender '%s', trying to send message: %O", this.logPrefix, this.name, data);
            return await this._trySend(encodedMessage, false, options);
        }
        catch (err) {
            senderLogger.logError(err, "%s An error occurred while sending the message: %O\nError", this.logPrefix, data);
            throw err;
        }
    }
    /**
     * Returns maximum message size on the AMQP sender link.
     *
     * Options to configure the `createBatch` method on the `Sender`.
     * - `maxSizeInBytes`: The upper limit for the size of batch.
     *
     * Example usage:
     * ```js
     * {
     *     retryOptions: { maxRetries: 5; timeoutInMs: 10 }
     * }
     * ```
     */
    async getMaxMessageSize(options = {}) {
        const retryOptions = options.retryOptions || {};
        if (this.isOpen()) {
            return this.link.maxMessageSize;
        }
        const config = {
            operation: async () => {
                await this.open(undefined, options?.abortSignal);
                if (this.link) {
                    return this.link.maxMessageSize;
                }
                throw new ServiceBusError("Link failed to initialize, cannot get max message size.", "GeneralError");
            },
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.senderLink,
            retryOptions: retryOptions,
            abortSignal: options?.abortSignal,
        };
        return coreAmqp.retry(config);
    }
    async createBatch(options) {
        throwErrorIfConnectionClosed(this._context);
        let maxMessageSize = await this.getMaxMessageSize({
            retryOptions: this._retryOptions,
            abortSignal: options?.abortSignal,
        });
        if (options?.maxSizeInBytes) {
            if (options.maxSizeInBytes > maxMessageSize) {
                const error = new Error(`Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`);
                throw error;
            }
            maxMessageSize = options.maxSizeInBytes;
        }
        return new ServiceBusMessageBatchImpl(this._context, maxMessageSize);
    }
    async sendBatch(batchMessage, options) {
        throwErrorIfConnectionClosed(this._context);
        try {
            senderLogger.verbose("%s Sender '%s', sending encoded batch message.", this.logPrefix, this.name, batchMessage);
            return await this._trySend(batchMessage._generateMessage(), true, options);
        }
        catch (err) {
            senderLogger.logError(err, "%s Sender '%s': An error occurred while sending the messages: %O\nError", this.logPrefix, this.name, batchMessage);
            throw err;
        }
    }
    static create(identifier, context, entityPath, retryOptions) {
        throwErrorIfConnectionClosed(context);
        const sbSender = new MessageSender(identifier, context, entityPath, retryOptions);
        context.senders[sbSender.name] = sbSender;
        return sbSender;
    }
    removeLinkFromContext() {
        delete this._context.senders[this.name];
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
class ServiceBusSenderImpl {
    get logPrefix() {
        return `[${this._context.connectionId}|sender:${this.entityPath}]`;
    }
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     */
    constructor(_context, _entityPath, retryOptions = {}, identifier) {
        this._context = _context;
        this._entityPath = _entityPath;
        /**
         * Denotes if close() was called on this sender
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this.entityPath = _entityPath;
        this.identifier = ensureValidIdentifier(this.entityPath, identifier);
        this._sender = MessageSender.create(this.identifier, this._context, _entityPath, retryOptions);
        this._retryOptions = retryOptions;
    }
    _throwIfSenderOrConnectionClosed() {
        throwErrorIfConnectionClosed(this._context);
        if (this.isClosed) {
            const errorMessage = getSenderClosedErrorMsg(this._entityPath);
            const error = new Error(errorMessage);
            senderLogger.logError(error, `[${this._context.connectionId}] is closed`);
            throw error;
        }
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    async sendMessages(messages, options) {
        this._throwIfSenderOrConnectionClosed();
        throwTypeErrorIfParameterMissing(this._context.connectionId, "messages", messages);
        if (!isServiceBusMessageBatch(messages) && !Array.isArray(messages)) {
            // Case 1: Single message
            throwIfNotValidServiceBusMessage(messages, errorInvalidMessageTypeSingleOrArray);
            const originalMessage = messages;
            const { message, spanContext } = instrumentMessage(originalMessage, options ?? {}, this.entityPath, this._context.config.host, "publish");
            const spanLinks = spanContext ? [{ tracingContext: spanContext }] : [];
            return tracingClient.withSpan("ServiceBusSender.send", options ?? {}, (updatedOptions) => this._sender.send(message, updatedOptions), {
                spanLinks,
                ...toSpanOptions({ entityPath: this.entityPath, host: this._context.config.host }, "publish", "client"),
            });
        }
        let batch;
        if (isServiceBusMessageBatch(messages)) {
            // Case 2: Batch message
            batch = messages;
        }
        else {
            // Case 3: Array of messages
            batch = await this.createMessageBatch(options);
            for (const message of messages) {
                throwIfNotValidServiceBusMessage(message, errorInvalidMessageTypeSingleOrArray);
                if (!batch.tryAddMessage(message, options)) {
                    // this is too big - throw an error
                    throw new ServiceBusError("Messages were too big to fit in a single batch. Remove some messages and try again or create your own batch using createBatch(), which gives more fine-grained control.", "MessageSizeExceeded");
                }
            }
        }
        const spanLinks = batch._messageSpanContexts.map((tracingContext) => {
            return {
                tracingContext,
            };
        });
        return tracingClient.withSpan("ServiceBusSender.send", options ?? {}, (updatedOptions) => this._sender.sendBatch(batch, updatedOptions), {
            spanLinks,
            ...toSpanOptions({ entityPath: this.entityPath, host: this._context.config.host }, "publish", "client"),
        });
    }
    async createMessageBatch(options) {
        this._throwIfSenderOrConnectionClosed();
        return this._sender.createBatch(options);
    }
    async scheduleMessages(messages, scheduledEnqueueTimeUtc, options = {}) {
        this._throwIfSenderOrConnectionClosed();
        throwTypeErrorIfParameterMissing(this._context.connectionId, "scheduledEnqueueTimeUtc", scheduledEnqueueTimeUtc);
        throwTypeErrorIfNotInstanceOfParameterType(this._context.connectionId, "scheduledEnqueueTimeUtc", scheduledEnqueueTimeUtc, Date);
        throwTypeErrorIfParameterMissing(this._context.connectionId, "messages", messages);
        const messagesToSchedule = Array.isArray(messages) ? messages : [messages];
        for (const message of messagesToSchedule) {
            throwIfNotValidServiceBusMessage(message, errorInvalidMessageTypeSingleOrArray);
        }
        const scheduleMessageOperationPromise = async () => {
            return this._context
                .getManagementClient(this._entityPath)
                .scheduleMessages(scheduledEnqueueTimeUtc, messagesToSchedule, {
                ...options,
                associatedLinkName: this._sender.name,
                requestName: "scheduleMessages",
                timeoutInMs: this._retryOptions.timeoutInMs,
            });
        };
        const config = {
            operation: scheduleMessageOperationPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.management,
            retryOptions: this._retryOptions,
            abortSignal: options?.abortSignal,
        };
        return coreAmqp.retry(config);
    }
    async cancelScheduledMessages(sequenceNumbers, options = {}) {
        this._throwIfSenderOrConnectionClosed();
        throwTypeErrorIfParameterMissing(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        throwTypeErrorIfParameterNotLong(this._context.connectionId, "sequenceNumbers", sequenceNumbers);
        const sequenceNumbersToCancel = Array.isArray(sequenceNumbers)
            ? sequenceNumbers
            : [sequenceNumbers];
        const cancelSchedulesMessagesOperationPromise = async () => {
            return this._context
                .getManagementClient(this._entityPath)
                .cancelScheduledMessages(sequenceNumbersToCancel, {
                ...options,
                associatedLinkName: this._sender.name,
                requestName: "cancelScheduledMessages",
                timeoutInMs: this._retryOptions.timeoutInMs,
            });
        };
        const config = {
            operation: cancelSchedulesMessagesOperationPromise,
            connectionId: this._context.connectionId,
            operationType: coreAmqp.RetryOperationType.management,
            retryOptions: this._retryOptions,
            abortSignal: options?.abortSignal,
        };
        return coreAmqp.retry(config);
    }
    // async open(options?: OperationOptionsBase): Promise<void> {
    //   this._throwIfSenderOrConnectionClosed();
    //   const config: RetryConfig<void> = {
    //     // TODO: Pass tracing options too
    //     operation: () => this._sender.open(undefined, options?.abortSignal),
    //     connectionId: this._context.connectionId,
    //     operationType: RetryOperationType.senderLink,
    //     retryOptions: this._retryOptions,
    //     abortSignal: options?.abortSignal
    //   };
    //   return retry<void>(config);
    // }
    async close() {
        try {
            this._isClosed = true;
            await this._sender.close();
        }
        catch (err) {
            senderLogger.logError(err, `${this.logPrefix} An error occurred while closing the Sender`);
            throw err;
        }
    }
}
/**
 * @internal
 */
function isServiceBusMessageBatch(messageBatchOrAnything) {
    if (messageBatchOrAnything == null) {
        return false;
    }
    const possibleBatch = messageBatchOrAnything;
    return (typeof possibleBatch.tryAddMessage === "function" &&
        typeof possibleBatch.maxSizeInBytes === "number" &&
        typeof possibleBatch.sizeInBytes === "number");
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Describes the receiver for a Message Session.
 */
class MessageSession extends LinkEntity {
    /**
     * Denotes if we are currently receiving messages
     */
    get isReceivingMessages() {
        return this._batchingReceiverLite.isReceivingMessages || this._isReceivingMessagesForSubscriber;
    }
    get receiverHelper() {
        return this._receiverHelper;
    }
    /**
     * Ensures that the session lock is renewed before it expires. The lock will not be renewed for
     * more than the configured totalAutoLockRenewDuration.
     */
    _ensureSessionLockRenewal() {
        if (this.autoRenewLock &&
            new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc &&
            Date.now() < this._totalAutoLockRenewDuration &&
            this.isOpen()) {
            const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc);
            this._sessionLockRenewalTimer = setTimeout(async () => {
                try {
                    receiverLogger.verbose("%s Attempting to renew the session lock for MessageSession '%s' " + "with name '%s'.", this.logPrefix, this.sessionId, this.name);
                    this.sessionLockedUntilUtc = await this._context
                        .getManagementClient(this.entityPath)
                        .renewSessionLock(this.sessionId, {
                        associatedLinkName: this.name,
                        timeoutInMs: 10000,
                    });
                    receiverLogger.verbose("%s Successfully renewed the session lock for MessageSession '%s' " + "with name '%s'.", this.logPrefix, this.sessionId, this.name);
                    receiverLogger.verbose("%s Calling _ensureSessionLockRenewal() again for MessageSession '%s'.", this.logPrefix, this.sessionId);
                    this._ensureSessionLockRenewal();
                }
                catch (err) {
                    receiverLogger.logError(err, "%s An error occurred while renewing the session lock for MessageSession '%s'", this.logPrefix, this.sessionId);
                }
            }, nextRenewalTimeout);
            receiverLogger.verbose("%s MessageSession '%s' has next session lock renewal in %d milliseconds @(%s).", this.logPrefix, this.sessionId, nextRenewalTimeout, new Date(Date.now() + nextRenewalTimeout).toString());
        }
    }
    async createRheaLink(options, _abortSignal) {
        this._lastSBError = undefined;
        let errorMessage = "";
        const link = await this._context.connection.createReceiver(options);
        this._intermediateLink = link;
        const receivedSessionId = link.source?.filter?.[coreAmqp.Constants.sessionFilterName];
        if (!this._providedSessionId && !receivedSessionId) {
            // When we ask for any sessions (passing option of session-filter: undefined),
            // but don't receive one back, check whether service has sent any error.
            if (options.source &&
                typeof options.source !== "string" &&
                options.source.filter &&
                coreAmqp.Constants.sessionFilterName in options.source.filter &&
                options.source.filter[coreAmqp.Constants.sessionFilterName] === undefined) {
                await coreUtil.delay(1); // yield to eventloop
                if (this._lastSBError) {
                    receiverLogger.verbose("%s cleaning up resources held by link", this.logPrefix);
                    await link.close({ closeSession: true });
                    link.remove();
                    throw this._lastSBError;
                }
            }
            // Ideally this code path should never be reached as `MessageSession.createReceiver()` should fail instead
            // TODO: https://github.com/Azure/azure-sdk-for-js/issues/9775 to figure out why this code path indeed gets hit.
            errorMessage = `Failed to create a receiver. No unlocked sessions available.`;
        }
        else if (this._providedSessionId && receivedSessionId !== this._providedSessionId) {
            // This code path is reached if the session is already locked by another receiver.
            // TODO: Check why the service would not throw an error or just timeout instead of giving a misleading successful receiver
            errorMessage = `Failed to create a receiver for the requested session '${this._providedSessionId}'. It may be locked by another receiver.`;
        }
        if (errorMessage) {
            const error = translateServiceBusError({
                description: errorMessage,
                condition: coreAmqp.ErrorNameConditionMapper.SessionCannotBeLockedError,
            });
            receiverLogger.logError(error, this.logPrefix);
            receiverLogger.verbose("%s cleaning up resources held by intermediate link (SessionCannotBeLockedError)", this.logPrefix);
            await link.close({ closeSession: true });
            link.remove();
            throw error;
        }
        return link;
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     */
    async _init(opts = {}) {
        try {
            const sessionOptions = this._createMessageSessionOptions(this.identifier, opts.timeoutInMs);
            await this.initLink(sessionOptions, opts.abortSignal);
            if (!this.link) {
                throw new Error("INTERNAL ERROR: failed to create receiver but without an error.");
            }
            const receivedSessionId = this.link.source?.filter?.[coreAmqp.Constants.sessionFilterName];
            if (!this._providedSessionId)
                this.sessionId = receivedSessionId;
            this.sessionLockedUntilUtc = convertTicksToDate(this.link.properties["com.microsoft:locked-until-utc"]);
            receiverLogger.verbose("%s Session with id '%s' is locked until: '%s'.", this.logPrefix, this.sessionId, this.sessionLockedUntilUtc.toISOString());
            receiverLogger.verbose("%s Receiver created with receiver options: %O", this.logPrefix, sessionOptions);
            if (!this._context.messageSessions[this.name]) {
                this._context.messageSessions[this.name] = this;
            }
            this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;
            this._ensureSessionLockRenewal();
        }
        catch (err) {
            const errObj = translateServiceBusError(err);
            receiverLogger.logError(errObj, "%s An error occured while creating the receiver", this.logPrefix);
            // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.
            if (errObj.code === "OperationTimeoutError") {
                if (this._providedSessionId) {
                    errObj.message = `Failed to create a receiver for the requested session '${this._providedSessionId}' within allocated time and retry attempts.`;
                }
                else {
                    errObj.message = "Failed to create a receiver within allocated time and retry attempts.";
                }
            }
            if (this._intermediateLink) {
                receiverLogger.verbose("%s cleaning up resources held by intermediate link", this.logPrefix);
                await this._intermediateLink.close({ closeSession: true });
                this._intermediateLink.remove();
            }
            throw errObj;
        }
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */
    _createMessageSessionOptions(clientId, timeoutInMs) {
        const rcvrOptions = createReceiverOptions(this.name, this.receiveMode, {
            address: this.address,
            filter: { [coreAmqp.Constants.sessionFilterName]: this.sessionId },
        }, clientId, {
            onClose: (context) => this._onAmqpClose(context).catch(() => {
                /* */
            }),
            onSessionClose: (context) => this._onSessionClose(context).catch(() => {
                /* */
            }),
            onError: this._onAmqpError,
            onSessionError: this._onSessionError,
            onSettled: this._onSettled,
        }, timeoutInMs);
        return rcvrOptions;
    }
    /**
     * Constructs a MessageSession instance which lets you receive messages as batches
     * or via callbacks using subscribe.
     *
     * @param _providedSessionId - The sessionId provided by the user. This can be the
     * name of a session ID to open (empty string is also valid) or it can be undefined,
     * to indicate we want the next unlocked non-empty session.
     */
    constructor(identifier, connectionContext, entityPath, _providedSessionId, options) {
        super(entityPath, entityPath, connectionContext, "session", receiverLogger, {
            address: entityPath,
            audience: `${connectionContext.config.endpoint}${entityPath}`,
        });
        this.identifier = identifier;
        this._providedSessionId = _providedSessionId;
        /**
         * The maximum number of messages that should be
         * processed concurrently in a session while in streaming mode. Once this limit has been reached,
         * more messages will not be received until the user's message handler has completed processing current message.
         * - **Default**: `1` (message in a session at a time).
         */
        this.maxConcurrentCalls = 1;
        /**
         * Maintains a map of deliveries that
         * are being actively disposed. It acts as a store for correlating the responses received for
         * active dispositions.
         */
        this._deliveryDispositionMap = new Map();
        this._receiverHelper = new ReceiverHelper(() => ({
            receiver: this.link,
            logPrefix: this.logPrefix,
        }));
        this._retryOptions = options.retryOptions;
        this.autoComplete = false;
        if (coreUtil.isDefined(this._providedSessionId))
            this.sessionId = this._providedSessionId;
        this.receiveMode = options.receiveMode || "peekLock";
        this.skipParsingBodyAsJson = options.skipParsingBodyAsJson;
        this.skipConvertingDate = options.skipConvertingDate;
        this.maxAutoRenewDurationInMs =
            options.maxAutoLockRenewalDurationInMs != null
                ? options.maxAutoLockRenewalDurationInMs
                : 300 * 1000;
        this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;
        this.autoRenewLock = this.maxAutoRenewDurationInMs > 0 && this.receiveMode === "peekLock";
        this._isReceivingMessagesForSubscriber = false;
        this._batchingReceiverLite = new BatchingReceiverLite(connectionContext, entityPath, async (_abortSignal) => {
            return this.link;
        }, this.receiveMode, this.skipParsingBodyAsJson, this.skipConvertingDate);
        // setting all the handlers
        this._onSettled = (context) => {
            const delivery = context.delivery;
            onMessageSettled(this.logPrefix, delivery, this._deliveryDispositionMap);
        };
        this._notifyError = async (args) => {
            if (this._onError) {
                this._onError(args);
                receiverLogger.verbose("%s Notified the user's error handler about the error received by the Receiver", this.logPrefix);
            }
        };
        this._onAmqpError = (context) => {
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const sbError = translateServiceBusError(receiverError);
                if (sbError.code === "SessionLockLostError") {
                    sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;
                }
                this._lastSBError = sbError;
                receiverLogger.logError(sbError, "%s An error occurred for Receiver", this.logPrefix);
                this._notifyError({
                    error: sbError,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: this.identifier,
                });
            }
        };
        this._onSessionError = (context) => {
            const connectionId = this._context.connectionId;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = translateServiceBusError(sessionError);
                receiverLogger.logError(sbError, "[%s] An error occurred on the session for Receiver '%s': %O.", connectionId, this.name, sbError);
                this._notifyError({
                    error: sbError,
                    errorSource: "receive",
                    entityPath: this.entityPath,
                    fullyQualifiedNamespace: this._context.config.host,
                    identifier: this.identifier,
                });
            }
        };
        this._onAmqpClose = async (context) => {
            const connectionId = this._context.connectionId;
            const receiverError = context.receiver && context.receiver.error;
            const receiver = this.link || context.receiver;
            if (receiverError) {
                const sbError = translateServiceBusError(receiverError);
                receiverLogger.logError(sbError, "[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. " +
                    "The associated error is: %O", connectionId, this.name, this.sessionId, sbError);
                // no need to notify the user's error handler since rhea guarantees that receiver_error
                // will always be emitted before receiver_close.
            }
            if (receiver && !receiver.isItselfClosed()) {
                receiverLogger.verbose("%s 'receiver_close' event occurred on the receiver for sessionId '%s' " +
                    "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", this.logPrefix, this.sessionId);
                try {
                    await this.close();
                }
                catch (err) {
                    receiverLogger.logError(err, "%s An error occurred while closing the receiver for sessionId '%s'.", this.logPrefix, this.sessionId);
                }
            }
            else {
                receiverLogger.verbose("%s 'receiver_close' event occurred on the receiver for sessionId '%s' " +
                    "because the sdk initiated it. Hence no need to gracefully close the receiver", this.logPrefix, this.sessionId);
            }
        };
        this._onSessionClose = async (context) => {
            const receiver = this.link || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const sbError = translateServiceBusError(sessionError);
                receiverLogger.logError(sbError, "%s 'session_close' event occurred for receiver for sessionId '%s'. " +
                    "The associated error is", this.logPrefix, this.sessionId);
                // no need to notify the user's error handler since rhea guarantees that session_error
                // will always be emitted before session_close.
            }
            if (receiver && !receiver.isSessionItselfClosed()) {
                receiverLogger.verbose("%s 'session_close' event occurred on the receiver for sessionId '%s' " +
                    "and the sdk did not initiate this. Hence, let's gracefully close the receiver.", this.logPrefix, this.sessionId);
                try {
                    await this.close();
                }
                catch (err) {
                    receiverLogger.logError(err, "%s An error occurred while closing the receiver for sessionId '%s'", this.logPrefix, this.sessionId);
                }
            }
            else {
                receiverLogger.verbose("%s 'session_close' event occurred on the receiver for sessionId'%s' " +
                    "because the sdk initiated it. Hence no need to gracefully close the receiver", this.logPrefix, this.sessionId);
            }
        };
    }
    /**
     * Closes the underlying AMQP receiver link.
     */
    async close(error) {
        try {
            this._isReceivingMessagesForSubscriber = false;
            if (this._sessionLockRenewalTimer)
                clearTimeout(this._sessionLockRenewalTimer);
            receiverLogger.verbose("%s Cleared the timers for 'no new message received' task and " +
                "'session lock renewal' task.", this.logPrefix);
            await super.close();
            this._batchingReceiverLite.terminate(error);
        }
        catch (err) {
            receiverLogger.logError(err, "%s An error occurred while closing the message session with id '%s'", this.logPrefix, this.sessionId);
        }
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     */
    isOpen() {
        const result = this.link && this.link.isOpen();
        receiverLogger.verbose("%s Receiver for sessionId '%s' is open? -> %s", this.logPrefix, this.sessionId, result);
        return result;
    }
    /**
     * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link
     * from a Queue/Subscription.
     * To stop receiving messages, call `close()` on the SessionReceiver or set the property
     * `newMessageWaitTimeoutInMs` in the options to provide a timeout.
     *
     * @param onMessage - Handler for processing each incoming message.
     * @param onError - Handler for any error that occurs while receiving or processing messages.
     * @param options - Options to control whether messages should be automatically completed. You can
     * also provide a timeout in milliseconds to denote the amount of time to wait for a new message
     * before closing the receiver.
     */
    subscribe(onMessage, onError, options) {
        this.receiverHelper.resume();
        this._subscribeImpl(onMessage, onError, options);
    }
    _subscribeImpl(onMessage, onError, options) {
        if (!options)
            options = {};
        if (options.abortSignal?.aborted) {
            throw new abortController.AbortError(coreAmqp.StandardAbortMessage);
        }
        this._isReceivingMessagesForSubscriber = true;
        if (typeof options.maxConcurrentCalls === "number" && options.maxConcurrentCalls > 0) {
            this.maxConcurrentCalls = options.maxConcurrentCalls;
        }
        // If explicitly set to false then autoComplete is false else true (default).
        this.autoComplete =
            options.autoCompleteMessages === false ? options.autoCompleteMessages : true;
        this._onMessage = onMessage;
        this._onError = onError;
        if (this.link && this.link.isOpen()) {
            const onSessionMessage = async (context) => {
                // If the receiver got closed in PeekLock mode, avoid processing the message as we
                // cannot settle the message.
                if (this.receiveMode === "peekLock" && (!this.link || !this.link.isOpen())) {
                    receiverLogger.verbose("%s Not calling the user's message handler for the current message " +
                        "as the receiver is closed", this.logPrefix);
                    return;
                }
                const bMessage = new ServiceBusMessageImpl(context.message, context.delivery, true, this.receiveMode, this.skipParsingBodyAsJson, this.skipConvertingDate);
                try {
                    await this._onMessage(bMessage);
                    if (this.autoComplete &&
                        this.receiveMode === "peekLock" &&
                        !bMessage.delivery.remote_settled) {
                        try {
                            receiverLogger.verbose("%s Auto completing the message with id '%s' on the receiver.", this.logPrefix, bMessage.messageId);
                            await completeMessage(bMessage, this._context, this.entityPath, this._retryOptions);
                        }
                        catch (completeError) {
                            const translatedError = translateServiceBusError(completeError);
                            receiverLogger.logError(translatedError, "%s An error occurred while completing the message with id '%s' on the " +
                                "receiver", this.logPrefix, bMessage.messageId);
                            await this._notifyError({
                                error: translatedError,
                                errorSource: "complete",
                                entityPath: this.entityPath,
                                fullyQualifiedNamespace: this._context.config.host,
                                identifier: this.identifier,
                            });
                        }
                    }
                }
                catch (err) {
                    receiverLogger.logError(err, "%s An error occurred while running user's message handler for the message " +
                        "with id '%s' on the receiver", this.logPrefix, bMessage.messageId);
                    await this._onError({
                        error: err,
                        errorSource: "processMessageCallback",
                        entityPath: this.entityPath,
                        fullyQualifiedNamespace: this._context.config.host,
                        identifier: this.identifier,
                    });
                    const error = translateServiceBusError(err);
                    // Nothing much to do if user's message handler throws. Let us try abandoning the message.
                    if (!bMessage.delivery.remote_settled &&
                        this.receiveMode === "peekLock" &&
                        this.isOpen() // only try to abandon the messages if the connection is still open
                    ) {
                        try {
                            receiverLogger.logError(error, "%s Abandoning the message with id '%s' on the receiver since an error occured", this.logPrefix, bMessage.messageId);
                            await abandonMessage(bMessage, this._context, this.entityPath, undefined, this._retryOptions);
                        }
                        catch (abandonError) {
                            const translatedError = translateServiceBusError(abandonError);
                            receiverLogger.logError(translatedError, "%s An error occurred while abandoning the message with id '%s' on the " +
                                "receiver", this.logPrefix, bMessage.messageId, translatedError);
                            await this._notifyError({
                                error: translatedError,
                                errorSource: "abandon",
                                entityPath: this.entityPath,
                                fullyQualifiedNamespace: this._context.config.host,
                                identifier: this.identifier,
                            });
                        }
                    }
                    return;
                }
                finally {
                    try {
                        this.receiverHelper.addCredit(1);
                    }
                    catch (err) {
                        // this isn't something we expect in normal operation - we'd only get here
                        // because of a bug in our code.
                        this.processCreditError(err);
                    }
                }
            };
            // setting the "message" event listener.
            this.link.on(rheaPromise.ReceiverEvents.message, onSessionMessage);
            try {
                this.receiverHelper.addCredit(this.maxConcurrentCalls);
            }
            catch (err) {
                // this isn't something we expect in normal operation - we'd only get here
                // because of a bug in our code.
                this.processCreditError(err);
            }
        }
        else {
            this._isReceivingMessagesForSubscriber = false;
            const msg = `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +
                `has either not been created or is not open.`;
            receiverLogger.verbose("[%s] %s", this._context.connectionId, msg);
            this._notifyError({
                error: new Error(msg),
                // This is _probably_ the right error code since we require that
                // the message session is created before we even give back the receiver. So it not
                // being open at this point is either:
                //
                // 1. we didn't acquire the lock
                // 2. the connection was broken (we don't reconnect)
                //
                // If any of these becomes untrue you'll probably want to re-evaluate this classification.
                errorSource: "receive",
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host,
                identifier: this.identifier,
            });
        }
    }
    async processCreditError(err) {
        if (err.name === "AbortError") {
            // if we fail to add credits because the user has asked us to stop
            // then this isn't an error - it's normal.
            return;
        }
        receiverLogger.logError(err, "Cannot request messages on the receiver");
        const error = new ServiceBusError("Cannot request messages on the receiver", "SessionLockLost");
        error.retryable = false;
        // from the user's perspective this is a fatal link error and they should retry
        // opening the link.
        await this._onError({
            error,
            errorSource: "processMessageCallback",
            entityPath: this.entityPath,
            fullyQualifiedNamespace: this._context.config.host,
            identifier: this.identifier,
        });
    }
    /**
     * Returns a batch of messages based on given count and timeout over an AMQP receiver link
     * from a Queue/Subscription.
     *
     * @param maxMessageCount - The maximum number of messages to receive from Queue/Subscription.
     * @param maxWaitTimeInMs - The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.
     * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.
     * @returns A promise that resolves with an array of Message objects.
     */
    async receiveMessages(maxMessageCount, maxWaitTimeInMs, maxTimeAfterFirstMessageInMs, options) {
        try {
            return await this._batchingReceiverLite.receiveMessages({
                maxMessageCount,
                maxWaitTimeInMs,
                maxTimeAfterFirstMessageInMs,
                ...options,
            });
        }
        catch (error) {
            receiverLogger.logError(error, `${this.logPrefix} Rejecting receiveMessages() with error`);
            throw error;
        }
    }
    /**
     * To be called when connection is disconnected to gracefully close ongoing receive request.
     * @param connectionError - The connection error if any.
     */
    async onDetached(connectionError) {
        receiverLogger.error(translateServiceBusError(connectionError), `${this.logPrefix} onDetached: closing link (session receiver will not reconnect)`);
        try {
            // Notifying so that the streaming receiver knows about the error
            await this._notifyError({
                entityPath: this.entityPath,
                fullyQualifiedNamespace: this._context.config.host,
                error: translateServiceBusError(connectionError),
                errorSource: "receive",
                identifier: this.identifier,
            });
        }
        catch (error) {
            receiverLogger.error(translateServiceBusError(error), `${this.logPrefix} onDetached: unexpected error seen when tried calling "_notifyError" with ${translateServiceBusError(connectionError)}`);
        }
        await this.close(connectionError);
    }
    /**
     * Settles the message with the specified disposition.
     * @param message - The ServiceBus Message that needs to be settled.
     * @param operation - The disposition type.
     * @param options - Optional parameters that can be provided while disposing the message.
     */
    async settleMessage(message, operation, options) {
        return new Promise((resolve, reject) => {
            if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {
                return reject(new Error(`operation: '${operation}' is not a valid operation.`));
            }
            const delivery = message.delivery;
            const timer = setTimeout(() => {
                this._deliveryDispositionMap.delete(delivery.id);
                receiverLogger.verbose("[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. " +
                    "Hence rejecting the promise with timeout error", this._context.connectionId, delivery.id, coreAmqp.Constants.defaultOperationTimeoutInMs);
                const e = {
                    condition: coreAmqp.ErrorNameConditionMapper.ServiceUnavailableError,
                    description: "Operation to settle the message has timed out. The disposition of the " +
                        "message may or may not be successful",
                };
                return reject(translateServiceBusError(e));
            }, coreAmqp.Constants.defaultOperationTimeoutInMs);
            this._deliveryDispositionMap.set(delivery.id, {
                resolve: resolve,
                reject: reject,
                timer: timer,
            });
            if (operation === DispositionType.complete) {
                delivery.accept();
            }
            else if (operation === DispositionType.abandon) {
                const params = {
                    undeliverable_here: false,
                };
                if (options.propertiesToModify)
                    params.message_annotations = options.propertiesToModify;
                delivery.modified(params);
            }
            else if (operation === DispositionType.defer) {
                const params = {
                    undeliverable_here: true,
                };
                if (options.propertiesToModify)
                    params.message_annotations = options.propertiesToModify;
                delivery.modified(params);
            }
            else if (operation === DispositionType.deadletter) {
                const error = {
                    condition: coreAmqp.Constants.deadLetterName,
                    info: {
                        ...options.propertiesToModify,
                        DeadLetterReason: options.deadLetterReason,
                        DeadLetterErrorDescription: options.deadLetterDescription,
                    },
                };
                delivery.reject(error);
            }
        });
    }
    /**
     * Creates a new instance of the MessageSession based on the provided parameters.
     * @param identifier - name to identify the message session
     * @param context - The client entity context
     * @param options - Options that can be provided while creating the MessageSession.
     */
    static async create(identifier, context, entityPath, sessionId, options) {
        throwErrorIfConnectionClosed(context);
        const messageSession = new MessageSession(identifier, context, entityPath, sessionId, options);
        let timeoutInMs;
        // Only passing client timeout in link properties for accepting next available
        // session as this is the only long-polling scenario.
        if (sessionId === undefined) {
            timeoutInMs = options.retryOptions?.timeoutInMs ?? coreAmqp.Constants.defaultOperationTimeoutInMs;
            // The number of milliseconds to use as the basis for calculating a random jitter amount
            // opening receiver links. This is intended to ensure that multiple
            // session operations don't timeout at the same exact moment.
            const openReceiveLinkBaseJitterInMs = 100;
            // The amount of time to subtract from the client timeout when setting the server timeout when attempting to
            // accept the next available session. This will decrease the likelihood that the client times out before receiving a
            // response from the server.
            const openReceiveLinkBufferInMs = 20;
            // The amount minimum threshold for the server timeout for which we will subtract the "openReceiveLinkBufferInMs".
            // If the server timeout is less than this, we will not subtract the additional buffer.
            const openReceiveLinkBufferThresholdInMs = 1000;
            // Subtract a random amount up to 100ms from the operation timeout as the jitter when attempting to open next available session link.
            // This prevents excessive resource usage when using high amounts of concurrency and accepting the next available session.
            // Take the min of 1% of the total timeout and the base jitter amount so that we don't end up subtracting more than 1% of the total timeout.
            const jitterBaseInMs = Math.min(timeoutInMs * 0.01, openReceiveLinkBaseJitterInMs);
            // We set the operation timeout on the properties not only to include the jitter, but also because the server will otherwise
            // restrict the maximum timeout to 1 minute and 5 seconds, regardless of the client timeout. We only do this for accepting next available
            // session as this is the only long-polling scenario.
            timeoutInMs = Math.floor(timeoutInMs - jitterBaseInMs * Math.random());
            // Subtract an additional constant buffer to reduce the likelihood that the client times out before the service which leads to unnecessary
            // network traffic. If the timeout is too short, we won't do this.
            if (timeoutInMs >= openReceiveLinkBufferThresholdInMs) {
                timeoutInMs -= openReceiveLinkBufferInMs;
            }
        }
        await messageSession._init({
            abortSignal: options?.abortSignal,
            timeoutInMs,
        });
        return messageSession;
    }
    removeLinkFromContext() {
        delete this._context.messageSessions[this.name];
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Typeguard that checks if the input is a credential type the clients accept.
 * @param thing - Any object.
 * @internal
 */
function isCredential(thing) {
    return coreAuth.isTokenCredential(thing) || coreAuth.isNamedKeyCredential(thing) || coreAuth.isSASCredential(thing);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A client that can create Sender instances for sending messages to queues and
 * topics as well as Receiver instances to receive messages from queues and subscriptions.
 */
class ServiceBusClient {
    constructor(fullyQualifiedNamespaceOrConnectionString1, credentialOrOptions2, options3) {
        if (isCredential(credentialOrOptions2)) {
            const fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;
            const credential = credentialOrOptions2;
            this._clientOptions = options3 || {};
            this._connectionContext = createConnectionContextForCredential(credential, fullyQualifiedNamespace, this._clientOptions);
        }
        else {
            const connectionString = fullyQualifiedNamespaceOrConnectionString1;
            this._clientOptions = credentialOrOptions2 || {};
            this._connectionContext = createConnectionContextForConnectionString(connectionString, this._clientOptions);
        }
        this.fullyQualifiedNamespace = this._connectionContext.config.host;
        this.identifier = ensureValidIdentifier(this.fullyQualifiedNamespace, this._clientOptions.identifier);
        this._clientOptions.retryOptions = this._clientOptions.retryOptions || {};
        const timeoutInMs = this._clientOptions.retryOptions.timeoutInMs;
        if (coreUtil.isDefined(timeoutInMs) &&
            (typeof timeoutInMs !== "number" || !isFinite(timeoutInMs) || timeoutInMs <= 0)) {
            throw new Error(`${timeoutInMs} is an invalid value for retryOptions.timeoutInMs`);
        }
    }
    createReceiver(queueOrTopicName1, optionsOrSubscriptionName2, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options3) {
        validateEntityPath(this._connectionContext.config, queueOrTopicName1);
        // NOTE: we don't currently have any options for this kind of receiver but
        // when we do make sure you pass them in and extract them.
        const { entityPath, receiveMode, options } = extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionName2, options3);
        let entityPathWithSubQueue = entityPath;
        if (options?.subQueueType) {
            switch (options?.subQueueType) {
                case "deadLetter":
                    entityPathWithSubQueue += "/$DeadLetterQueue";
                    break;
                case "transferDeadLetter":
                    entityPathWithSubQueue += "/$Transfer/$DeadLetterQueue";
                    break;
                default:
                    throw new Error(`Invalid subQueueType '${options?.subQueueType}' provided. Valid values are 'deadLetter' and 'transferDeadLetter'`);
            }
        }
        const maxLockAutoRenewDurationInMs = options?.maxAutoLockRenewalDurationInMs != null
            ? options.maxAutoLockRenewalDurationInMs
            : 5 * 60 * 1000;
        return new ServiceBusReceiverImpl(this._connectionContext, entityPathWithSubQueue, receiveMode, maxLockAutoRenewDurationInMs, options?.skipParsingBodyAsJson ?? false, options?.skipConvertingDate ?? false, this._clientOptions.retryOptions, options?.identifier);
    }
    /**
     * Creates an instance of {@link ServiceBusRuleManager} that is used to manage
     * the rules for a subscription.
     *
     * @param topicName - the topic to create {@link ServiceBusRuleManager}
     * @param subscriptionName - the subscription specific to the specified topic to create a {@link ServiceBusRuleManager} for.
     * @returns a {@link ServiceBusRuleManager} scoped to the specified subscription and topic.
     */
    createRuleManager(topicName, subscriptionName) {
        validateEntityPath(this._connectionContext.config, topicName);
        const { entityPath } = extractReceiverArguments(topicName, subscriptionName);
        return new ServiceBusRuleManagerImpl(this._connectionContext, entityPath, this._clientOptions.retryOptions);
    }
    async acceptSession(queueOrTopicName1, optionsOrSubscriptionNameOrSessionId2, optionsOrSessionId3, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options4) {
        validateEntityPath(this._connectionContext.config, queueOrTopicName1);
        let sessionId;
        let entityPath;
        let receiveMode;
        let options;
        if (typeof queueOrTopicName1 === "string" &&
            typeof optionsOrSubscriptionNameOrSessionId2 === "string" &&
            typeof optionsOrSessionId3 === "string") {
            // subscription constructor
            sessionId = optionsOrSessionId3;
            ({ entityPath, receiveMode, options } = extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionNameOrSessionId2, 
            // skip the session ID parameter (3)
            options4));
        }
        else if (typeof queueOrTopicName1 === "string" &&
            typeof optionsOrSubscriptionNameOrSessionId2 === "string" &&
            typeof optionsOrSessionId3 !== "string") {
            // queue constructor (but only because we know we're not a subscription constructor)
            sessionId = optionsOrSubscriptionNameOrSessionId2;
            ({ entityPath, receiveMode, options } = extractReceiverArguments(queueOrTopicName1, 
            // skip the session ID parameter (2)
            optionsOrSessionId3, undefined));
        }
        else {
            throw new Error("Unhandled set of parameters");
        }
        const messageSession = await MessageSession.create(ensureValidIdentifier(entityPath, options?.identifier), this._connectionContext, entityPath, sessionId, {
            maxAutoLockRenewalDurationInMs: options?.maxAutoLockRenewalDurationInMs,
            receiveMode,
            abortSignal: options?.abortSignal,
            retryOptions: this._clientOptions.retryOptions,
            skipParsingBodyAsJson: options?.skipParsingBodyAsJson ?? false,
            skipConvertingDate: options?.skipConvertingDate ?? false,
        });
        const sessionReceiver = new ServiceBusSessionReceiverImpl(messageSession, this._connectionContext, entityPath, receiveMode, options?.skipParsingBodyAsJson ?? false, options?.skipConvertingDate ?? false, this._clientOptions.retryOptions);
        return sessionReceiver;
    }
    async acceptNextSession(queueOrTopicName1, optionsOrSubscriptionName2, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options3) {
        validateEntityPath(this._connectionContext.config, queueOrTopicName1);
        const { entityPath, receiveMode, options } = extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionName2, options3);
        const messageSession = await MessageSession.create(ensureValidIdentifier(entityPath, options?.identifier), this._connectionContext, entityPath, undefined, {
            maxAutoLockRenewalDurationInMs: options?.maxAutoLockRenewalDurationInMs,
            receiveMode,
            abortSignal: options?.abortSignal,
            retryOptions: this._clientOptions.retryOptions,
            skipParsingBodyAsJson: options?.skipParsingBodyAsJson ?? false,
            skipConvertingDate: options?.skipConvertingDate ?? false,
        });
        const sessionReceiver = new ServiceBusSessionReceiverImpl(messageSession, this._connectionContext, entityPath, receiveMode, options?.skipParsingBodyAsJson ?? false, options?.skipConvertingDate ?? false, this._clientOptions.retryOptions);
        return sessionReceiver;
    }
    /**
     * Creates a Sender which can be used to send messages, schedule messages to be
     * sent at a later time and cancel such scheduled messages. No connection is made
     * to the service until one of the methods on the sender is called.
     * @param queueOrTopicName - The name of a queue or topic to send messages to.
     */
    createSender(queueOrTopicName, options = {}) {
        validateEntityPath(this._connectionContext.config, queueOrTopicName);
        return new ServiceBusSenderImpl(this._connectionContext, queueOrTopicName, this._clientOptions.retryOptions, options.identifier);
    }
    /**
     * Closes the underlying AMQP connection.
     * NOTE: this will also disconnect any Receiver or Sender instances created from this
     * instance.
     */
    close() {
        return ConnectionContext.close(this._connectionContext);
    }
}
/**
 * Helper to validate and extract the common arguments from both the create*Receiver() overloads that
 * have this pattern:
 *
 * queue, options
 * topic, subscription, options
 *
 * @internal
 */
function extractReceiverArguments(queueOrTopicName1, optionsOrSubscriptionName2, definitelyOptions3) {
    let entityPath;
    let options;
    if (typeof optionsOrSubscriptionName2 === "string") {
        const topic = queueOrTopicName1;
        const subscription = optionsOrSubscriptionName2;
        entityPath = `${topic}/Subscriptions/${subscription}`;
        options = definitelyOptions3;
    }
    else {
        entityPath = queueOrTopicName1;
        options = optionsOrSubscriptionName2;
    }
    let receiveMode;
    if (!options || !coreUtil.isDefined(options.receiveMode) || options.receiveMode === "peekLock") {
        receiveMode = "peekLock";
    }
    else if (options.receiveMode === "receiveAndDelete") {
        receiveMode = "receiveAndDelete";
    }
    else {
        throw new TypeError(`Invalid receiveMode '${options?.receiveMode}' provided. Valid values are 'peekLock' and 'receiveAndDelete'`);
    }
    delete options?.receiveMode;
    return {
        entityPath,
        receiveMode,
        options,
    };
}
/**
 * Validates that the EntityPath in the connection string (if any) matches with the
 * queue or topic name passed to the methods that create senders and receivers.
 *
 * @internal
 */
function validateEntityPath(connectionConfig, queueOrTopicName) {
    if (connectionConfig.entityPath && connectionConfig.entityPath !== queueOrTopicName) {
        throw new Error(entityPathMisMatchError);
    }
}

Object.defineProperty(exports, "MessagingError", {
    enumerable: true,
    get: function () { return coreAmqp.MessagingError; }
});
Object.defineProperty(exports, "RetryMode", {
    enumerable: true,
    get: function () { return coreAmqp.RetryMode; }
});
Object.defineProperty(exports, "TokenType", {
    enumerable: true,
    get: function () { return coreAmqp.TokenType; }
});
Object.defineProperty(exports, "delay", {
    enumerable: true,
    get: function () { return coreAmqp.delay; }
});
exports.ServiceBusAdministrationClient = ServiceBusAdministrationClient;
exports.ServiceBusClient = ServiceBusClient;
exports.ServiceBusError = ServiceBusError;
exports.isServiceBusError = isServiceBusError;
exports.parseServiceBusConnectionString = parseServiceBusConnectionString;
//# sourceMappingURL=index.js.map
